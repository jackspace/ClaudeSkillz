{
  "sections": {
    "Additional Features": "### Webhook Handling\r\n\r\n```typescript\r\n// webhooks.ts\r\nimport crypto from 'crypto';\r\n\r\nexport class WebhookHandler {\r\n  constructor(private secret: string) {}\r\n\r\n  verify(payload: string, signature: string): boolean {\r\n    const hmac = crypto.createHmac('sha256', this.secret);\r\n    const digest = hmac.update(payload).digest('hex');\r\n    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));\r\n  }\r\n\r\n  parse<T>(payload: string, signature: string): T {\r\n    if (!this.verify(payload, signature)) {\r\n      throw new Error('Invalid webhook signature');\r\n    }\r\n    return JSON.parse(payload);\r\n  }\r\n}\r\n```\r\n\r\n### Pagination Helper\r\n\r\n```typescript\r\n// pagination.ts\r\nexport class PaginationHelper<T> {\r\n  constructor(\r\n    private client: any,\r\n    private endpoint: string,\r\n    private pageSize: number = 100\r\n  ) {}\r\n\r\n  async *iterate(params?: any): AsyncGenerator<T> {\r\n    let hasMore = true;\r\n    let startingAfter: string | undefined;\r\n\r\n    while (hasMore) {\r\n      const response = await this.client[this.endpoint]({\r\n        ...params,\r\n        limit: this.pageSize,\r\n        starting_after: startingAfter,\r\n      });\r\n\r\n      for (const item of response.data) {\r\n        yield item;\r\n      }\r\n\r\n      hasMore = response.has_more;\r\n      if (hasMore && response.data.length > 0) {\r\n        startingAfter = response.data[response.data.length - 1].id;\r\n      }\r\n    }\r\n  }\r\n\r\n  async all(params?: any): Promise<T[]> {\r\n    const items: T[] = [];\r\n    for await (const item of this.iterate(params)) {\r\n      items.push(item);\r\n    }\r\n    return items;\r\n  }\r\n}\r\n```",
    "Activation Triggers": "- User says: \"integrate API\", \"API client\", \"connect to service\", \"create SDK\"\r\n- Requests for: Stripe integration, SendGrid, Twilio, any third-party API\r\n- \"Set up OAuth\" or \"implement API authentication\"",
    "Usage Examples": "See [examples.md](examples.md) for complete integration examples including:\r\n- Stripe API client\r\n- SendGrid email integration\r\n- GitHub API client\r\n- Custom REST API\r\n- GraphQL API client",
    "Quality Checklist": "Before delivering, verify:\r\n- ✅ TypeScript types for all endpoints\r\n- ✅ Authentication implemented correctly\r\n- ✅ Retry logic with exponential backoff\r\n- ✅ Rate limiting configured\r\n- ✅ Custom error classes\r\n- ✅ Mock responses for testing\r\n- ✅ README with usage examples\r\n- ✅ No hardcoded secrets",
    "Purpose": "Generates complete, production-ready API clients with all the boilerplate handled: TypeScript types, authentication, retry logic, rate limiting, and error handling.\r\n\r\n**For ADHD users**: Instant integration - no need to read API docs and implement everything manually.\r\n**For all users**: Saves hours of boilerplate code, type-safe, production-ready from day one.",
    "Quick Reference": "### Trigger Phrases\r\n- \"integrate API\"\r\n- \"API client\"\r\n- \"connect to service\"\r\n- \"create SDK\"\r\n- \"Stripe integration\"\r\n- \"OAuth setup\"\r\n\r\n### Supported Auth Types\r\n- API Key (Bearer, Custom Header)\r\n- OAuth 2.0 (Client Credentials, Authorization Code)\r\n- Basic Auth\r\n- Custom (user provides implementation)\r\n\r\n### Output Location\r\n- Linux/macOS: `~/.claude-artifacts/api-client-{name}-{timestamp}/`\r\n- Windows: `%USERPROFILE%\\.claude-artifacts\\api-client-{name}-{timestamp}\\`",
    "Delivery Format": "**Generated files**:\r\n1. Complete TypeScript API client\r\n2. README with usage examples\r\n3. Test file with mock examples\r\n4. Package.json with dependencies\r\n\r\n**Dependencies included**:\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"axios\": \"^1.5.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"typescript\": \"^5.2.0\",\r\n    \"@types/node\": \"^20.8.0\",\r\n    \"jest\": \"^29.7.0\",\r\n    \"@types/jest\": \"^29.5.0\"\r\n  }\r\n}\r\n```\r\n\r\n**Notify user**:\r\n```\r\n✅ **{API Name} Client** generated!\r\n\r\n**Features:**\r\n- ✅ TypeScript types\r\n- ✅ {Auth type} authentication\r\n- ✅ Automatic retries (up to 3x)\r\n- ✅ Rate limiting ({X} requests per {Y})\r\n- ✅ Error handling\r\n- ✅ Mock responses for testing\r\n\r\n**Generated files:**\r\n- client.ts (main client)\r\n- types.ts (TypeScript definitions)\r\n- auth.ts (authentication)\r\n- mocks.ts (test mocks)\r\n\r\n**Usage:**\r\n```typescript\r\nimport { {APIName}Client } from './client';\r\n\r\nconst client = new {APIName}Client({\r\n  baseURL: '{API_URL}',\r\n  apiKey: process.env.API_KEY,\r\n  rateLimit: { requests: 100, per: 'minute' }\r\n});\r\n\r\nconst customers = await client.listCustomers();\r\n```\r\n\r\n**Next steps:**\r\n1. Install dependencies: `npm install`\r\n2. Set API key in .env\r\n3. Import and use the client\r\n```",
    "Core Workflow": "### 1. Gather Requirements\r\n\r\nAsk user for:\r\n```javascript\r\n{\r\n  api_name: \"Stripe\",\r\n  api_base_url: \"https://api.stripe.com/v1\",\r\n  auth_type: \"api_key|oauth|bearer|basic\",\r\n  endpoints: [\r\n    { method: \"GET\", path: \"/customers\", description: \"List customers\" },\r\n    { method: \"POST\", path: \"/customers\", description: \"Create customer\" }\r\n  ],\r\n  rate_limit: { requests: 100, per: \"minute\" } // optional\r\n}\r\n```\r\n\r\n**If user provides API documentation URL**, fetch it and extract this information automatically.\r\n\r\n### 2. Generate TypeScript Client\r\n\r\n**File structure**:\r\n```\r\napi-client/\r\n├── client.ts              # Main client class\r\n├── types.ts               # TypeScript types\r\n├── auth.ts                # Authentication handler\r\n├── errors.ts              # Custom error classes\r\n├── retry.ts               # Retry logic\r\n├── rate-limiter.ts        # Rate limiting\r\n└── mocks.ts               # Mock responses for testing\r\n```\r\n\r\n### 3. Client Template\r\n\r\n```typescript\r\n// client.ts\r\nimport axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\r\nimport { AuthHandler } from './auth';\r\nimport { RateLimiter } from './rate-limiter';\r\nimport { RetryHandler } from './retry';\r\nimport { APIError, RateLimitError, AuthenticationError } from './errors';\r\nimport type { ClientConfig, APIResponse } from './types';\r\n\r\nexport class {APIName}Client {\r\n  private axios: AxiosInstance;\r\n  private auth: AuthHandler;\r\n  private rateLimiter: RateLimiter;\r\n  private retryHandler: RetryHandler;\r\n\r\n  constructor(config: ClientConfig) {\r\n    this.auth = new AuthHandler(config.apiKey);\r\n    this.rateLimiter = new RateLimiter(config.rateLimit);\r\n    this.retryHandler = new RetryHandler(config.retryConfig);\r\n\r\n    this.axios = axios.create({\r\n      baseURL: config.baseURL,\r\n      timeout: config.timeout || 30000,\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'User-Agent': '{APIName}-Client/1.0.0',\r\n        ...config.defaultHeaders,\r\n      },\r\n    });\r\n\r\n    // Request interceptor for auth\r\n    this.axios.interceptors.request.use(\r\n      async (config) => {\r\n        await this.rateLimiter.wait();\r\n        return this.auth.addAuthHeaders(config);\r\n      },\r\n      (error) => Promise.reject(error)\r\n    );\r\n\r\n    // Response interceptor for retry logic\r\n    this.axios.interceptors.response.use(\r\n      (response) => response,\r\n      async (error) => {\r\n        if (this.retryHandler.shouldRetry(error)) {\r\n          return this.retryHandler.retry(error);\r\n        }\r\n        return Promise.reject(this.handleError(error));\r\n      }\r\n    );\r\n  }\r\n\r\n  private handleError(error: any): Error {\r\n    if (error.response?.status === 401) {\r\n      return new AuthenticationError('Invalid API credentials');\r\n    }\r\n    if (error.response?.status === 429) {\r\n      return new RateLimitError('Rate limit exceeded');\r\n    }\r\n    if (error.response?.data?.message) {\r\n      return new APIError(error.response.data.message, error.response.status);\r\n    }\r\n    return new APIError('Unknown API error', error.response?.status);\r\n  }\r\n\r\n  // Generated methods for each endpoint\r\n  async listCustomers(params?: ListCustomersParams): Promise<APIResponse<Customer[]>> {\r\n    const response = await this.axios.get('/customers', { params });\r\n    return response.data;\r\n  }\r\n\r\n  async createCustomer(data: CreateCustomerData): Promise<APIResponse<Customer>> {\r\n    const response = await this.axios.post('/customers', data);\r\n    return response.data;\r\n  }\r\n\r\n  // ... more generated methods\r\n}\r\n```\r\n\r\n### 4. Authentication Handler\r\n\r\n```typescript\r\n// auth.ts\r\nimport { AxiosRequestConfig } from 'axios';\r\n\r\nexport type AuthConfig =\r\n  | { type: 'api_key'; key: string; header?: string }\r\n  | { type: 'bearer'; token: string }\r\n  | { type: 'oauth'; clientId: string; clientSecret: string; tokenUrl: string }\r\n  | { type: 'basic'; username: string; password: string };\r\n\r\nexport class AuthHandler {\r\n  private config: AuthConfig;\r\n  private accessToken?: string;\r\n  private tokenExpiry?: Date;\r\n\r\n  constructor(config: AuthConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async addAuthHeaders(axiosConfig: AxiosRequestConfig): Promise<AxiosRequestConfig> {\r\n    const headers = axiosConfig.headers || {};\r\n\r\n    switch (this.config.type) {\r\n      case 'api_key':\r\n        headers[this.config.header || 'Authorization'] = `Bearer ${this.config.key}`;\r\n        break;\r\n\r\n      case 'bearer':\r\n        headers['Authorization'] = `Bearer ${this.config.token}`;\r\n        break;\r\n\r\n      case 'oauth':\r\n        const token = await this.getOAuthToken();\r\n        headers['Authorization'] = `Bearer ${token}`;\r\n        break;\r\n\r\n      case 'basic':\r\n        const credentials = Buffer.from(\r\n          `${this.config.username}:${this.config.password}`\r\n        ).toString('base64');\r\n        headers['Authorization'] = `Basic ${credentials}`;\r\n        break;\r\n    }\r\n\r\n    return { ...axiosConfig, headers };\r\n  }\r\n\r\n  private async getOAuthToken(): Promise<string> {\r\n    // Check if token is still valid\r\n    if (this.accessToken && this.tokenExpiry && this.tokenExpiry > new Date()) {\r\n      return this.accessToken;\r\n    }\r\n\r\n    // Fetch new token\r\n    const response = await axios.post(this.config.tokenUrl, {\r\n      grant_type: 'client_credentials',\r\n      client_id: this.config.clientId,\r\n      client_secret: this.config.clientSecret,\r\n    });\r\n\r\n    this.accessToken = response.data.access_token;\r\n    this.tokenExpiry = new Date(Date.now() + response.data.expires_in * 1000);\r\n\r\n    return this.accessToken;\r\n  }\r\n}\r\n```\r\n\r\n### 5. Retry Logic\r\n\r\n```typescript\r\n// retry.ts\r\nimport { AxiosError, AxiosRequestConfig } from 'axios';\r\n\r\nexport interface RetryConfig {\r\n  maxRetries: number;\r\n  initialDelay: number; // ms\r\n  maxDelay: number; // ms\r\n  backoffFactor: number;\r\n  retryableStatuses: number[];\r\n}\r\n\r\nexport class RetryHandler {\r\n  private config: RetryConfig;\r\n  private retryCount: Map<string, number> = new Map();\r\n\r\n  constructor(config?: Partial<RetryConfig>) {\r\n    this.config = {\r\n      maxRetries: config?.maxRetries || 3,\r\n      initialDelay: config?.initialDelay || 1000,\r\n      maxDelay: config?.maxDelay || 30000,\r\n      backoffFactor: config?.backoffFactor || 2,\r\n      retryableStatuses: config?.retryableStatuses || [408, 429, 500, 502, 503, 504],\r\n    };\r\n  }\r\n\r\n  shouldRetry(error: AxiosError): boolean {\r\n    if (!error.response) return true; // Network error, retry\r\n    if (!this.config.retryableStatuses.includes(error.response.status)) return false;\r\n\r\n    const key = this.getRequestKey(error.config);\r\n    const count = this.retryCount.get(key) || 0;\r\n\r\n    return count < this.config.maxRetries;\r\n  }\r\n\r\n  async retry(error: AxiosError): Promise<any> {\r\n    const key = this.getRequestKey(error.config);\r\n    const count = this.retryCount.get(key) || 0;\r\n\r\n    this.retryCount.set(key, count + 1);\r\n\r\n    const delay = Math.min(\r\n      this.config.initialDelay * Math.pow(this.config.backoffFactor, count),\r\n      this.config.maxDelay\r\n    );\r\n\r\n    await this.sleep(delay);\r\n\r\n    return axios.request(error.config);\r\n  }\r\n\r\n  private getRequestKey(config: AxiosRequestConfig): string {\r\n    return `${config.method}:${config.url}`;\r\n  }\r\n\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n```\r\n\r\n### 6. Rate Limiter\r\n\r\n```typescript\r\n// rate-limiter.ts\r\nexport interface RateLimitConfig {\r\n  requests: number;\r\n  per: 'second' | 'minute' | 'hour';\r\n}\r\n\r\nexport class RateLimiter {\r\n  private config: RateLimitConfig;\r\n  private timestamps: number[] = [];\r\n\r\n  constructor(config: RateLimitConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  async wait(): Promise<void> {\r\n    const now = Date.now();\r\n    const windowMs = this.getWindowMs();\r\n\r\n    // Remove timestamps outside the window\r\n    this.timestamps = this.timestamps.filter((ts) => now - ts < windowMs);\r\n\r\n    if (this.timestamps.length >= this.config.requests) {\r\n      const oldestTimestamp = this.timestamps[0];\r\n      const waitTime = oldestTimestamp + windowMs - now;\r\n\r\n      if (waitTime > 0) {\r\n        await this.sleep(waitTime);\r\n        return this.wait(); // Recursive call after waiting\r\n      }\r\n    }\r\n\r\n    this.timestamps.push(now);\r\n  }\r\n\r\n  private getWindowMs(): number {\r\n    switch (this.config.per) {\r\n      case 'second':\r\n        return 1000;\r\n      case 'minute':\r\n        return 60000;\r\n      case 'hour':\r\n        return 3600000;\r\n    }\r\n  }\r\n\r\n  private sleep(ms: number): Promise<void> {\r\n    return new Promise((resolve) => setTimeout(resolve, ms));\r\n  }\r\n}\r\n```\r\n\r\n### 7. TypeScript Types\r\n\r\n```typescript\r\n// types.ts\r\nexport interface ClientConfig {\r\n  baseURL: string;\r\n  apiKey?: string;\r\n  oauthConfig?: OAuthConfig;\r\n  timeout?: number;\r\n  rateLimit?: RateLimitConfig;\r\n  retryConfig?: Partial<RetryConfig>;\r\n  defaultHeaders?: Record<string, string>;\r\n}\r\n\r\nexport interface OAuthConfig {\r\n  clientId: string;\r\n  clientSecret: string;\r\n  tokenUrl: string;\r\n}\r\n\r\nexport interface APIResponse<T> {\r\n  data: T;\r\n  status: number;\r\n  headers: Record<string, string>;\r\n}\r\n\r\nexport interface PaginatedResponse<T> {\r\n  data: T[];\r\n  page: number;\r\n  totalPages: number;\r\n  totalItems: number;\r\n  hasMore: boolean;\r\n}\r\n\r\n// Auto-generated types for each API entity\r\nexport interface Customer {\r\n  id: string;\r\n  email: string;\r\n  name: string;\r\n  created: number;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface CreateCustomerData {\r\n  email: string;\r\n  name?: string;\r\n  metadata?: Record<string, any>;\r\n}\r\n\r\nexport interface ListCustomersParams {\r\n  limit?: number;\r\n  starting_after?: string;\r\n  ending_before?: string;\r\n}\r\n```\r\n\r\n### 8. Custom Errors\r\n\r\n```typescript\r\n// errors.ts\r\nexport class APIError extends Error {\r\n  constructor(\r\n    message: string,\r\n    public statusCode?: number,\r\n    public response?: any\r\n  ) {\r\n    super(message);\r\n    this.name = 'APIError';\r\n  }\r\n}\r\n\r\nexport class AuthenticationError extends APIError {\r\n  constructor(message: string) {\r\n    super(message, 401);\r\n    this.name = 'AuthenticationError';\r\n  }\r\n}\r\n\r\nexport class RateLimitError extends APIError {\r\n  constructor(message: string, public retryAfter?: number) {\r\n    super(message, 429);\r\n    this.name = 'RateLimitError';\r\n  }\r\n}\r\n\r\nexport class ValidationError extends APIError {\r\n  constructor(message: string, public fields?: Record<string, string[]>) {\r\n    super(message, 400);\r\n    this.name = 'ValidationError';\r\n  }\r\n}\r\n```\r\n\r\n### 9. Mock Responses (for Testing)\r\n\r\n```typescript\r\n// mocks.ts\r\nexport const mockCustomers: Customer[] = [\r\n  {\r\n    id: 'cus_test123',\r\n    email: 'test@example.com',\r\n    name: 'Test User',\r\n    created: Date.now(),\r\n  },\r\n];\r\n\r\nexport const mockResponses = {\r\n  'GET /customers': {\r\n    data: mockCustomers,\r\n    status: 200,\r\n  },\r\n  'POST /customers': {\r\n    data: mockCustomers[0],\r\n    status: 201,\r\n  },\r\n};\r\n\r\nexport class Mock{APIName}Client {\r\n  async listCustomers(): Promise<APIResponse<Customer[]>> {\r\n    return mockResponses['GET /customers'];\r\n  }\r\n\r\n  async createCustomer(data: CreateCustomerData): Promise<APIResponse<Customer>> {\r\n    return mockResponses['POST /customers'];\r\n  }\r\n}\r\n```",
    "Success Criteria": "✅ Generated client compiles without errors\r\n✅ All endpoints have TypeScript types\r\n✅ Authentication works\r\n✅ Retries happen automatically\r\n✅ Rate limiting prevents 429 errors\r\n✅ Errors are properly caught and typed\r\n✅ Mock client available for testing\r\n✅ Production-ready code",
    "Integration with Other Skills": "### Context Manager\r\nSave API integration details:\r\n```\r\nremember: Integrated Stripe API\r\nType: PROCEDURE\r\nTags: api, stripe, payments, typescript\r\nContent: Stripe client with retry logic, rate limiting (100/min),\r\n         webhook verification implemented\r\n```\r\n\r\n### Error Debugger\r\nIf API integration has issues:\r\n```\r\nAutomatically invokes error-debugger for:\r\n- Authentication failures\r\n- Rate limit errors\r\n- Network timeouts\r\n```\r\n\r\n### Rapid Prototyper\r\nFor testing integration:\r\n```\r\nrapid-prototyper generates test server\r\n→ Mock API responses for development\r\n```",
    "Additional Resources": "- **[Integration Examples](examples.md)** - Complete API client examples\r\n- **[Reference Patterns](reference.md)** - Common API patterns and best practices"
  },
  "references": {
    "files": [
      "examples.md",
      "reference.md"
    ]
  },
  "id": "api-integration-builder",
  "name": "api-integration-builder",
  "description": "Generates production-ready API clients with TypeScript types, retry logic, rate limiting, authentication (OAuth, API keys), error handling, and mock responses. Use when user says \"integrate API\", \"API client\", \"connect to service\", or requests third-party service integration."
}