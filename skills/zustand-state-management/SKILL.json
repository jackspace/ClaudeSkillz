{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/example-reference.md",
      "references/middleware-guide.md",
      "references/migration-guide.md",
      "references/nextjs-hydration.md",
      "references/typescript-patterns.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-24\r\n**Latest Version**: zustand@5.0.8\r\n**Dependencies**: React 18+, TypeScript 5+\r\n\r\n---\r\n\r\n\r\n### 1. Install Zustand\r\n\r\n```bash\r\nnpm install zustand\r\npnpm add zustand\r\n\r\n### Templates (templates/)\r\n\r\nThis skill includes 8 ready-to-use template files:\r\n\r\n- `basic-store.ts` - Minimal JavaScript store example\r\n- `typescript-store.ts` - Properly typed TypeScript store\r\n- `persist-store.ts` - localStorage persistence with migration\r\n- `slices-pattern.ts` - Modular store organization\r\n- `devtools-store.ts` - Redux DevTools integration\r\n- `nextjs-store.ts` - SSR-safe Next.js store with hydration\r\n- `computed-store.ts` - Derived state patterns\r\n- `async-actions-store.ts` - Async operations with loading states\r\n\r\n**Example Usage:**\r\n```bash",
  "name": "zustand-state-management",
  "id": "zustand-state-management",
  "sections": {
    "The 3-Pattern Setup Process": "### Pattern 1: Basic Store (JavaScript)\r\n\r\nFor simple use cases without TypeScript:\r\n\r\n```javascript\r\nimport { create } from 'zustand'\r\n\r\nconst useStore = create((set) => ({\r\n  count: 0,\r\n  increment: () => set((state) => ({ count: state.count + 1 })),\r\n  decrement: () => set((state) => ({ count: state.count - 1 })),\r\n}))\r\n```\r\n\r\n**When to use:**\r\n- Prototyping\r\n- Small apps\r\n- No TypeScript in project\r\n\r\n### Pattern 2: TypeScript Store (Recommended)\r\n\r\nFor production apps with type safety:\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\n\r\n// Define store interface\r\ninterface CounterStore {\r\n  count: number\r\n  increment: () => void\r\n  decrement: () => void\r\n}\r\n\r\n// Create typed store\r\nconst useCounterStore = create<CounterStore>()((set) => ({\r\n  count: 0,\r\n  increment: () => set((state) => ({ count: state.count + 1 })),\r\n  decrement: () => set((state) => ({ count: state.count - 1 })),\r\n}))\r\n```\r\n\r\n**Key Points:**\r\n- Separate interface for state + actions\r\n- Use `create<T>()()` syntax (currying for middleware)\r\n- Full IDE autocomplete and type checking\r\n\r\n### Pattern 3: Persistent Store\r\n\r\nFor state that survives page reloads:\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\ninterface UserPreferences {\r\n  theme: 'light' | 'dark' | 'system'\r\n  language: string\r\n  setTheme: (theme: UserPreferences['theme']) => void\r\n  setLanguage: (language: string) => void\r\n}\r\n\r\nconst usePreferencesStore = create<UserPreferences>()(\r\n  persist(\r\n    (set) => ({\r\n      theme: 'system',\r\n      language: 'en',\r\n      setTheme: (theme) => set({ theme }),\r\n      setLanguage: (language) => set({ language }),\r\n    }),\r\n    {\r\n      name: 'user-preferences', // unique name in localStorage\r\n      storage: createJSONStorage(() => localStorage), // optional: defaults to localStorage\r\n    },\r\n  ),\r\n)\r\n```\r\n\r\n**Why this matters:**\r\n- State automatically saved to localStorage\r\n- Restored on page reload\r\n- Works with sessionStorage too\r\n- Handles serialization automatically\r\n\r\n---",
    "Complete Setup Checklist": "Use this checklist to verify your Zustand setup:\r\n\r\n- [ ] Installed `zustand@5.0.8` or later\r\n- [ ] Created store with proper TypeScript types\r\n- [ ] Used `create<T>()()` double parentheses syntax\r\n- [ ] Tested selector functions in components\r\n- [ ] Verified components only re-render when selected state changes\r\n- [ ] If using persist: Configured unique storage name\r\n- [ ] If using persist: Implemented hydration check for Next.js\r\n- [ ] If using devtools: Named actions for debugging\r\n- [ ] If using slices: Properly typed `StateCreator` for each slice\r\n- [ ] All actions are pure functions\r\n- [ ] No direct state mutations\r\n- [ ] Store works in production build\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check [references/typescript-patterns.md](references/typescript-patterns.md) for TypeScript help\r\n2. Check [references/nextjs-hydration.md](references/nextjs-hydration.md) for Next.js issues\r\n3. Check [references/middleware-guide.md](references/middleware-guide.md) for persist/devtools help\r\n4. Official docs: https://zustand.docs.pmnd.rs/\r\n5. GitHub issues: https://github.com/pmndrs/zustand/issues",
    "Known Issues Prevention": "This skill prevents **5** documented issues:\r\n\r\n### Issue #1: Next.js Hydration Mismatch\r\n\r\n**Error**: `\"Text content does not match server-rendered HTML\"` or `\"Hydration failed\"`\r\n\r\n**Source**:\r\n- [DEV Community: Persist middleware in Next.js](https://dev.to/abdulsamad/how-to-use-zustands-persist-middleware-in-nextjs-4lb5)\r\n- GitHub Discussions #2839\r\n\r\n**Why It Happens**:\r\nPersist middleware reads from localStorage on client but not on server, causing state mismatch.\r\n\r\n**Prevention**:\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { persist } from 'zustand/middleware'\r\n\r\ninterface StoreWithHydration {\r\n  count: number\r\n  _hasHydrated: boolean\r\n  setHasHydrated: (hydrated: boolean) => void\r\n  increase: () => void\r\n}\r\n\r\nconst useStore = create<StoreWithHydration>()(\r\n  persist(\r\n    (set) => ({\r\n      count: 0,\r\n      _hasHydrated: false,\r\n      setHasHydrated: (hydrated) => set({ _hasHydrated: hydrated }),\r\n      increase: () => set((state) => ({ count: state.count + 1 })),\r\n    }),\r\n    {\r\n      name: 'my-store',\r\n      onRehydrateStorage: () => (state) => {\r\n        state?.setHasHydrated(true)\r\n      },\r\n    },\r\n  ),\r\n)\r\n\r\n// In component\r\nfunction MyComponent() {\r\n  const hasHydrated = useStore((state) => state._hasHydrated)\r\n\r\n  if (!hasHydrated) {\r\n    return <div>Loading...</div>\r\n  }\r\n\r\n  // Now safe to render with persisted state\r\n  return <ActualContent />\r\n}\r\n```\r\n\r\n### Issue #2: TypeScript Double Parentheses Missing\r\n\r\n**Error**: Type inference fails, `StateCreator` types break with middleware\r\n\r\n**Source**: [Official Zustand TypeScript Guide](https://zustand.docs.pmnd.rs/guides/typescript)\r\n\r\n**Why It Happens**:\r\nThe currying syntax `create<T>()()` is required for middleware to work with TypeScript inference.\r\n\r\n**Prevention**:\r\n```typescript\r\n// ❌ WRONG - Single parentheses\r\nconst useStore = create<MyStore>((set) => ({\r\n  // ...\r\n}))\r\n\r\n// ✅ CORRECT - Double parentheses\r\nconst useStore = create<MyStore>()((set) => ({\r\n  // ...\r\n}))\r\n```\r\n\r\n**Rule**: Always use `create<T>()()` in TypeScript, even without middleware (future-proof).\r\n\r\n### Issue #3: Persist Middleware Import Error\r\n\r\n**Error**: `\"Attempted import error: 'createJSONStorage' is not exported from 'zustand/middleware'\"`\r\n\r\n**Source**: GitHub Discussion #2839\r\n\r\n**Why It Happens**:\r\nWrong import path or version mismatch between zustand and build tools.\r\n\r\n**Prevention**:\r\n```typescript\r\n// ✅ CORRECT imports for v5\r\nimport { create } from 'zustand'\r\nimport { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\n// Verify versions\r\n// zustand@5.0.8 includes createJSONStorage\r\n// zustand@4.x uses different API\r\n\r\n// Check your package.json\r\n// \"zustand\": \"^5.0.8\"\r\n```\r\n\r\n### Issue #4: Infinite Render Loop\r\n\r\n**Error**: Component re-renders infinitely, browser freezes\r\n\r\n**Source**: GitHub Discussions #2642\r\n\r\n**Why It Happens**:\r\nCreating new object references in selectors causes Zustand to think state changed.\r\n\r\n**Prevention**:\r\n```typescript\r\nimport { shallow } from 'zustand/shallow'\r\n\r\n// ❌ WRONG - Creates new object every time\r\nconst { bears, fishes } = useStore((state) => ({\r\n  bears: state.bears,\r\n  fishes: state.fishes,\r\n}))\r\n\r\n// ✅ CORRECT Option 1 - Select primitives separately\r\nconst bears = useStore((state) => state.bears)\r\nconst fishes = useStore((state) => state.fishes)\r\n\r\n// ✅ CORRECT Option 2 - Use shallow for multiple values\r\nconst { bears, fishes } = useStore(\r\n  (state) => ({ bears: state.bears, fishes: state.fishes }),\r\n  shallow,\r\n)\r\n```\r\n\r\n### Issue #5: Slices Pattern TypeScript Complexity\r\n\r\n**Error**: `StateCreator` types fail to infer, complex middleware types break\r\n\r\n**Source**: [Official Slices Pattern Guide](https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md)\r\n\r\n**Why It Happens**:\r\nCombining multiple slices requires explicit type annotations for middleware compatibility.\r\n\r\n**Prevention**:\r\n```typescript\r\nimport { create, StateCreator } from 'zustand'\r\n\r\n// Define slice types\r\ninterface BearSlice {\r\n  bears: number\r\n  addBear: () => void\r\n}\r\n\r\ninterface FishSlice {\r\n  fishes: number\r\n  addFish: () => void\r\n}\r\n\r\n// Create slices with proper types\r\nconst createBearSlice: StateCreator<\r\n  BearSlice & FishSlice,  // Combined store type\r\n  [],                      // Middleware mutators (empty if none)\r\n  [],                      // Chained middleware (empty if none)\r\n  BearSlice               // This slice's type\r\n> = (set) => ({\r\n  bears: 0,\r\n  addBear: () => set((state) => ({ bears: state.bears + 1 })),\r\n})\r\n\r\nconst createFishSlice: StateCreator<\r\n  BearSlice & FishSlice,\r\n  [],\r\n  [],\r\n  FishSlice\r\n> = (set) => ({\r\n  fishes: 0,\r\n  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),\r\n})\r\n\r\n// Combine slices\r\nconst useStore = create<BearSlice & FishSlice>()((...a) => ({\r\n  ...createBearSlice(...a),\r\n  ...createFishSlice(...a),\r\n}))\r\n```\r\n\r\n---",
    "Package Versions (Verified 2025-10-24)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"zustand\": \"^5.0.8\",\r\n    \"react\": \"^19.0.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/node\": \"^22.0.0\",\r\n    \"typescript\": \"^5.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n**Compatibility**:\r\n- React 18+, React 19 ✅\r\n- TypeScript 5+ ✅\r\n- Next.js 14+, Next.js 15+ ✅\r\n- Vite 5+ ✅\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ Use `create<T>()()` (double parentheses) in TypeScript for middleware compatibility\r\n✅ Define separate interfaces for state and actions\r\n✅ Use selector functions to extract specific state slices\r\n✅ Use `set` with updater functions for derived state: `set((state) => ({ count: state.count + 1 }))`\r\n✅ Use unique names for persist middleware storage keys\r\n✅ Handle Next.js hydration with `hasHydrated` flag pattern\r\n✅ Use `shallow` for selecting multiple values\r\n✅ Keep actions pure (no side effects except state updates)\r\n\r\n### Never Do\r\n\r\n❌ Use `create<T>(...)` (single parentheses) in TypeScript - breaks middleware types\r\n❌ Mutate state directly: `set((state) => { state.count++; return state })` - use immutable updates\r\n❌ Create new objects in selectors: `useStore((state) => ({ a: state.a }))` - causes infinite renders\r\n❌ Use same storage name for multiple stores - causes data collisions\r\n❌ Access localStorage during SSR without hydration check\r\n❌ Use Zustand for server state - use TanStack Query instead\r\n❌ Export store instance directly - always export the hook\r\n\r\n---",
    "Advanced Topics": "### Vanilla Store (Without React)\r\n\r\n```typescript\r\nimport { createStore } from 'zustand/vanilla'\r\n\r\nconst store = createStore<CounterStore>()((set) => ({\r\n  count: 0,\r\n  increment: () => set((state) => ({ count: state.count + 1 })),\r\n}))\r\n\r\n// Subscribe to changes\r\nconst unsubscribe = store.subscribe((state) => {\r\n  console.log('Count changed:', state.count)\r\n})\r\n\r\n// Get current state\r\nconsole.log(store.getState().count)\r\n\r\n// Update state\r\nstore.getState().increment()\r\n\r\n// Cleanup\r\nunsubscribe()\r\n```\r\n\r\n### Custom Middleware\r\n\r\n```typescript\r\nimport { StateCreator, StoreMutatorIdentifier } from 'zustand'\r\n\r\ntype Logger = <T>(\r\n  f: StateCreator<T, [], []>,\r\n  name?: string,\r\n) => StateCreator<T, [], []>\r\n\r\nconst logger: Logger = (f, name) => (set, get, store) => {\r\n  const loggedSet: typeof set = (...a) => {\r\n    set(...(a as Parameters<typeof set>))\r\n    console.log(`[${name}]:`, get())\r\n  }\r\n  return f(loggedSet, get, store)\r\n}\r\n\r\n// Use custom middleware\r\nconst useStore = create<MyStore>()(\r\n  logger((set) => ({\r\n    // store definition\r\n  }), 'MyStore'),\r\n)\r\n```\r\n\r\n### Immer Middleware (Mutable Updates)\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { immer } from 'zustand/middleware/immer'\r\n\r\ninterface TodoStore {\r\n  todos: Array<{ id: string; text: string }>\r\n  addTodo: (text: string) => void\r\n}\r\n\r\nconst useStore = create<TodoStore>()(\r\n  immer((set) => ({\r\n    todos: [],\r\n    addTodo: (text) =>\r\n      set((state) => {\r\n        // Mutate directly with Immer\r\n        state.todos.push({ id: Date.now().toString(), text })\r\n      }),\r\n  })),\r\n)\r\n```\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- `zustand@5.0.8` - State management library\r\n- `react@18.0.0+` - React framework\r\n\r\n**Optional**:\r\n- `@types/node` - For TypeScript path resolution\r\n- `immer` - For mutable update syntax\r\n- Redux DevTools Extension - For devtools middleware\r\n\r\n---",
    "Common Patterns": "### Pattern: Computed/Derived Values\r\n\r\n```typescript\r\ninterface StoreWithComputed {\r\n  items: string[]\r\n  addItem: (item: string) => void\r\n  // Computed in selector, not stored\r\n}\r\n\r\nconst useStore = create<StoreWithComputed>()((set) => ({\r\n  items: [],\r\n  addItem: (item) => set((state) => ({ items: [...state.items, item] })),\r\n}))\r\n\r\n// Use in component\r\nfunction ItemCount() {\r\n  const count = useStore((state) => state.items.length)\r\n  return <div>{count} items</div>\r\n}\r\n```\r\n\r\n### Pattern: Async Actions\r\n\r\n```typescript\r\ninterface AsyncStore {\r\n  data: string | null\r\n  isLoading: boolean\r\n  error: string | null\r\n  fetchData: () => Promise<void>\r\n}\r\n\r\nconst useAsyncStore = create<AsyncStore>()((set) => ({\r\n  data: null,\r\n  isLoading: false,\r\n  error: null,\r\n  fetchData: async () => {\r\n    set({ isLoading: true, error: null })\r\n    try {\r\n      const response = await fetch('/api/data')\r\n      const data = await response.text()\r\n      set({ data, isLoading: false })\r\n    } catch (error) {\r\n      set({ error: (error as Error).message, isLoading: false })\r\n    }\r\n  },\r\n}))\r\n```\r\n\r\n### Pattern: Resetting Store\r\n\r\n```typescript\r\ninterface ResettableStore {\r\n  count: number\r\n  name: string\r\n  increment: () => void\r\n  reset: () => void\r\n}\r\n\r\nconst initialState = {\r\n  count: 0,\r\n  name: '',\r\n}\r\n\r\nconst useStore = create<ResettableStore>()((set) => ({\r\n  ...initialState,\r\n  increment: () => set((state) => ({ count: state.count + 1 })),\r\n  reset: () => set(initialState),\r\n}))\r\n```\r\n\r\n### Pattern: Selector with Params\r\n\r\n```typescript\r\ninterface TodoStore {\r\n  todos: Array<{ id: string; text: string; done: boolean }>\r\n  addTodo: (text: string) => void\r\n  toggleTodo: (id: string) => void\r\n}\r\n\r\nconst useStore = create<TodoStore>()((set) => ({\r\n  todos: [],\r\n  addTodo: (text) =>\r\n    set((state) => ({\r\n      todos: [...state.todos, { id: Date.now().toString(), text, done: false }],\r\n    })),\r\n  toggleTodo: (id) =>\r\n    set((state) => ({\r\n      todos: state.todos.map((todo) =>\r\n        todo.id === id ? { ...todo, done: !todo.done } : todo\r\n      ),\r\n    })),\r\n}))\r\n\r\n// Use with parameter\r\nfunction Todo({ id }: { id: string }) {\r\n  const todo = useStore((state) => state.todos.find((t) => t.id === id))\r\n  const toggleTodo = useStore((state) => state.toggleTodo)\r\n\r\n  if (!todo) return null\r\n\r\n  return (\r\n    <div>\r\n      <input\r\n        type=\"checkbox\"\r\n        checked={todo.done}\r\n        onChange={() => toggleTodo(id)}\r\n      />\r\n      {todo.text}\r\n    </div>\r\n  )\r\n}\r\n```\r\n\r\n---",
    "Quick Start (3 Minutes)": "yarn add zustand\r\n```\r\n\r\n**Why Zustand?**\r\n- Minimal API: Only 1 function to learn (`create`)\r\n- No boilerplate: No providers, reducers, or actions\r\n- TypeScript-first: Excellent type inference\r\n- Fast: Fine-grained subscriptions prevent unnecessary re-renders\r\n- Flexible: Middleware for persistence, devtools, and more\r\n\r\n### 2. Create Your First Store (TypeScript)\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\n\r\ninterface BearStore {\r\n  bears: number\r\n  increase: (by: number) => void\r\n  reset: () => void\r\n}\r\n\r\nconst useBearStore = create<BearStore>()((set) => ({\r\n  bears: 0,\r\n  increase: (by) => set((state) => ({ bears: state.bears + by })),\r\n  reset: () => set({ bears: 0 }),\r\n}))\r\n```\r\n\r\n**CRITICAL**: Notice the **double parentheses** `create<T>()()` - this is required for TypeScript with middleware.\r\n\r\n### 3. Use Store in Components\r\n\r\n```tsx\r\nimport { useBearStore } from './store'\r\n\r\nfunction BearCounter() {\r\n  const bears = useBearStore((state) => state.bears)\r\n  return <h1>{bears} around here...</h1>\r\n}\r\n\r\nfunction Controls() {\r\n  const increase = useBearStore((state) => state.increase)\r\n  return <button onClick={() => increase(1)}>Add bear</button>\r\n}\r\n```\r\n\r\n**Why this works:**\r\n- Components only re-render when their selected state changes\r\n- No Context providers needed\r\n- Selector function extracts specific state slice\r\n\r\n---",
    "Troubleshooting": "### Problem: Store updates don't trigger re-renders\r\n**Solution**: Ensure you're using selector functions, not destructuring: `const bears = useStore(state => state.bears)` not `const { bears } = useStore()`\r\n\r\n### Problem: TypeScript errors with middleware\r\n**Solution**: Use double parentheses: `create<T>()()` not `create<T>()`\r\n\r\n### Problem: Persist middleware causes hydration error\r\n**Solution**: Implement `_hasHydrated` flag pattern (see Issue #1)\r\n\r\n### Problem: Actions not showing in Redux DevTools\r\n**Solution**: Pass action name as third parameter to `set`: `set(newState, undefined, 'actionName')`\r\n\r\n### Problem: Store state resets unexpectedly\r\n**Solution**: Check if using HMR (hot module replacement) - Zustand resets on module reload in development\r\n\r\n---",
    "Official Documentation": "- **Zustand**: https://zustand.docs.pmnd.rs/\r\n- **GitHub**: https://github.com/pmndrs/zustand\r\n- **TypeScript Guide**: https://zustand.docs.pmnd.rs/guides/typescript\r\n- **Slices Pattern**: https://github.com/pmndrs/zustand/blob/main/docs/guides/slices-pattern.md\r\n- **Context7 Library ID**: `/pmndrs/zustand`\r\n\r\n---",
    "Middleware Configuration": "### Persist Middleware (localStorage)\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { persist, createJSONStorage } from 'zustand/middleware'\r\n\r\ninterface MyStore {\r\n  data: string[]\r\n  addItem: (item: string) => void\r\n}\r\n\r\nconst useStore = create<MyStore>()(\r\n  persist(\r\n    (set) => ({\r\n      data: [],\r\n      addItem: (item) => set((state) => ({ data: [...state.data, item] })),\r\n    }),\r\n    {\r\n      name: 'my-storage',\r\n      storage: createJSONStorage(() => localStorage),\r\n      partialize: (state) => ({ data: state.data }), // Only persist 'data'\r\n    },\r\n  ),\r\n)\r\n```\r\n\r\n### Devtools Middleware (Redux DevTools)\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { devtools } from 'zustand/middleware'\r\n\r\ninterface CounterStore {\r\n  count: number\r\n  increment: () => void\r\n}\r\n\r\nconst useStore = create<CounterStore>()(\r\n  devtools(\r\n    (set) => ({\r\n      count: 0,\r\n      increment: () =>\r\n        set(\r\n          (state) => ({ count: state.count + 1 }),\r\n          undefined,\r\n          'counter/increment', // Action name in DevTools\r\n        ),\r\n    }),\r\n    { name: 'CounterStore' }, // Store name in DevTools\r\n  ),\r\n)\r\n```\r\n\r\n### Combining Multiple Middlewares\r\n\r\n```typescript\r\nimport { create } from 'zustand'\r\nimport { devtools, persist } from 'zustand/middleware'\r\n\r\nconst useStore = create<MyStore>()(\r\n  devtools(\r\n    persist(\r\n      (set) => ({\r\n        // store definition\r\n      }),\r\n      { name: 'my-storage' },\r\n    ),\r\n    { name: 'MyStore' },\r\n  ),\r\n)\r\n```\r\n\r\n**Order matters**: `devtools(persist(...))` shows persist actions in DevTools.\r\n\r\n---",
    "Using Bundled Resources": "cp ~/.claude/skills/zustand-state-management/templates/typescript-store.ts src/store/\r\n```\r\n\r\n**When to use each:**\r\n- Use `basic-store.ts` for quick prototypes\r\n- Use `typescript-store.ts` for most production apps\r\n- Use `persist-store.ts` when state needs to survive page reloads\r\n- Use `slices-pattern.ts` for large, complex stores (100+ lines)\r\n- Use `nextjs-store.ts` for Next.js projects with SSR\r\n\r\n### References (references/)\r\n\r\nDeep-dive documentation for complex scenarios:\r\n\r\n- `middleware-guide.md` - Complete middleware documentation (persist, devtools, immer, custom)\r\n- `typescript-patterns.md` - Advanced TypeScript patterns and troubleshooting\r\n- `nextjs-hydration.md` - SSR, hydration, and Next.js best practices\r\n- `migration-guide.md` - Migrating from Redux, Context API, or Zustand v4\r\n\r\n**When Claude should load these:**\r\n- Load `middleware-guide.md` when user asks about persistence, devtools, or custom middleware\r\n- Load `typescript-patterns.md` when encountering complex type inference issues\r\n- Load `nextjs-hydration.md` for Next.js-specific problems\r\n- Load `migration-guide.md` when migrating from other state management solutions\r\n\r\n### Scripts (scripts/)\r\n\r\n- `check-versions.sh` - Verify Zustand version and compatibility\r\n\r\n**Usage:**\r\n```bash\r\ncd your-project/\r\n~/.claude/skills/zustand-state-management/scripts/check-versions.sh\r\n```\r\n\r\n---"
  }
}