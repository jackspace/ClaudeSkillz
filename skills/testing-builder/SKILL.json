{
  "sections": {
    "Context Integration": "### Recall Testing Preferences\r\n\r\nBefore generating tests:\r\n\r\n```javascript\r\n// Query context-manager\r\nconst preferences = searchMemories({\r\n  type: 'PREFERENCE',\r\n  tags: ['testing', project],\r\n  recent: true\r\n});\r\n\r\n// Apply preferences\r\nconst testConfig = {\r\n  framework: preferences.framework || 'vitest',\r\n  style: preferences.style || 'describe/it',\r\n  coverage: preferences.coverage || 80,\r\n  naming: preferences.naming || '{name}.test.js'\r\n};\r\n```\r\n\r\n### Save Testing Patterns\r\n\r\nAfter generating tests:\r\n\r\n```bash\r\nremember: Testing pattern for API endpoints\r\nType: PROCEDURE\r\nTags: testing, api, integration\r\nContent: For API endpoints, always include:\r\n1. Happy path (200/201)\r\n2. Validation errors (400)\r\n3. Auth errors (401/403)\r\n4. Not found (404)\r\n5. Server errors (500)\r\n6. Rate limiting (429)\r\n```\r\n\r\n### Learn from Feedback\r\n\r\nIf user modifies generated tests:\r\n\r\n```javascript\r\n// Analyze what user changed\r\nconst changes = diff(generatedTest, userModifiedTest);\r\n\r\n// Save as new pattern if significant\r\nif (changes.significant) {\r\n  saveMemory({\r\n    type: 'PREFERENCE',\r\n    content: `User prefers ${changes.pattern}`,\r\n    tags: ['testing', 'user-preference']\r\n  });\r\n}\r\n```",
    "Activation Triggers": "- User says: \"write tests\", \"test this\", \"add tests\", \"coverage\"\r\n- After fixing bug: \"create regression test\"\r\n- Code review: \"needs tests\"\r\n- User mentions: \"unit test\", \"integration test\", \"E2E test\"",
    "Test Categories": "### Unit Tests\r\n\r\n**What to test**:\r\n- Pure functions\r\n- Utility functions\r\n- Component logic\r\n- Class methods\r\n\r\n**Focus on**:\r\n- Input/output correctness\r\n- Edge cases\r\n- Error conditions\r\n- Boundary values\r\n\r\n### Integration Tests\r\n\r\n**What to test**:\r\n- API endpoints\r\n- Database operations\r\n- Multiple components together\r\n- External service integration\r\n\r\n**Focus on**:\r\n- Component interactions\r\n- Data flow\r\n- Error propagation\r\n- Transaction handling\r\n\r\n### E2E Tests\r\n\r\n**What to test**:\r\n- Critical user flows\r\n- Complete features\r\n- Multi-step processes\r\n- Cross-page workflows\r\n\r\n**Focus on**:\r\n- User perspective\r\n- Real browser interaction\r\n- Full stack integration\r\n- Production-like environment\r\n\r\n### Regression Tests\r\n\r\n**When to create**:\r\n- After fixing a bug\r\n- Preventing known issues\r\n- Historical problems\r\n\r\n**Structure**:\r\n```javascript\r\ndescribe('Regression: Bug #123 - User map undefined', () => {\r\n  it('should handle undefined users array', () => {\r\n    // Test that previously failed\r\n    const result = renderUserList(undefined);\r\n    expect(result).not.toThrow();\r\n  });\r\n});\r\n```",
    "Purpose": "Automatic test generation that learns your testing style. Eliminates the ADHD barrier to testing by making it effortless:\r\n1. Analyzes code to understand what needs testing\r\n2. Recalls your testing patterns from memory\r\n3. Generates comprehensive test suite\r\n4. Ensures all edge cases covered\r\n5. Saves testing patterns for future\r\n\r\n**For ADHD users**: Zero friction - tests created instantly without manual effort.\r\n**For all users**: Comprehensive coverage without the tedious work.\r\n**Learning system**: Gets better at matching your testing style over time.",
    "Quick Reference": "### Test Generation Checklist\r\n\r\n✅ Happy path covered\r\n✅ Edge cases tested\r\n✅ Error conditions handled\r\n✅ Invalid inputs validated\r\n✅ Boundary values checked\r\n✅ Async operations handled\r\n✅ Mocks properly configured\r\n✅ Cleanup properly done\r\n✅ Assertions are meaningful\r\n\r\n### Common Test Patterns\r\n\r\n| Scenario | Pattern |\r\n|----------|---------|\r\n| Function | Input → Output assertions |\r\n| Component | Render → Query → Assert |\r\n| API | Request → Response → Assert |\r\n| Async | await → Promise → Result |\r\n| Error | Try/catch → Error assertion |\r\n| Mock | Setup → Call → Verify mock |\r\n\r\n### Trigger Phrases\r\n\r\n- \"write tests\"\r\n- \"test this\"\r\n- \"add coverage\"\r\n- \"create regression test\"\r\n- \"needs tests\"\r\n\r\n### File Locations\r\n\r\n- **Test patterns**: `/home/toowired/.claude-memories/procedures/` (tagged \"testing\")\r\n- **Test preferences**: `/home/toowired/.claude-memories/preferences/` (tagged \"testing\")\r\n- **Generated tests**: `{filename}.test.{ext}` or `tests/{filename}.test.{ext}`\r\n\r\n### Success Criteria\r\n\r\n✅ Tests generated in <30 seconds\r\n✅ Comprehensive coverage (80%+ by default)\r\n✅ All edge cases included\r\n✅ Tests follow project style\r\n✅ Zero manual effort required\r\n✅ Testing patterns saved for future",
    "Framework-Specific Patterns": "### Jest/Vitest (JavaScript/TypeScript)\r\n\r\n```javascript\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\r\n\r\ndescribe('Component', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks();\r\n  });\r\n\r\n  it('should do something', () => {\r\n    expect(result).toBe(expected);\r\n  });\r\n});\r\n```\r\n\r\n**Mocking**:\r\n```javascript\r\n// Mock module\r\nvi.mock('./api', () => ({\r\n  fetchData: vi.fn(() => Promise.resolve({ data: [] }))\r\n}));\r\n\r\n// Mock implementation\r\nconst mockFn = vi.fn().mockImplementation(() => 'value');\r\n```\r\n\r\n### Pytest (Python)\r\n\r\n```python\r\nimport pytest\r\nfrom mymodule import calculate_discount\r\n\r\nclass TestCalculateDiscount:\r\n    def test_regular_customer(self):\r\n        result = calculate_discount(100, 10, 'regular')\r\n        assert result == 90\r\n\r\n    def test_premium_customer(self):\r\n        result = calculate_discount(100, 10, 'premium')\r\n        assert result == 80\r\n\r\n    @pytest.mark.parametrize(\"price,discount,expected\", [\r\n        (100, 0, 100),\r\n        (100, 100, 0),\r\n        (0, 10, 0),\r\n    ])\r\n    def test_edge_cases(self, price, discount, expected):\r\n        result = calculate_discount(price, discount, 'regular')\r\n        assert result == expected\r\n```\r\n\r\n**Fixtures**:\r\n```python\r\n@pytest.fixture\r\ndef sample_user():\r\n    return {\r\n        'id': 1,\r\n        'email': 'test@example.com',\r\n        'name': 'Test User'\r\n    }\r\n\r\ndef test_user_creation(sample_user):\r\n    assert sample_user['email'] == 'test@example.com'\r\n```\r\n\r\n### React Testing Library\r\n\r\n```javascript\r\nimport { render, screen, fireEvent } from '@testing-library/react';\r\nimport { expect, test } from 'vitest';\r\nimport { UserList } from './UserList';\r\n\r\ntest('renders user list', () => {\r\n  const users = [\r\n    { id: 1, name: 'Alice' },\r\n    { id: 2, name: 'Bob' }\r\n  ];\r\n\r\n  render(<UserList users={users} />);\r\n\r\n  expect(screen.getByText('Alice')).toBeInTheDocument();\r\n  expect(screen.getByText('Bob')).toBeInTheDocument();\r\n});\r\n\r\ntest('handles empty user list', () => {\r\n  render(<UserList users={[]} />);\r\n\r\n  expect(screen.getByText('No users found')).toBeInTheDocument();\r\n});\r\n\r\ntest('handles user click', () => {\r\n  const handleClick = vi.fn();\r\n  const users = [{ id: 1, name: 'Alice' }];\r\n\r\n  render(<UserList users={users} onUserClick={handleClick} />);\r\n\r\n  fireEvent.click(screen.getByText('Alice'));\r\n\r\n  expect(handleClick).toHaveBeenCalledWith(users[0]);\r\n});\r\n```",
    "Integration with Other Skills": "### Error Debugger\r\n\r\nWhen error-debugger fixes a bug:\r\n```\r\nAutomatically invoke testing-builder\r\nCreate regression test for: {bug_scenario}\r\nEnsure test fails before fix, passes after\r\n```\r\n\r\n### Context Manager\r\n\r\nLoad testing preferences:\r\n```\r\nQuery for PREFERENCE with tags: [testing, test-framework]\r\nApply framework, style, coverage preferences\r\n```\r\n\r\nSave new patterns:\r\n```\r\nAfter generating tests for new scenario\r\nSave pattern as PROCEDURE for future reference\r\n```\r\n\r\n### Code Quality Auditor\r\n\r\nCheck test quality:\r\n```\r\nAfter generating tests:\r\n→ Invoke code-quality-auditor\r\n→ Verify test coverage\r\n→ Check for test smells\r\n→ Ensure meaningful assertions\r\n```",
    "Core Workflow": "remember: Testing pattern for authentication\r\nType: PROCEDURE\r\nTags: testing, authentication, integration\r\nContent: For auth endpoints, always test:\r\n- Valid credentials → success\r\n- Invalid credentials → 401\r\n- Missing fields → 400\r\n- Expired token → 401\r\n- Token refresh flow\r\n```"
  },
  "content": "### 1. Analyze Code\r\n\r\n**Step 1**: Identify what to test\r\n\r\n```javascript\r\n// Example: Analyzing a function\r\nfunction calculateDiscount(price, discountPercent, customerType) {\r\n  if (customerType === 'premium') {\r\n    discountPercent += 10;\r\n  }\r\n  return price * (1 - discountPercent / 100);\r\n}\r\n\r\n// Identify:\r\n- Function name: calculateDiscount\r\n- Parameters: price, discountPercent, customerType\r\n- Logic branches: premium vs non-premium\r\n- Edge cases: negative values, zero, boundary conditions\r\n- Return type: number\r\n```\r\n\r\n**Step 2**: Determine test type needed\r\n\r\n- **Unit test**: Pure functions, utilities, components\r\n- **Integration test**: Multiple components working together, API endpoints\r\n- **E2E test**: Full user workflows, critical paths\r\n- **Regression test**: Specific bug that was fixed\r\n\r\n### 2. Recall Testing Patterns\r\n\r\nQuery context-manager for:\r\n\r\n```\r\nsearch memories:\r\n- Type: PREFERENCE, PROCEDURE\r\n- Tags: testing, test-framework, test-style\r\n- Project: current project\r\n```\r\n\r\n**What to recall**:\r\n- Test framework (Jest, Vitest, Pytest, etc.)\r\n- Assertion style (expect, assert, should)\r\n- Test structure (describe/it, test blocks)\r\n- Mocking patterns (jest.mock, vi.mock)\r\n- Coverage requirements\r\n- File naming conventions\r\n\r\n**Example memory**:\r\n```\r\nPREFERENCE: Testing style for BOOSTBOX\r\n- Framework: Vitest\r\n- Assertion: expect()\r\n- Structure: describe/it blocks\r\n- Coverage: Minimum 80%\r\n- File naming: {filename}.test.js\r\n```\r\n\r\n### 3. Generate Test Suite\r\n\r\n**Unit Test Template**:\r\n\r\n```javascript\r\nimport { describe, it, expect } from 'vitest';\r\nimport { calculateDiscount } from './discount';\r\n\r\ndescribe('calculateDiscount', () => {\r\n  describe('basic calculations', () => {\r\n    it('should calculate discount correctly for regular customers', () => {\r\n      const result = calculateDiscount(100, 10, 'regular');\r\n      expect(result).toBe(90);\r\n    });\r\n\r\n    it('should add bonus discount for premium customers', () => {\r\n      const result = calculateDiscount(100, 10, 'premium');\r\n      expect(result).toBe(80); // 10% + 10% bonus\r\n    });\r\n  });\r\n\r\n  describe('edge cases', () => {\r\n    it('should handle zero discount', () => {\r\n      const result = calculateDiscount(100, 0, 'regular');\r\n      expect(result).toBe(100);\r\n    });\r\n\r\n    it('should handle 100% discount', () => {\r\n      const result = calculateDiscount(100, 100, 'regular');\r\n      expect(result).toBe(0);\r\n    });\r\n\r\n    it('should handle zero price', () => {\r\n      const result = calculateDiscount(0, 10, 'regular');\r\n      expect(result).toBe(0);\r\n    });\r\n  });\r\n\r\n  describe('invalid inputs', () => {\r\n    it('should handle negative price', () => {\r\n      const result = calculateDiscount(-100, 10, 'regular');\r\n      expect(result).toBeLessThan(0);\r\n    });\r\n\r\n    it('should handle invalid customer type', () => {\r\n      const result = calculateDiscount(100, 10, 'unknown');\r\n      expect(result).toBe(90); // Falls back to regular\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n**Integration Test Template** (API endpoint):\r\n\r\n```javascript\r\nimport { describe, it, expect, beforeAll, afterAll } from 'vitest';\r\nimport request from 'supertest';\r\nimport { app } from './app';\r\nimport { db } from './db';\r\n\r\ndescribe('POST /api/users', () => {\r\n  beforeAll(async () => {\r\n    await db.connect();\r\n  });\r\n\r\n  afterAll(async () => {\r\n    await db.disconnect();\r\n  });\r\n\r\n  it('should create a new user', async () => {\r\n    const response = await request(app)\r\n      .post('/api/users')\r\n      .send({\r\n        email: 'test@example.com',\r\n        name: 'Test User'\r\n      });\r\n\r\n    expect(response.status).toBe(201);\r\n    expect(response.body).toHaveProperty('id');\r\n    expect(response.body.email).toBe('test@example.com');\r\n  });\r\n\r\n  it('should reject duplicate email', async () => {\r\n    await request(app).post('/api/users').send({\r\n      email: 'duplicate@example.com',\r\n      name: 'User 1'\r\n    });\r\n\r\n    const response = await request(app)\r\n      .post('/api/users')\r\n      .send({\r\n        email: 'duplicate@example.com',\r\n        name: 'User 2'\r\n      });\r\n\r\n    expect(response.status).toBe(409);\r\n    expect(response.body.error).toContain('already exists');\r\n  });\r\n\r\n  it('should validate required fields', async () => {\r\n    const response = await request(app)\r\n      .post('/api/users')\r\n      .send({\r\n        name: 'No Email'\r\n      });\r\n\r\n    expect(response.status).toBe(400);\r\n    expect(response.body.error).toContain('email');\r\n  });\r\n});\r\n```\r\n\r\n**E2E Test Template** (Playwright):\r\n\r\n```javascript\r\nimport { test, expect } from '@playwright/test';\r\n\r\ntest.describe('User Login Flow', () => {\r\n  test('should login successfully with valid credentials', async ({ page }) => {\r\n    await page.goto('/login');\r\n\r\n    await page.fill('[name=\"email\"]', 'user@example.com');\r\n    await page.fill('[name=\"password\"]', 'password123');\r\n    await page.click('button[type=\"submit\"]');\r\n\r\n    await expect(page).toHaveURL('/dashboard');\r\n    await expect(page.locator('.welcome-message')).toContainText('Welcome');\r\n  });\r\n\r\n  test('should show error with invalid credentials', async ({ page }) => {\r\n    await page.goto('/login');\r\n\r\n    await page.fill('[name=\"email\"]', 'wrong@example.com');\r\n    await page.fill('[name=\"password\"]', 'wrongpass');\r\n    await page.click('button[type=\"submit\"]');\r\n\r\n    await expect(page.locator('.error-message')).toContainText('Invalid');\r\n    await expect(page).toHaveURL('/login');\r\n  });\r\n\r\n  test('should validate required fields', async ({ page }) => {\r\n    await page.goto('/login');\r\n\r\n    await page.click('button[type=\"submit\"]');\r\n\r\n    await expect(page.locator('[name=\"email\"]:invalid')).toBeVisible();\r\n    await expect(page.locator('[name=\"password\"]:invalid')).toBeVisible();\r\n  });\r\n});\r\n```\r\n\r\n### 4. Coverage Analysis\r\n\r\n**Check what's tested**:\r\n\r\n```javascript\r\n// Coverage requirements (from memory or defaults)\r\nconst requirements = {\r\n  statements: 80,\r\n  branches: 75,\r\n  functions: 90,\r\n  lines: 80\r\n};\r\n\r\n// Identify untested scenarios\r\nconst missing = [\r\n  'Error handling for network failures',\r\n  'Loading state transitions',\r\n  'Concurrent operations',\r\n  'Cleanup on unmount'\r\n];\r\n\r\n// Generate additional tests for missing coverage\r\n```\r\n\r\n### 5. Save Testing Patterns\r\n\r\nAfter generating tests:\r\n\r\n```bash",
  "id": "testing-builder",
  "name": "testing-builder",
  "description": "Automatically generates comprehensive test suites (unit, integration, E2E) based on code and past testing patterns. Use when user says \"write tests\", \"test this\", \"add coverage\", or after fixing bugs to create regression tests. Eliminates testing friction for ADHD users."
}