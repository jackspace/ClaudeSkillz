{
  "description": "Use this skill when working with symbolic mathematics in Python. This skill should be used for symbolic computation tasks including solving equations algebraically, performing calculus operations (derivatives, integrals, limits), manipulating algebraic expressions, working with matrices symbolically, physics calculations, number theory problems, geometry computations, and generating executable code from mathematical expressions. Apply this skill when the user needs exact symbolic results rather than numerical approximations, or when working with mathematical formulas that contain variables and parameters.",
  "references": {
    "files": [
      "references/advanced-topics.md",
      "references/code-generation-printing.md",
      "references/core-capabilities.md",
      "references/matrices-linear-algebra.md",
      "references/physics-mechanics.md"
    ]
  },
  "content": "### 1. Symbolic Computation Basics\r\n\r\n**Creating symbols and expressions:**\r\n```python\r\nfrom sympy import symbols, Symbol\r\nx, y, z = symbols('x y z')\r\nexpr = x**2 + 2*x + 1\r\n\r\nx = symbols('x', real=True, positive=True)\r\nn = symbols('n', integer=True)\r\n```\r\n\r\n**Simplification and manipulation:**\r\n```python\r\nfrom sympy import simplify, expand, factor, cancel\r\nsimplify(sin(x)**2 + cos(x)**2)  # Returns 1\r\nexpand((x + 1)**3)  # x**3 + 3*x**2 + 3*x + 1\r\nfactor(x**2 - 1)    # (x - 1)*(x + 1)\r\n```\r\n\r\n**For detailed basics:** See `references/core-capabilities.md`\r\n\r\n### 2. Calculus\r\n\r\n**Derivatives:**\r\n```python\r\nfrom sympy import diff\r\ndiff(x**2, x)        # 2*x\r\ndiff(x**4, x, 3)     # 24*x (third derivative)\r\ndiff(x**2*y**3, x, y)  # 6*x*y**2 (partial derivatives)\r\n```\r\n\r\n**Integrals:**\r\n```python\r\nfrom sympy import integrate, oo\r\nintegrate(x**2, x)              # x**3/3 (indefinite)\r\nintegrate(x**2, (x, 0, 1))      # 1/3 (definite)\r\nintegrate(exp(-x), (x, 0, oo))  # 1 (improper)\r\n```\r\n\r\n**Limits and Series:**\r\n```python\r\nfrom sympy import limit, series\r\nlimit(sin(x)/x, x, 0)  # 1\r\nseries(exp(x), x, 0, 6)  # 1 + x + x**2/2 + x**3/6 + x**4/24 + x**5/120 + O(x**6)\r\n```\r\n\r\n**For detailed calculus operations:** See `references/core-capabilities.md`\r\n\r\n### 3. Equation Solving\r\n\r\n**Algebraic equations:**\r\n```python\r\nfrom sympy import solveset, solve, Eq\r\nsolveset(x**2 - 4, x)  # {-2, 2}\r\nsolve(Eq(x**2, 4), x)  # [-2, 2]\r\n```\r\n\r\n**Systems of equations:**\r\n```python\r\nfrom sympy import linsolve, nonlinsolve\r\nlinsolve([x + y - 2, x - y], x, y)  # {(1, 1)} (linear)\r\nnonlinsolve([x**2 + y - 2, x + y**2 - 3], x, y)  # (nonlinear)\r\n```\r\n\r\n**Differential equations:**\r\n```python\r\nfrom sympy import Function, dsolve, Derivative\r\nf = symbols('f', cls=Function)\r\ndsolve(Derivative(f(x), x) - f(x), f(x))  # Eq(f(x), C1*exp(x))\r\n```\r\n\r\n**For detailed solving methods:** See `references/core-capabilities.md`\r\n\r\n### 4. Matrices and Linear Algebra\r\n\r\n**Matrix creation and operations:**\r\n```python\r\nfrom sympy import Matrix, eye, zeros\r\nM = Matrix([[1, 2], [3, 4]])\r\nM_inv = M**-1  # Inverse\r\nM.det()        # Determinant\r\nM.T            # Transpose\r\n```\r\n\r\n**Eigenvalues and eigenvectors:**\r\n```python\r\neigenvals = M.eigenvals()  # {eigenvalue: multiplicity}\r\neigenvects = M.eigenvects()  # [(eigenval, mult, [eigenvectors])]\r\nP, D = M.diagonalize()  # M = P*D*P^-1\r\n```\r\n\r\n**Solving linear systems:**\r\n```python\r\nA = Matrix([[1, 2], [3, 4]])\r\nb = Matrix([5, 6])\r\nx = A.solve(b)  # Solve Ax = b\r\n```\r\n\r\n**For comprehensive linear algebra:** See `references/matrices-linear-algebra.md`\r\n\r\n### 5. Physics and Mechanics\r\n\r\n**Classical mechanics:**\r\n```python\r\nfrom sympy.physics.mechanics import dynamicsymbols, LagrangesMethod\r\nfrom sympy import symbols\r\n\r\nq = dynamicsymbols('q')\r\nm, g, l = symbols('m g l')\r\n\r\nL = m*(l*q.diff())**2/2 - m*g*l*(1 - cos(q))\r\n\r\n\r\n### 1. Always Define Symbols First\r\n\r\n```python\r\nfrom sympy import symbols\r\nx, y, z = symbols('x y z')\r\n```\r\n\r\n### 2. Use Assumptions for Better Simplification\r\n\r\n```python\r\nx = symbols('x', positive=True, real=True)\r\nsqrt(x**2)  # Returns x (not Abs(x)) due to positive assumption\r\n```\r\n\r\nCommon assumptions: `real`, `positive`, `negative`, `integer`, `rational`, `complex`, `even`, `odd`\r\n\r\n### 3. Use Exact Arithmetic\r\n\r\n```python\r\nfrom sympy import Rational, S\r\nexpr = Rational(1, 2) * x\r\nexpr = S(1)/2 * x\r\n\r\nexpr = 0.5 * x  # Creates approximate value\r\n```\r\n\r\n### 4. Numerical Evaluation When Needed\r\n\r\n```python\r\nfrom sympy import pi, sqrt\r\nresult = sqrt(8) + pi\r\nresult.evalf()    # 5.96371554103586\r\nresult.evalf(50)  # 50 digits of precision\r\n```\r\n\r\n### 5. Convert to NumPy for Performance\r\n\r\n```python\r\nfor x_val in range(1000):\r\n    result = expr.subs(x, x_val).evalf()\r\n\r\n\r\n### Pattern 1: Solve and Verify\r\n\r\n```python\r\nfrom sympy import symbols, solve, simplify\r\nx = symbols('x')\r\n\r\nequation = x**2 - 5*x + 6\r\nsolutions = solve(equation, x)  # [2, 3]\r\n\r\nfor sol in solutions:\r\n    result = simplify(equation.subs(x, sol))\r\n    assert result == 0\r\n```\r\n\r\n### Pattern 2: Symbolic to Numeric Pipeline\r\n\r\n```python\r\nx, y = symbols('x y')\r\nexpr = sin(x) + cos(y)\r\n\r\nsimplified = simplify(expr)\r\nderivative = diff(simplified, x)\r\n\r\nf = lambdify((x, y), derivative, 'numpy')\r\n\r\nresults = f(x_data, y_data)\r\n```\r\n\r\n### Pattern 3: Document Mathematical Results\r\n\r\n```python\r\nintegral_expr = Integral(x**2, (x, 0, 1))\r\nresult = integral_expr.doit()\r\n\r\n\r\n### With NumPy\r\n\r\n```python\r\nimport numpy as np\r\nfrom sympy import symbols, lambdify\r\n\r\nx = symbols('x')\r\nexpr = x**2 + 2*x + 1\r\n\r\nf = lambdify(x, expr, 'numpy')\r\nx_array = np.linspace(-5, 5, 100)\r\ny_array = f(x_array)\r\n```\r\n\r\n### With Matplotlib\r\n\r\n```python\r\nimport matplotlib.pyplot as plt\r\nimport numpy as np\r\nfrom sympy import symbols, lambdify, sin\r\n\r\nx = symbols('x')\r\nexpr = sin(x) / x\r\n\r\nf = lambdify(x, expr, 'numpy')\r\nx_vals = np.linspace(-10, 10, 1000)\r\ny_vals = f(x_vals)\r\n\r\nplt.plot(x_vals, y_vals)\r\nplt.show()\r\n```\r\n\r\n### With SciPy\r\n\r\n```python\r\nfrom scipy.optimize import fsolve\r\nfrom sympy import symbols, lambdify\r\n\r\nx = symbols('x')\r\nequation = x**3 - 2*x - 5\r\n\r\nf = lambdify(x, equation, 'numpy')\r\n\r\n\r\n```python\r\nfrom sympy import symbols, Symbol\r\nx, y = symbols('x y')\r\n\r\nfrom sympy import simplify, expand, factor, collect, cancel\r\nfrom sympy import sqrt, exp, log, sin, cos, tan, pi, E, I, oo\r\n\r\nfrom sympy import diff, integrate, limit, series, Derivative, Integral\r\n\r\nfrom sympy import solve, solveset, linsolve, nonlinsolve, dsolve\r\n\r\nfrom sympy import Matrix, eye, zeros, ones, diag\r\n\r\nfrom sympy import And, Or, Not, Implies, FiniteSet, Interval, Union\r\n\r\nfrom sympy import latex, pprint, lambdify, init_printing\r\n\r\n\r\n### Example 1: Solve Quadratic Equation\r\n```python\r\nfrom sympy import symbols, solve, sqrt\r\nx = symbols('x')\r\nsolution = solve(x**2 - 5*x + 6, x)\r\n```\r\n\r\n### Example 2: Calculate Derivative\r\n```python\r\nfrom sympy import symbols, diff, sin\r\nx = symbols('x')\r\nf = sin(x**2)\r\ndf_dx = diff(f, x)\r\n```\r\n\r\n### Example 3: Evaluate Integral\r\n```python\r\nfrom sympy import symbols, integrate, exp\r\nx = symbols('x')\r\nintegral = integrate(x * exp(-x**2), (x, 0, oo))\r\n```\r\n\r\n### Example 4: Matrix Eigenvalues\r\n```python\r\nfrom sympy import Matrix\r\nM = Matrix([[1, 2], [2, 1]])\r\neigenvals = M.eigenvals()\r\n```\r\n\r\n### Example 5: Generate Python Function\r\n```python\r\nfrom sympy import symbols, lambdify\r\nimport numpy as np\r\nx = symbols('x')\r\nexpr = x**2 + 2*x + 1\r\nf = lambdify(x, expr, 'numpy')\r\nf(np.array([1, 2, 3]))",
  "name": "sympy",
  "id": "scientific-pkg-sympy",
  "sections": {
    "Getting Started Examples": "```",
    "Additional Resources": "- Official Documentation: https://docs.sympy.org/\r\n- Tutorial: https://docs.sympy.org/latest/tutorials/intro-tutorial/index.html\r\n- API Reference: https://docs.sympy.org/latest/reference/index.html\r\n- Examples: https://github.com/sympy/sympy/tree/master/examples",
    "Reference Files Structure": "This skill uses modular reference files for different capabilities:\r\n\r\n1. **`core-capabilities.md`**: Symbols, algebra, calculus, simplification, equation solving\r\n   - Load when: Basic symbolic computation, calculus, or solving equations\r\n\r\n2. **`matrices-linear-algebra.md`**: Matrix operations, eigenvalues, linear systems\r\n   - Load when: Working with matrices or linear algebra problems\r\n\r\n3. **`physics-mechanics.md`**: Classical mechanics, quantum mechanics, vectors, units\r\n   - Load when: Physics calculations or mechanics problems\r\n\r\n4. **`advanced-topics.md`**: Geometry, number theory, combinatorics, logic, statistics\r\n   - Load when: Advanced mathematical topics beyond basic algebra and calculus\r\n\r\n5. **`code-generation-printing.md`**: Lambdify, codegen, LaTeX output, printing\r\n   - Load when: Converting expressions to code or generating formatted output",
    "Overview": "SymPy is a Python library for symbolic mathematics that enables exact computation using mathematical symbols rather than numerical approximations. This skill provides comprehensive guidance for performing symbolic algebra, calculus, linear algebra, equation solving, physics calculations, and code generation using SymPy.",
    "Working with SymPy: Best Practices": "f = lambdify(x, expr, 'numpy')\r\nresults = f(np.arange(1000))\r\n```\r\n\r\n### 6. Use Appropriate Solvers\r\n\r\n- `solveset`: Algebraic equations (primary)\r\n- `linsolve`: Linear systems\r\n- `nonlinsolve`: Nonlinear systems\r\n- `dsolve`: Differential equations\r\n- `solve`: General purpose (legacy, but flexible)",
    "When to Use This Skill": "Use this skill when:\r\n- Solving equations symbolically (algebraic, differential, systems of equations)\r\n- Performing calculus operations (derivatives, integrals, limits, series)\r\n- Manipulating and simplifying algebraic expressions\r\n- Working with matrices and linear algebra symbolically\r\n- Doing physics calculations (mechanics, quantum mechanics, vector analysis)\r\n- Number theory computations (primes, factorization, modular arithmetic)\r\n- Geometric calculations (2D/3D geometry, analytic geometry)\r\n- Converting mathematical expressions to executable code (Python, C, Fortran)\r\n- Generating LaTeX or other formatted mathematical output\r\n- Needing exact mathematical results (e.g., `sqrt(2)` not `1.414...`)",
    "Integration with Scientific Workflows": "solution = fsolve(f, 2)\r\n```",
    "Quick Reference: Most Common Functions": "from sympy import evalf, N, nsimplify\r\n```",
    "Common Use Case Patterns": "print(f\"LaTeX: {latex(integral_expr)} = {latex(result)}\")\r\nprint(f\"Pretty: {pretty(integral_expr)} = {pretty(result)}\")\r\nprint(f\"Numerical: {result.evalf()}\")\r\n```",
    "Core Capabilities": "LM = LagrangesMethod(L, [q])\r\n```\r\n\r\n**Vector analysis:**\r\n```python\r\nfrom sympy.physics.vector import ReferenceFrame, dot, cross\r\nN = ReferenceFrame('N')\r\nv1 = 3*N.x + 4*N.y\r\nv2 = 1*N.x + 2*N.z\r\ndot(v1, v2)  # Dot product\r\ncross(v1, v2)  # Cross product\r\n```\r\n\r\n**Quantum mechanics:**\r\n```python\r\nfrom sympy.physics.quantum import Ket, Bra, Commutator\r\npsi = Ket('psi')\r\nA = Operator('A')\r\ncomm = Commutator(A, B).doit()\r\n```\r\n\r\n**For detailed physics capabilities:** See `references/physics-mechanics.md`\r\n\r\n### 6. Advanced Mathematics\r\n\r\nThe skill includes comprehensive support for:\r\n\r\n- **Geometry:** 2D/3D analytic geometry, points, lines, circles, polygons, transformations\r\n- **Number Theory:** Primes, factorization, GCD/LCM, modular arithmetic, Diophantine equations\r\n- **Combinatorics:** Permutations, combinations, partitions, group theory\r\n- **Logic and Sets:** Boolean logic, set theory, finite and infinite sets\r\n- **Statistics:** Probability distributions, random variables, expectation, variance\r\n- **Special Functions:** Gamma, Bessel, orthogonal polynomials, hypergeometric functions\r\n- **Polynomials:** Polynomial algebra, roots, factorization, Groebner bases\r\n\r\n**For detailed advanced topics:** See `references/advanced-topics.md`\r\n\r\n### 7. Code Generation and Output\r\n\r\n**Convert to executable functions:**\r\n```python\r\nfrom sympy import lambdify\r\nimport numpy as np\r\n\r\nexpr = x**2 + 2*x + 1\r\nf = lambdify(x, expr, 'numpy')  # Create NumPy function\r\nx_vals = np.linspace(0, 10, 100)\r\ny_vals = f(x_vals)  # Fast numerical evaluation\r\n```\r\n\r\n**Generate C/Fortran code:**\r\n```python\r\nfrom sympy.utilities.codegen import codegen\r\n[(c_name, c_code), (h_name, h_header)] = codegen(\r\n    ('my_func', expr), 'C'\r\n)\r\n```\r\n\r\n**LaTeX output:**\r\n```python\r\nfrom sympy import latex\r\nlatex_str = latex(expr)  # Convert to LaTeX for documents\r\n```\r\n\r\n**For comprehensive code generation:** See `references/code-generation-printing.md`",
    "Troubleshooting Common Issues": "1. **\"NameError: name 'x' is not defined\"**\r\n   - Solution: Always define symbols using `symbols()` before use\r\n\r\n2. **Unexpected numerical results**\r\n   - Issue: Using floating-point numbers like `0.5` instead of `Rational(1, 2)`\r\n   - Solution: Use `Rational()` or `S()` for exact arithmetic\r\n\r\n3. **Slow performance in loops**\r\n   - Issue: Using `subs()` and `evalf()` repeatedly\r\n   - Solution: Use `lambdify()` to create a fast numerical function\r\n\r\n4. **\"Can't solve this equation\"**\r\n   - Try different solvers: `solve`, `solveset`, `nsolve` (numerical)\r\n   - Check if the equation is solvable algebraically\r\n   - Use numerical methods if no closed-form solution exists\r\n\r\n5. **Simplification not working as expected**\r\n   - Try different simplification functions: `simplify`, `factor`, `expand`, `trigsimp`\r\n   - Add assumptions to symbols (e.g., `positive=True`)\r\n   - Use `simplify(expr, force=True)` for aggressive simplification"
  }
}