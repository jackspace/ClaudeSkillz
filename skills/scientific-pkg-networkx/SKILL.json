{
  "description": "Comprehensive toolkit for creating, analyzing, and visualizing complex networks and graphs in Python. Use when working with network/graph data structures, analyzing relationships between entities, computing graph algorithms (shortest paths, centrality, clustering), detecting communities, generating synthetic networks, or visualizing network topologies. Applicable to social networks, biological networks, transportation systems, citation networks, and any domain involving pairwise relationships.",
  "references": {
    "files": [
      "references/algorithms.md",
      "references/generators.md",
      "references/graph-basics.md",
      "references/io.md",
      "references/visualization.md"
    ]
  },
  "content": "### 1. Graph Creation and Manipulation\r\n\r\nNetworkX supports four main graph types:\r\n- **Graph**: Undirected graphs with single edges\r\n- **DiGraph**: Directed graphs with one-way connections\r\n- **MultiGraph**: Undirected graphs allowing multiple edges between nodes\r\n- **MultiDiGraph**: Directed graphs with multiple edges\r\n\r\nCreate graphs by:\r\n```python\r\nimport networkx as nx\r\n\r\nG = nx.Graph()\r\n\r\nG.add_node(1)\r\nG.add_nodes_from([2, 3, 4])\r\nG.add_node(\"protein_A\", type='enzyme', weight=1.5)\r\n\r\nG.add_edge(1, 2)\r\nG.add_edges_from([(1, 3), (2, 4)])\r\nG.add_edge(1, 4, weight=0.8, relation='interacts')\r\n```\r\n\r\n**Reference**: See `references/graph-basics.md` for comprehensive guidance on creating, modifying, examining, and managing graph structures, including working with attributes and subgraphs.\r\n\r\n### 2. Graph Algorithms\r\n\r\nNetworkX provides extensive algorithms for network analysis:\r\n\r\n**Shortest Paths**:\r\n```python\r\npath = nx.shortest_path(G, source=1, target=5)\r\nlength = nx.shortest_path_length(G, source=1, target=5, weight='weight')\r\n```\r\n\r\n**Centrality Measures**:\r\n```python\r\ndegree_cent = nx.degree_centrality(G)\r\n\r\nbetweenness = nx.betweenness_centrality(G)\r\n\r\npagerank = nx.pagerank(G)\r\n```\r\n\r\n**Community Detection**:\r\n```python\r\nfrom networkx.algorithms import community\r\n\r\ncommunities = community.greedy_modularity_communities(G)\r\n```\r\n\r\n**Connectivity**:\r\n```python\r\nis_connected = nx.is_connected(G)\r\n\r\ncomponents = list(nx.connected_components(G))\r\n```\r\n\r\n**Reference**: See `references/algorithms.md` for detailed documentation on all available algorithms including shortest paths, centrality measures, clustering, community detection, flows, matching, tree algorithms, and graph traversal.\r\n\r\n### 3. Graph Generators\r\n\r\nCreate synthetic networks for testing, simulation, or modeling:\r\n\r\n**Classic Graphs**:\r\n```python\r\nG = nx.complete_graph(n=10)\r\n\r\nG = nx.cycle_graph(n=20)\r\n\r\nG = nx.karate_club_graph()\r\nG = nx.petersen_graph()\r\n```\r\n\r\n**Random Networks**:\r\n```python\r\nG = nx.erdos_renyi_graph(n=100, p=0.1, seed=42)\r\n\r\nG = nx.barabasi_albert_graph(n=100, m=3, seed=42)\r\n\r\nG = nx.watts_strogatz_graph(n=100, k=6, p=0.1, seed=42)\r\n```\r\n\r\n**Structured Networks**:\r\n```python\r\nG = nx.grid_2d_graph(m=5, n=7)\r\n\r\nG = nx.random_tree(n=100, seed=42)\r\n```\r\n\r\n**Reference**: See `references/generators.md` for comprehensive coverage of all graph generators including classic, random, lattice, bipartite, and specialized network models with detailed parameters and use cases.\r\n\r\n### 4. Reading and Writing Graphs\r\n\r\nNetworkX supports numerous file formats and data sources:\r\n\r\n**File Formats**:\r\n```python\r\nG = nx.read_edgelist('graph.edgelist')\r\nnx.write_edgelist(G, 'graph.edgelist')\r\n\r\nG = nx.read_graphml('graph.graphml')\r\nnx.write_graphml(G, 'graph.graphml')\r\n\r\nG = nx.read_gml('graph.gml')\r\nnx.write_gml(G, 'graph.gml')\r\n\r\ndata = nx.node_link_data(G)\r\nG = nx.node_link_graph(data)\r\n```\r\n\r\n**Pandas Integration**:\r\n```python\r\nimport pandas as pd\r\n\r\ndf = pd.DataFrame({'source': [1, 2, 3], 'target': [2, 3, 4], 'weight': [0.5, 1.0, 0.75]})\r\nG = nx.from_pandas_edgelist(df, 'source', 'target', edge_attr='weight')\r\n\r\ndf = nx.to_pandas_edgelist(G)\r\n```\r\n\r\n**Matrix Formats**:\r\n```python\r\nimport numpy as np\r\n\r\nA = nx.to_numpy_array(G)\r\nG = nx.from_numpy_array(A)\r\n\r\nA = nx.to_scipy_sparse_array(G)\r\nG = nx.from_scipy_sparse_array(A)\r\n```\r\n\r\n**Reference**: See `references/io.md` for complete documentation on all I/O formats including CSV, SQL databases, Cytoscape, DOT, and guidance on format selection for different use cases.\r\n\r\n### 5. Visualization\r\n\r\nCreate clear and informative network visualizations:\r\n\r\n**Basic Visualization**:\r\n```python\r\nimport matplotlib.pyplot as plt\r\n\r\nnx.draw(G, with_labels=True)\r\nplt.show()\r\n\r\npos = nx.spring_layout(G, seed=42)\r\nnx.draw(G, pos=pos, with_labels=True, node_color='lightblue', node_size=500)\r\nplt.show()\r\n```\r\n\r\n**Customization**:\r\n```python\r\nnode_colors = [G.degree(n) for n in G.nodes()]\r\nnx.draw(G, node_color=node_colors, cmap=plt.cm.viridis)\r\n\r\ncentrality = nx.betweenness_centrality(G)\r\nnode_sizes = [3000 * centrality[n] for n in G.nodes()]\r\nnx.draw(G, node_size=node_sizes)\r\n\r\nedge_widths = [3 * G[u][v].get('weight', 1) for u, v in G.edges()]\r\nnx.draw(G, width=edge_widths)\r\n```\r\n\r\n**Layout Algorithms**:\r\n```python\r\npos = nx.spring_layout(G, seed=42)\r\n\r\npos = nx.circular_layout(G)\r\n\r\npos = nx.kamada_kawai_layout(G)\r\n\r\n\r\n### Installation\r\n\r\nEnsure NetworkX is installed:\r\n```python\r\nimport networkx as nx\r\nprint(nx.__version__)\r\n\r\n\r\n### Basic Operations\r\n```python\r\nG = nx.Graph()\r\nG.add_edge(1, 2)\r\n\r\nG.number_of_nodes()\r\nG.number_of_edges()\r\nG.degree(1)\r\nlist(G.neighbors(1))\r\n\r\nG.has_node(1)\r\nG.has_edge(1, 2)\r\nnx.is_connected(G)\r\n\r\nG.remove_node(1)\r\nG.remove_edge(1, 2)\r\nG.clear()\r\n```\r\n\r\n### Essential Algorithms\r\n```python\r\nnx.shortest_path(G, source, target)\r\nnx.all_pairs_shortest_path(G)\r\n\r\nnx.degree_centrality(G)\r\nnx.betweenness_centrality(G)\r\nnx.closeness_centrality(G)\r\nnx.pagerank(G)\r\n\r\nnx.clustering(G)\r\nnx.average_clustering(G)\r\n\r\nnx.connected_components(G)\r\nnx.strongly_connected_components(G)  # Directed\r\n\r\ncommunity.greedy_modularity_communities(G)\r\n```\r\n\r\n### File I/O Quick Reference\r\n```python\r\nnx.read_edgelist('file.txt')\r\nnx.read_graphml('file.graphml')\r\nnx.read_gml('file.gml')\r\n\r\nnx.write_edgelist(G, 'file.txt')\r\nnx.write_graphml(G, 'file.graphml')\r\nnx.write_gml(G, 'file.gml')",
  "name": "networkx",
  "id": "scientific-pkg-networkx",
  "sections": {
    "Additional Resources": "- **Official Documentation**: https://networkx.org/documentation/latest/\r\n- **Tutorial**: https://networkx.org/documentation/latest/tutorial.html\r\n- **Gallery**: https://networkx.org/documentation/latest/auto_examples/index.html\r\n- **GitHub**: https://github.com/networkx/networkx",
    "Working with NetworkX": "```\r\n\r\n### Common Workflow Pattern\r\n\r\nMost NetworkX tasks follow this pattern:\r\n\r\n1. **Create or Load Graph**:\r\n   ```python\r\n   # From scratch\r\n   G = nx.Graph()\r\n   G.add_edges_from([(1, 2), (2, 3), (3, 4)])\r\n\r\n   # Or load from file/data\r\n   G = nx.read_edgelist('data.txt')\r\n   ```\r\n\r\n2. **Examine Structure**:\r\n   ```python\r\n   print(f\"Nodes: {G.number_of_nodes()}\")\r\n   print(f\"Edges: {G.number_of_edges()}\")\r\n   print(f\"Density: {nx.density(G)}\")\r\n   print(f\"Connected: {nx.is_connected(G)}\")\r\n   ```\r\n\r\n3. **Analyze**:\r\n   ```python\r\n   # Compute metrics\r\n   degree_cent = nx.degree_centrality(G)\r\n   avg_clustering = nx.average_clustering(G)\r\n\r\n   # Find paths\r\n   path = nx.shortest_path(G, source=1, target=4)\r\n\r\n   # Detect communities\r\n   communities = community.greedy_modularity_communities(G)\r\n   ```\r\n\r\n4. **Visualize**:\r\n   ```python\r\n   pos = nx.spring_layout(G, seed=42)\r\n   nx.draw(G, pos=pos, with_labels=True)\r\n   plt.show()\r\n   ```\r\n\r\n5. **Export Results**:\r\n   ```python\r\n   # Save graph\r\n   nx.write_graphml(G, 'analyzed_network.graphml')\r\n\r\n   # Save metrics\r\n   df = pd.DataFrame({\r\n       'node': list(degree_cent.keys()),\r\n       'centrality': list(degree_cent.values())\r\n   })\r\n   df.to_csv('centrality_results.csv', index=False)\r\n   ```\r\n\r\n### Important Considerations\r\n\r\n**Floating Point Precision**: When graphs contain floating-point numbers, all results are inherently approximate due to precision limitations. This can affect algorithm outcomes, particularly in minimum/maximum computations.\r\n\r\n**Memory and Performance**: Each time a script runs, graph data must be loaded into memory. For large networks:\r\n- Use appropriate data structures (sparse matrices for large sparse graphs)\r\n- Consider loading only necessary subgraphs\r\n- Use efficient file formats (pickle for Python objects, compressed formats)\r\n- Leverage approximate algorithms for very large networks (e.g., `k` parameter in centrality calculations)\r\n\r\n**Node and Edge Types**:\r\n- Nodes can be any hashable Python object (numbers, strings, tuples, custom objects)\r\n- Use meaningful identifiers for clarity\r\n- When removing nodes, all incident edges are automatically removed\r\n\r\n**Random Seeds**: Always set random seeds for reproducibility in random graph generation and force-directed layouts:\r\n```python\r\nG = nx.erdos_renyi_graph(n=100, p=0.1, seed=42)\r\npos = nx.spring_layout(G, seed=42)\r\n```",
    "Overview": "NetworkX is a Python package for creating, manipulating, and analyzing complex networks and graphs. Use this skill when working with network or graph data structures, including social networks, biological networks, transportation systems, citation networks, knowledge graphs, or any system involving relationships between entities.",
    "Quick Reference": "nx.from_pandas_edgelist(df, 'source', 'target')\r\nnx.to_pandas_edgelist(G)\r\n```",
    "When to Use This Skill": "Invoke this skill when tasks involve:\r\n\r\n- **Creating graphs**: Building network structures from data, adding nodes and edges with attributes\r\n- **Graph analysis**: Computing centrality measures, finding shortest paths, detecting communities, measuring clustering\r\n- **Graph algorithms**: Running standard algorithms like Dijkstra's, PageRank, minimum spanning trees, maximum flow\r\n- **Network generation**: Creating synthetic networks (random, scale-free, small-world models) for testing or simulation\r\n- **Graph I/O**: Reading from or writing to various formats (edge lists, GraphML, JSON, CSV, adjacency matrices)\r\n- **Visualization**: Drawing and customizing network visualizations with matplotlib or interactive libraries\r\n- **Network comparison**: Checking isomorphism, computing graph metrics, analyzing structural properties",
    "Resources": "This skill includes comprehensive reference documentation:\r\n\r\n### references/graph-basics.md\r\nDetailed guide on graph types, creating and modifying graphs, adding nodes and edges, managing attributes, examining structure, and working with subgraphs.\r\n\r\n### references/algorithms.md\r\nComplete coverage of NetworkX algorithms including shortest paths, centrality measures, connectivity, clustering, community detection, flow algorithms, tree algorithms, matching, coloring, isomorphism, and graph traversal.\r\n\r\n### references/generators.md\r\nComprehensive documentation on graph generators including classic graphs, random models (Erdős-Rényi, Barabási-Albert, Watts-Strogatz), lattices, trees, social network models, and specialized generators.\r\n\r\n### references/io.md\r\nComplete guide to reading and writing graphs in various formats: edge lists, adjacency lists, GraphML, GML, JSON, CSV, Pandas DataFrames, NumPy arrays, SciPy sparse matrices, database integration, and format selection guidelines.\r\n\r\n### references/visualization.md\r\nExtensive documentation on visualization techniques including layout algorithms, customizing node and edge appearance, labels, interactive visualizations with Plotly and PyVis, 3D networks, bipartite layouts, and creating publication-quality figures.",
    "Core Capabilities": "pos = nx.spectral_layout(G)\r\n```\r\n\r\n**Publication Quality**:\r\n```python\r\nplt.figure(figsize=(12, 8))\r\npos = nx.spring_layout(G, seed=42)\r\nnx.draw(G, pos=pos, node_color='lightblue', node_size=500,\r\n        edge_color='gray', with_labels=True, font_size=10)\r\nplt.title('Network Visualization', fontsize=16)\r\nplt.axis('off')\r\nplt.tight_layout()\r\nplt.savefig('network.png', dpi=300, bbox_inches='tight')\r\nplt.savefig('network.pdf', bbox_inches='tight')  # Vector format\r\n```\r\n\r\n**Reference**: See `references/visualization.md` for extensive documentation on visualization techniques including layout algorithms, customization options, interactive visualizations with Plotly and PyVis, 3D networks, and publication-quality figure creation."
  }
}