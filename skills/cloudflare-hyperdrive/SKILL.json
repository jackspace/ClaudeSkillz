{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/connection-pooling.md",
      "references/drizzle-integration.md",
      "references/prisma-integration.md",
      "references/query-caching.md",
      "references/supported-databases.md",
      "references/tls-ssl-setup.md",
      "references/troubleshooting.md",
      "references/wrangler-commands.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-22\r\n**Dependencies**: cloudflare-worker-base (recommended for Worker setup)\r\n**Latest Versions**: wrangler@4.43.0+, pg@8.13.0+, postgres@3.4.5+, mysql2@3.13.0+\r\n\r\n---\r\n\r\n\r\n### 1. Create Hyperdrive Configuration\r\n\r\n```bash\r\nnpx wrangler hyperdrive create my-postgres-db \\\r\n  --connection-string=\"postgres://user:password@db-host.cloud:5432/database\"\r\n\r\nnpx wrangler hyperdrive create my-mysql-db \\\r\n  --connection-string=\"mysql://user:password@db-host.cloud:3306/database\"\r\n\r\n#\r\n```\r\n\r\n**Save the `id` value** - you'll need it in the next step!\r\n\r\n---\r\n\r\n### 2. Configure Bindings in wrangler.jsonc\r\n\r\nAdd to your `wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2024-09-23\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],  // REQUIRED for database drivers\r\n  \"hyperdrive\": [\r\n    {\r\n      \"binding\": \"HYPERDRIVE\",                     // Available as env.HYPERDRIVE\r\n      \"id\": \"a76a99bc-7901-48c9-9c15-c4b11b559606\"  // From wrangler hyperdrive create\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**CRITICAL:**\r\n- `nodejs_compat` flag is **REQUIRED** for all database drivers\r\n- `binding` is how you access Hyperdrive in code (`env.HYPERDRIVE`)\r\n- `id` is the Hyperdrive configuration ID (NOT your database ID)\r\n\r\n---\r\n\r\n### 3. Install Database Driver\r\n\r\n```bash\r\nnpm install pg           # node-postgres (most common)\r\nnpm install postgres     # postgres.js (modern, minimum v3.4.5)\r\n\r\n\r\n### Step 1: Prerequisites\r\n\r\n**You need:**\r\n- Cloudflare account with Workers access\r\n- Existing PostgreSQL (v9.0-17.x) or MySQL (v5.7-8.x) database\r\n- Database accessible via:\r\n  - **Public internet** (with TLS/SSL enabled), OR\r\n  - **Private network** (via Cloudflare Tunnel)\r\n\r\n**Important**: Hyperdrive **requires TLS/SSL**. Ensure your database has encryption enabled.\r\n\r\n---\r\n\r\n### Step 2: Create Hyperdrive Configuration\r\n\r\n**Option A: Wrangler CLI** (Recommended)\r\n\r\n```bash\r\n\r\nnpx wrangler hyperdrive create my-hyperdrive \\\r\n  --connection-string=\"postgres://myuser:mypassword@db.example.com:5432/mydb\"\r\n\r\n\r\nnpx wrangler hyperdrive create my-hyperdrive \\\r\n  --connection-string=\"mysql://myuser:mypassword@db.example.com:3306/mydb\"\r\n```\r\n\r\n**Option B: Cloudflare Dashboard**\r\n\r\n1. Go to [Hyperdrive Dashboard](https://dash.cloudflare.com/?to=/:account/workers/hyperdrive)\r\n2. Click **Create Configuration**\r\n3. Enter connection details:\r\n   - Name: `my-hyperdrive`\r\n   - Protocol: PostgreSQL or MySQL\r\n   - Host: `db.example.com`\r\n   - Port: `5432` (PostgreSQL) or `3306` (MySQL)\r\n   - Database: `mydb`\r\n   - Username: `myuser`\r\n   - Password: `mypassword`\r\n4. Click **Create**\r\n\r\n**Connection String Formats:**\r\n\r\n```bash\r\npostgres://user:password@host:5432/database\r\n\r\npostgres://user:password@host:5432/database?sslmode=require\r\n\r\nmysql://user:password@host:3306/database\r\n\r\npostgres://user:p%40ssw%24rd@host:5432/database  # p@ssw$rd\r\n```\r\n\r\n---\r\n\r\n### Step 3: Configure Worker Bindings\r\n\r\nAdd Hyperdrive binding to `wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2024-09-23\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n  \"hyperdrive\": [\r\n    {\r\n      \"binding\": \"HYPERDRIVE\",\r\n      \"id\": \"<your-hyperdrive-id-here>\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Multiple Hyperdrive configs:**\r\n```jsonc\r\n{\r\n  \"hyperdrive\": [\r\n    {\r\n      \"binding\": \"POSTGRES_DB\",\r\n      \"id\": \"postgres-hyperdrive-id\"\r\n    },\r\n    {\r\n      \"binding\": \"MYSQL_DB\",\r\n      \"id\": \"mysql-hyperdrive-id\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Access in Worker:**\r\n```typescript\r\ntype Bindings = {\r\n  POSTGRES_DB: Hyperdrive;\r\n  MYSQL_DB: Hyperdrive;\r\n};\r\n\r\nexport default {\r\n  async fetch(request, env: Bindings, ctx) {\r\n    // Access different databases\r\n    const pgClient = new Client({ connectionString: env.POSTGRES_DB.connectionString });\r\n    const mysqlConn = await createConnection({ host: env.MYSQL_DB.host, ... });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Step 4: Install Database Driver\r\n\r\n**PostgreSQL Drivers:**\r\n\r\n```bash\r\nnpm install pg\r\nnpm install @types/pg  # TypeScript types\r\n\r\nnpm install postgres@^3.4.5\r\n```\r\n\r\n**MySQL Drivers:**\r\n\r\n```bash\r\n\r\n### Option 1: Environment Variable (Recommended)\r\n\r\nSet `CLOUDFLARE_HYPERDRIVE_LOCAL_CONNECTION_STRING_<BINDING>` environment variable:\r\n\r\n```bash\r\nexport CLOUDFLARE_HYPERDRIVE_LOCAL_CONNECTION_STRING_HYPERDRIVE=\"postgres://user:password@localhost:5432/local_db\"\r\n\r\n\r\nConnect Hyperdrive to databases in private networks (VPCs, on-premises):\r\n\r\n**1. Install cloudflared:**\r\n```bash\r\nbrew install cloudflare/cloudflare/cloudflared\r\n\r\n\r\n```bash\r\nwrangler hyperdrive create <name> --connection-string=\"postgres://...\"\r\n\r\nwrangler hyperdrive list\r\n\r\nwrangler hyperdrive get <hyperdrive-id>\r\n\r\nwrangler hyperdrive update <hyperdrive-id> --connection-string=\"postgres://...\"\r\n\r\nwrangler hyperdrive delete <hyperdrive-id>\r\n\r\nwrangler cert upload certificate-authority --ca-cert <file>.pem --name <name>\r\n\r\n\r\n**Option 1: Create new Hyperdrive config**\r\n```bash\r\nwrangler hyperdrive create my-db-v2 --connection-string=\"postgres://...\"",
  "name": "cloudflare-hyperdrive",
  "id": "cloudflare-hyperdrive",
  "sections": {
    "Complete Setup Process": "npm install mysql2\r\n```\r\n\r\n**Driver Comparison:**\r\n\r\n| Driver | Database | Pros | Cons | Min Version |\r\n|--------|----------|------|------|-------------|\r\n| **pg** | PostgreSQL | Most popular, stable, well-documented | Slightly slower than postgres.js | 8.13.0+ |\r\n| **postgres** | PostgreSQL | Faster, modern API, streaming support | Newer (less community examples) | 3.4.5+ |\r\n| **mysql2** | MySQL | Promises, prepared statements, fast | Requires `disableEval: true` for Workers | 3.13.0+ |\r\n\r\n---\r\n\r\n### Step 5: Use Driver in Worker\r\n\r\n**PostgreSQL with pg (Client):**\r\n\r\n```typescript\r\nimport { Client } from \"pg\";\r\n\r\nexport default {\r\n  async fetch(request: Request, env: { HYPERDRIVE: Hyperdrive }, ctx: ExecutionContext) {\r\n    // Create client for this request\r\n    const client = new Client({\r\n      connectionString: env.HYPERDRIVE.connectionString\r\n    });\r\n\r\n    await client.connect();\r\n\r\n    try {\r\n      // Run query\r\n      const result = await client.query('SELECT $1::text as message', ['Hello from Hyperdrive!']);\r\n      return Response.json(result.rows);\r\n    } catch (error) {\r\n      return new Response(`Database error: ${error.message}`, { status: 500 });\r\n    } finally {\r\n      // CRITICAL: Clean up connection after response\r\n      ctx.waitUntil(client.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**PostgreSQL with pg (Pool for parallel queries):**\r\n\r\n```typescript\r\nimport { Pool } from \"pg\";\r\n\r\nexport default {\r\n  async fetch(request: Request, env: { HYPERDRIVE: Hyperdrive }, ctx: ExecutionContext) {\r\n    // Create pool (max 5 to stay within Workers' 6 connection limit)\r\n    const pool = new Pool({\r\n      connectionString: env.HYPERDRIVE.connectionString,\r\n      max: 5  // CRITICAL: Workers limit is 6 concurrent external connections\r\n    });\r\n\r\n    try {\r\n      // Run parallel queries\r\n      const [users, posts] = await Promise.all([\r\n        pool.query('SELECT * FROM users LIMIT 10'),\r\n        pool.query('SELECT * FROM posts LIMIT 10')\r\n      ]);\r\n\r\n      return Response.json({\r\n        users: users.rows,\r\n        posts: posts.rows\r\n      });\r\n    } finally {\r\n      ctx.waitUntil(pool.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**PostgreSQL with postgres.js:**\r\n\r\n```typescript\r\nimport postgres from \"postgres\";\r\n\r\nexport default {\r\n  async fetch(request: Request, env: { HYPERDRIVE: Hyperdrive }, ctx: ExecutionContext) {\r\n    const sql = postgres(env.HYPERDRIVE.connectionString, {\r\n      max: 5,              // Max 5 connections (Workers limit: 6)\r\n      fetch_types: false,  // Disable if not using array types (reduces latency)\r\n      prepare: true        // CRITICAL: Enable prepared statements for caching\r\n    });\r\n\r\n    try {\r\n      const users = await sql`SELECT * FROM users LIMIT 10`;\r\n      return Response.json({ users });\r\n    } finally {\r\n      ctx.waitUntil(sql.end({ timeout: 5 }));\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**MySQL with mysql2:**\r\n\r\n```typescript\r\nimport { createConnection } from \"mysql2/promise\";\r\n\r\nexport default {\r\n  async fetch(request: Request, env: { HYPERDRIVE: Hyperdrive }, ctx: ExecutionContext) {\r\n    const connection = await createConnection({\r\n      host: env.HYPERDRIVE.host,\r\n      user: env.HYPERDRIVE.user,\r\n      password: env.HYPERDRIVE.password,\r\n      database: env.HYPERDRIVE.database,\r\n      port: env.HYPERDRIVE.port,\r\n      disableEval: true  // REQUIRED: eval() not supported in Workers\r\n    });\r\n\r\n    try {\r\n      const [rows] = await connection.query('SELECT * FROM users LIMIT 10');\r\n      return Response.json({ users: rows });\r\n    } finally {\r\n      ctx.waitUntil(connection.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n---",
    "Migration Strategies": "### From Direct Database Connection\r\n\r\n**Before (direct connection):**\r\n```typescript\r\nconst client = new Client({\r\n  host: 'db.example.com',\r\n  user: 'myuser',\r\n  password: 'mypassword',\r\n  database: 'mydb',\r\n  port: 5432\r\n});\r\n```\r\n\r\n**After (with Hyperdrive):**\r\n```typescript\r\nconst client = new Client({\r\n  connectionString: env.HYPERDRIVE.connectionString\r\n});\r\n```\r\n\r\n**Benefits:**\r\n- ✅ 7 round trips eliminated\r\n- ✅ Query caching enabled\r\n- ✅ Connection pooling automatic\r\n- ✅ Global performance boost\r\n\r\n---\r\n\r\n### From D1 to Hyperdrive\r\n\r\n**When to migrate:**\r\n- Need PostgreSQL/MySQL features (JSON types, full-text search, etc.)\r\n- Existing database with data\r\n- Multi-region read replicas\r\n- Advanced indexing strategies\r\n\r\n**Keep D1 if:**\r\n- Building new Cloudflare-native app\r\n- SQLite features sufficient\r\n- No existing database to migrate\r\n- Want simpler serverless setup\r\n\r\n---",
    "Quick Start (5 Minutes)": "npm install mysql2       # mysql2 (minimum v3.13.0)\r\n```\r\n\r\n---\r\n\r\n### 4. Query Your Database\r\n\r\n**PostgreSQL with node-postgres (pg):**\r\n```typescript\r\nimport { Client } from \"pg\";\r\n\r\ntype Bindings = {\r\n  HYPERDRIVE: Hyperdrive;\r\n};\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Bindings, ctx: ExecutionContext) {\r\n    const client = new Client({\r\n      connectionString: env.HYPERDRIVE.connectionString\r\n    });\r\n\r\n    await client.connect();\r\n\r\n    try {\r\n      const result = await client.query('SELECT * FROM users LIMIT 10');\r\n      return Response.json({ users: result.rows });\r\n    } finally {\r\n      // Clean up connection AFTER response is sent\r\n      ctx.waitUntil(client.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**MySQL with mysql2:**\r\n```typescript\r\nimport { createConnection } from \"mysql2/promise\";\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Bindings, ctx: ExecutionContext) {\r\n    const connection = await createConnection({\r\n      host: env.HYPERDRIVE.host,\r\n      user: env.HYPERDRIVE.user,\r\n      password: env.HYPERDRIVE.password,\r\n      database: env.HYPERDRIVE.database,\r\n      port: env.HYPERDRIVE.port,\r\n      disableEval: true  // REQUIRED for Workers (eval() not supported)\r\n    });\r\n\r\n    try {\r\n      const [rows] = await connection.query('SELECT * FROM users LIMIT 10');\r\n      return Response.json({ users: rows });\r\n    } finally {\r\n      ctx.waitUntil(connection.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### 5. Deploy\r\n\r\n```bash\r\nnpx wrangler deploy\r\n```\r\n\r\n**That's it!** Your Worker now connects to your existing database via Hyperdrive with:\r\n- ✅ Global connection pooling\r\n- ✅ Automatic query caching\r\n- ✅ Reduced latency (eliminates 7 round trips)\r\n\r\n---",
    "Performance Best Practices": "1. **Avoid long-running transactions** - Limits connection multiplexing\r\n2. **Use prepared statements** - Enables query caching (postgres.js: `prepare: true`)\r\n3. **Set max: 5 for pools** - Stays within Workers' 6 connection limit\r\n4. **Disable fetch_types if not needed** - Reduces latency (postgres.js)\r\n5. **Use ctx.waitUntil() for cleanup** - Non-blocking connection close\r\n6. **Cache-friendly queries** - Prefer SELECT over complex joins\r\n7. **Index frequently queried columns** - Improves query performance\r\n8. **Monitor with Hyperdrive analytics** - Track cache hit ratios and latency\r\n\r\n---",
    "Private Database Access (Cloudflare Tunnel)": "wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64\r\n```\r\n\r\n**2. Create tunnel:**\r\n```bash\r\ncloudflared tunnel create my-db-tunnel\r\n```\r\n\r\n**3. Configure tunnel (`config.yml`):**\r\n```yaml\r\ntunnel: <TUNNEL_ID>\r\ncredentials-file: /path/to/credentials.json\r\n\r\ningress:\r\n  - hostname: db.example.com\r\n    service: tcp://localhost:5432  # Your private database\r\n  - service: http_status:404\r\n```\r\n\r\n**4. Run tunnel:**\r\n```bash\r\ncloudflared tunnel run my-db-tunnel\r\n```\r\n\r\n**5. Create Hyperdrive:**\r\n```bash\r\nnpx wrangler hyperdrive create my-private-db \\\r\n  --connection-string=\"postgres://user:password@db.example.com:5432/database\"\r\n```\r\n\r\n---",
    "How Hyperdrive Works": "### The Problem\r\nConnecting to traditional databases from Cloudflare's 300+ global locations presents challenges:\r\n\r\n1. **High Latency** - Multiple round trips for each connection:\r\n   - TCP handshake (1 round trip)\r\n   - TLS negotiation (3 round trips)\r\n   - Database authentication (3 round trips)\r\n   - **Total: 7 round trips before you can even send a query**\r\n\r\n2. **Connection Limits** - Traditional databases handle limited concurrent connections, easily exhausted by distributed traffic\r\n\r\n### The Solution\r\nHyperdrive solves these problems by:\r\n\r\n1. **Edge Connection Setup** - Connection handshake happens near your Worker (low latency)\r\n2. **Connection Pooling** - Pool near your database reuses connections (eliminates round trips)\r\n3. **Query Caching** - Popular queries cached at the edge (reduces database load)\r\n\r\n**Result**: Single-region databases feel globally distributed.\r\n\r\n---",
    "Supported Databases": "### PostgreSQL (v9.0 - 17.x)\r\n- ✅ AWS RDS / Aurora\r\n- ✅ Google Cloud SQL\r\n- ✅ Azure Database for PostgreSQL\r\n- ✅ Neon\r\n- ✅ Supabase\r\n- ✅ PlanetScale (PostgreSQL)\r\n- ✅ Timescale\r\n- ✅ CockroachDB\r\n- ✅ Materialize\r\n- ✅ Fly.io\r\n- ✅ pgEdge Cloud\r\n- ✅ Prisma Postgres\r\n\r\n### MySQL (v5.7 - 8.x)\r\n- ✅ AWS RDS / Aurora\r\n- ✅ Google Cloud SQL\r\n- ✅ Azure Database for MySQL\r\n- ✅ PlanetScale (MySQL)\r\n\r\n### NOT Supported\r\n- ❌ SQL Server\r\n- ❌ MongoDB (NoSQL)\r\n- ❌ Oracle Database\r\n\r\n---",
    "Query Caching": "### What Gets Cached\r\n\r\nHyperdrive automatically caches **non-mutating queries** (read-only):\r\n\r\n```sql\r\n-- ✅ Cached\r\nSELECT * FROM articles WHERE published = true ORDER BY date DESC LIMIT 50;\r\nSELECT COUNT(*) FROM users;\r\nSELECT * FROM products WHERE category = 'electronics';\r\n\r\n-- ❌ NOT Cached\r\nINSERT INTO users (name, email) VALUES ('John', 'john@example.com');\r\nUPDATE posts SET published = true WHERE id = 123;\r\nDELETE FROM sessions WHERE expired = true;\r\nSELECT LASTVAL();  -- PostgreSQL volatile function\r\nSELECT LAST_INSERT_ID();  -- MySQL volatile function\r\n```\r\n\r\n### How It Works\r\n\r\n1. **Wire Protocol Parsing**: Hyperdrive parses database protocol to differentiate mutations\r\n2. **Automatic Detection**: No configuration needed\r\n3. **Edge Caching**: Cached at Cloudflare's edge (near users)\r\n4. **Cache Invalidation**: Writes invalidate relevant cached queries\r\n\r\n### Caching Optimization\r\n\r\n**postgres.js - Enable prepared statements:**\r\n```typescript\r\nconst sql = postgres(env.HYPERDRIVE.connectionString, {\r\n  prepare: true  // CRITICAL for caching\r\n});\r\n```\r\n\r\n**Without `prepare: true`, queries are NOT cacheable!**\r\n\r\n### Cache Status\r\n\r\nCheck if query was cached:\r\n\r\n```typescript\r\nconst response = await fetch('https://your-worker.dev/api/users');\r\nconst cacheStatus = response.headers.get('cf-cache-status');\r\n// Values: HIT, MISS, BYPASS, EXPIRED\r\n```\r\n\r\n---",
    "Credential Rotation": "```\r\n\r\n**Option 2: Update existing config**\r\n```bash\r\nwrangler hyperdrive update <id> --connection-string=\"postgres://new-credentials@...\"\r\n```\r\n\r\n**Best practice**: Use separate Hyperdrive configs for staging and production.\r\n\r\n---",
    "Unsupported Features": "### PostgreSQL\r\n- SQL-level prepared statements (`PREPARE`, `EXECUTE`, `DEALLOCATE`)\r\n- Advisory locks\r\n- `LISTEN` and `NOTIFY`\r\n- Per-session state modifications\r\n\r\n### MySQL\r\n- Non-UTF8 characters in queries\r\n- `USE` statements\r\n- Multi-statement queries\r\n- Protocol-level prepared statements (`COM_STMT_PREPARE`)\r\n- `COM_INIT_DB` messages\r\n- Auth plugins other than `caching_sha2_password` or `mysql_native_password`\r\n\r\n**Workaround**: For unsupported features, create a second direct client connection (without Hyperdrive).\r\n\r\n---",
    "Connection Patterns": "### Pattern 1: Single Connection (pg.Client)\r\n\r\n**When to use**: Simple queries, single query per request\r\n\r\n```typescript\r\nimport { Client } from \"pg\";\r\n\r\nconst client = new Client({ connectionString: env.HYPERDRIVE.connectionString });\r\nawait client.connect();\r\nconst result = await client.query('SELECT ...');\r\nctx.waitUntil(client.end());\r\n```\r\n\r\n**Pros**: Simple, straightforward\r\n**Cons**: Can't run parallel queries\r\n\r\n---\r\n\r\n### Pattern 2: Connection Pool (pg.Pool)\r\n\r\n**When to use**: Multiple parallel queries in single request\r\n\r\n```typescript\r\nimport { Pool } from \"pg\";\r\n\r\nconst pool = new Pool({\r\n  connectionString: env.HYPERDRIVE.connectionString,\r\n  max: 5  // CRITICAL: Stay within Workers' 6 connection limit\r\n});\r\n\r\nconst [result1, result2] = await Promise.all([\r\n  pool.query('SELECT ...'),\r\n  pool.query('SELECT ...')\r\n]);\r\n\r\nctx.waitUntil(pool.end());\r\n```\r\n\r\n**Pros**: Parallel queries, better performance\r\n**Cons**: Must manage max connections\r\n\r\n---\r\n\r\n### Pattern 3: Connection Cleanup\r\n\r\n**CRITICAL**: Always use `ctx.waitUntil()` to clean up connections AFTER response is sent:\r\n\r\n```typescript\r\nexport default {\r\n  async fetch(request, env, ctx) {\r\n    const client = new Client({ connectionString: env.HYPERDRIVE.connectionString });\r\n    await client.connect();\r\n\r\n    try {\r\n      const result = await client.query('SELECT ...');\r\n      return Response.json(result.rows);  // Response sent here\r\n    } finally {\r\n      // This runs AFTER response is sent (non-blocking)\r\n      ctx.waitUntil(client.end());\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**Why `ctx.waitUntil()`?**\r\n- Allows Worker to return response immediately\r\n- Connection cleanup happens in background\r\n- Prevents connection leaks\r\n\r\n**DON'T do this:**\r\n```typescript\r\nawait client.end();  // ❌ Blocks response, adds latency\r\n```\r\n\r\n---",
    "Examples": "See `templates/` directory for complete working examples:\r\n\r\n- `postgres-basic.ts` - Simple query with pg.Client\r\n- `postgres-pool.ts` - Parallel queries with pg.Pool\r\n- `postgres-js.ts` - Using postgres.js driver\r\n- `mysql2-basic.ts` - MySQL with mysql2 driver\r\n- `drizzle-postgres.ts` - Drizzle ORM integration\r\n- `drizzle-mysql.ts` - Drizzle ORM with MySQL\r\n- `prisma-postgres.ts` - Prisma ORM integration\r\n\r\n---",
    "Metrics and Analytics": "View Hyperdrive metrics in the dashboard:\r\n\r\n1. Go to [Hyperdrive Dashboard](https://dash.cloudflare.com/?to=/:account/workers/hyperdrive)\r\n2. Select your configuration\r\n3. Click **Metrics** tab\r\n\r\n**Available Metrics:**\r\n- Query count\r\n- Cache hit ratio (hit vs miss)\r\n- Query latency (p50, p95, p99)\r\n- Connection latency\r\n- Query bytes / result bytes\r\n- Error rate\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ Include `nodejs_compat` in `compatibility_flags`\r\n✅ Use `ctx.waitUntil(client.end())` for connection cleanup\r\n✅ Set `max: 5` for connection pools (Workers limit: 6)\r\n✅ Enable TLS/SSL on your database (Hyperdrive requires it)\r\n✅ Use prepared statements for caching (postgres.js: `prepare: true`)\r\n✅ Set `disableEval: true` for mysql2 driver\r\n✅ Handle errors gracefully with try/catch\r\n✅ Use environment variables for local development connection strings\r\n✅ Test locally with `wrangler dev` before deploying\r\n\r\n### Never Do\r\n\r\n❌ Skip `nodejs_compat` flag (causes \"No such module\" errors)\r\n❌ Use private IP addresses directly (use Cloudflare Tunnel instead)\r\n❌ Use `await client.end()` (blocks response, use `ctx.waitUntil()`)\r\n❌ Set connection pool max > 5 (exceeds Workers' 6 connection limit)\r\n❌ Wrap all queries in transactions (limits connection multiplexing)\r\n❌ Use SQL-level PREPARE/EXECUTE/DEALLOCATE (unsupported)\r\n❌ Use advisory locks, LISTEN/NOTIFY (PostgreSQL unsupported features)\r\n❌ Use multi-statement queries in MySQL (unsupported)\r\n❌ Commit database credentials to version control\r\n\r\n---",
    "TLS/SSL Configuration": "### SSL Modes\r\n\r\nHyperdrive supports 3 TLS/SSL modes:\r\n\r\n1. **`require`** (default) - TLS required, basic certificate validation\r\n2. **`verify-ca`** - Verify server certificate signed by expected CA\r\n3. **`verify-full`** - Verify CA + hostname matches certificate SAN\r\n\r\n### Server Certificates (verify-ca / verify-full)\r\n\r\n**1. Upload CA certificate:**\r\n```bash\r\nnpx wrangler cert upload certificate-authority \\\r\n  --ca-cert root-ca.pem \\\r\n  --name my-ca-cert\r\n```\r\n\r\n**2. Create Hyperdrive with CA:**\r\n```bash\r\nnpx wrangler hyperdrive create my-db \\\r\n  --connection-string=\"postgres://...\" \\\r\n  --ca-certificate-id <CA_CERT_ID> \\\r\n  --sslmode verify-full\r\n```\r\n\r\n### Client Certificates (mTLS)\r\n\r\nFor databases requiring client authentication:\r\n\r\n**1. Upload client certificate + key:**\r\n```bash\r\nnpx wrangler cert upload mtls-certificate \\\r\n  --cert client-cert.pem \\\r\n  --key client-key.pem \\\r\n  --name my-client-cert\r\n```\r\n\r\n**2. Create Hyperdrive with client cert:**\r\n```bash\r\nnpx wrangler hyperdrive create my-db \\\r\n  --connection-string=\"postgres://...\" \\\r\n  --mtls-certificate-id <CERT_PAIR_ID>\r\n```\r\n\r\n---",
    "Troubleshooting": "See `references/troubleshooting.md` for complete error reference with solutions.\r\n\r\n**Quick fixes:**\r\n\r\n| Error | Solution |\r\n|-------|----------|\r\n| \"No such module 'node:*'\" | Add `nodejs_compat` to compatibility_flags |\r\n| \"TLS not supported by database\" | Enable SSL/TLS on your database |\r\n| \"Connection refused\" | Check firewall rules, allow public internet or use Tunnel |\r\n| \"Failed to acquire connection\" | Use `ctx.waitUntil()` for cleanup, avoid long transactions |\r\n| \"Code generation from strings disallowed\" | Set `disableEval: true` in mysql2 config |\r\n| \"Bad hostname\" | Verify DNS resolves, check for typos |\r\n| \"Invalid database credentials\" | Check username/password (case-sensitive) |\r\n\r\n---",
    "ORM Integration": "### Drizzle ORM (PostgreSQL)\r\n\r\n**1. Install dependencies:**\r\n```bash\r\nnpm install drizzle-orm postgres dotenv\r\nnpm install -D drizzle-kit\r\n```\r\n\r\n**2. Define schema (`src/db/schema.ts`):**\r\n```typescript\r\nimport { pgTable, serial, varchar, timestamp } from \"drizzle-orm/pg-core\";\r\n\r\nexport const users = pgTable(\"users\", {\r\n  id: serial(\"id\").primaryKey(),\r\n  name: varchar(\"name\", { length: 255 }).notNull(),\r\n  email: varchar(\"email\", { length: 255 }).notNull().unique(),\r\n  createdAt: timestamp(\"created_at\").defaultNow(),\r\n});\r\n```\r\n\r\n**3. Use in Worker:**\r\n```typescript\r\nimport { drizzle } from \"drizzle-orm/postgres-js\";\r\nimport postgres from \"postgres\";\r\nimport { users } from \"./db/schema\";\r\n\r\nexport default {\r\n  async fetch(request, env: { HYPERDRIVE: Hyperdrive }, ctx) {\r\n    const sql = postgres(env.HYPERDRIVE.connectionString, { max: 5 });\r\n    const db = drizzle(sql);\r\n\r\n    const allUsers = await db.select().from(users);\r\n\r\n    ctx.waitUntil(sql.end());\r\n    return Response.json({ users: allUsers });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Prisma ORM (PostgreSQL)\r\n\r\n**1. Install dependencies:**\r\n```bash\r\nnpm install prisma @prisma/client\r\nnpm install pg @prisma/adapter-pg\r\n```\r\n\r\n**2. Initialize Prisma:**\r\n```bash\r\nnpx prisma init\r\n```\r\n\r\n**3. Define schema (`prisma/schema.prisma`):**\r\n```prisma\r\ngenerator client {\r\n  provider        = \"prisma-client-js\"\r\n  previewFeatures = [\"driverAdapters\"]\r\n}\r\n\r\ndatasource db {\r\n  provider = \"postgresql\"\r\n  url      = env(\"DATABASE_URL\")\r\n}\r\n\r\nmodel User {\r\n  id        Int      @id @default(autoincrement())\r\n  name      String\r\n  email     String   @unique\r\n  createdAt DateTime @default(now())\r\n}\r\n```\r\n\r\n**4. Generate Prisma Client:**\r\n```bash\r\nnpx prisma generate --no-engine\r\n```\r\n\r\n**5. Use in Worker:**\r\n```typescript\r\nimport { PrismaPg } from \"@prisma/adapter-pg\";\r\nimport { PrismaClient } from \"@prisma/client\";\r\nimport { Pool } from \"pg\";\r\n\r\nexport default {\r\n  async fetch(request, env: { HYPERDRIVE: Hyperdrive }, ctx) {\r\n    // Create driver adapter with Hyperdrive connection\r\n    const pool = new Pool({ connectionString: env.HYPERDRIVE.connectionString, max: 5 });\r\n    const adapter = new PrismaPg(pool);\r\n    const prisma = new PrismaClient({ adapter });\r\n\r\n    const users = await prisma.user.findMany();\r\n\r\n    ctx.waitUntil(pool.end());\r\n    return Response.json({ users });\r\n  }\r\n};\r\n```\r\n\r\n**IMPORTANT**: Prisma requires driver adapters (`@prisma/adapter-pg`) to work with Hyperdrive.\r\n\r\n---",
    "Local Development": "npx wrangler dev\r\n```\r\n\r\n**Benefits:**\r\n- No credentials in wrangler.jsonc\r\n- Safe to commit configuration files\r\n- Different devs can use different local databases\r\n\r\n---\r\n\r\n### Option 2: localConnectionString in wrangler.jsonc\r\n\r\n```jsonc\r\n{\r\n  \"hyperdrive\": [\r\n    {\r\n      \"binding\": \"HYPERDRIVE\",\r\n      \"id\": \"production-hyperdrive-id\",\r\n      \"localConnectionString\": \"postgres://user:password@localhost:5432/local_db\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Caution**: Don't commit real credentials to version control!\r\n\r\n---\r\n\r\n### Option 3: Remote Development\r\n\r\nConnect to production database during local development:\r\n\r\n```bash\r\nnpx wrangler dev --remote\r\n```\r\n\r\n**Warning**: This uses your PRODUCTION database. Changes cannot be undone!\r\n\r\n---",
    "References": "- [Official Documentation](https://developers.cloudflare.com/hyperdrive/)\r\n- [Get Started Guide](https://developers.cloudflare.com/hyperdrive/get-started/)\r\n- [How Hyperdrive Works](https://developers.cloudflare.com/hyperdrive/configuration/how-hyperdrive-works/)\r\n- [Query Caching](https://developers.cloudflare.com/hyperdrive/configuration/query-caching/)\r\n- [Local Development](https://developers.cloudflare.com/hyperdrive/configuration/local-development/)\r\n- [TLS/SSL Certificates](https://developers.cloudflare.com/hyperdrive/configuration/tls-ssl-certificates-for-hyperdrive/)\r\n- [Troubleshooting Guide](https://developers.cloudflare.com/hyperdrive/observability/troubleshooting/)\r\n- [Wrangler Commands](https://developers.cloudflare.com/hyperdrive/reference/wrangler-commands/)\r\n- [Supported Databases](https://developers.cloudflare.com/hyperdrive/reference/supported-databases-and-features/)\r\n\r\n---\r\n\r\n**Last Updated**: 2025-10-22\r\n**Package Versions**: wrangler@4.43.0+, pg@8.13.0+, postgres@3.4.5+, mysql2@3.13.0+\r\n**Production Tested**: Based on official Cloudflare documentation and community examples",
    "Wrangler Commands Reference": "wrangler cert upload mtls-certificate --cert <cert>.pem --key <key>.pem --name <name>\r\n```\r\n\r\n---"
  }
}