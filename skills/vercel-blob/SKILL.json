{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/example-reference.md"
    ]
  },
  "content": "**Status**: Production Ready\r\n**Last Updated**: 2025-10-29\r\n**Dependencies**: None\r\n**Latest Versions**: `@vercel/blob@2.0.0`\r\n\r\n---\r\n\r\n\r\n### 1. Create Blob Store\r\n\r\n```bash",
  "name": "vercel-blob",
  "id": "vercel-blob",
  "sections": {
    "Production Example": "- **E-commerce**: Product images, user uploads (500K+ files)\r\n- **Blog Platform**: Featured images, author avatars\r\n- **SaaS**: Document uploads, PDF generation, CSV exports\r\n- **Errors**: 0 (all 10 known issues prevented)\r\n\r\n---",
    "Quick Start (3 Minutes)": "vercel env pull .env.local\r\n```\r\n\r\nCreates: `BLOB_READ_WRITE_TOKEN`\r\n\r\n### 2. Install\r\n\r\n```bash\r\nnpm install @vercel/blob\r\n```\r\n\r\n### 3. Upload File (Server Action)\r\n\r\n```typescript\r\n'use server';\r\n\r\nimport { put } from '@vercel/blob';\r\n\r\nexport async function uploadFile(formData: FormData) {\r\n  const file = formData.get('file') as File;\r\n\r\n  const blob = await put(file.name, file, {\r\n    access: 'public' // or 'private'\r\n  });\r\n\r\n  return blob.url; // https://xyz.public.blob.vercel-storage.com/file.jpg\r\n}\r\n```\r\n\r\n**CRITICAL:**\r\n- Use client upload tokens for direct client uploads (don't expose `BLOB_READ_WRITE_TOKEN`)\r\n- Set correct `access` level (`public` vs `private`)\r\n- Files are automatically distributed via CDN\r\n\r\n---",
    "Configuration Files Reference": "### package.json\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@vercel/blob\": \"^2.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n### .env.local\r\n\r\n```bash\r\nBLOB_READ_WRITE_TOKEN=\"vercel_blob_rw_xxxxx\"\r\n```\r\n\r\n---",
    "Package Versions (Verified 2025-10-29)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"@vercel/blob\": \"^2.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Troubleshooting": "### Problem: `BLOB_READ_WRITE_TOKEN is not defined`\r\n**Solution**: Run `vercel env pull .env.local`, ensure `.env.local` in `.gitignore`.\r\n\r\n### Problem: File size exceeded (>500MB)\r\n**Solution**: Use multipart upload with `createMultipartUpload()` API.\r\n\r\n### Problem: Client upload fails with token error\r\n**Solution**: Ensure using `handleUpload()` server-side, don't expose read/write token to client.\r\n\r\n### Problem: Files not deleting\r\n**Solution**: Use exact URL from `put()` response, check `del()` return value.\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ **Use client upload tokens for client-side uploads** - Never expose `BLOB_READ_WRITE_TOKEN` to client\r\n\r\n✅ **Set correct access level** - `public` (CDN) or `private` (authenticated access)\r\n\r\n✅ **Validate file types and sizes** - Before upload, check MIME type and size\r\n\r\n✅ **Use pathname organization** - `avatars/`, `uploads/`, `documents/` for structure\r\n\r\n✅ **Handle upload errors** - Network failures, size limits, token expiration\r\n\r\n✅ **Clean up old files** - Delete unused files to manage storage costs\r\n\r\n✅ **Set content-type explicitly** - For correct browser handling (videos, PDFs)\r\n\r\n### Never Do\r\n\r\n❌ **Never expose `BLOB_READ_WRITE_TOKEN` to client** - Use `handleUpload()` for client uploads\r\n\r\n❌ **Never skip file validation** - Always validate type, size, content before upload\r\n\r\n❌ **Never upload files >500MB without multipart** - Use multipart upload for large files\r\n\r\n❌ **Never use generic filenames** - `file.jpg` collides, use `${timestamp}-${name}` or UUID\r\n\r\n❌ **Never assume uploads succeed** - Always handle errors (network, quota, etc.)\r\n\r\n❌ **Never store sensitive data unencrypted** - Encrypt before upload if needed\r\n\r\n❌ **Never forget to delete temporary files** - Old uploads consume quota\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- `@vercel/blob@^2.0.0` - Vercel Blob SDK\r\n\r\n**Optional**:\r\n- `sharp@^0.33.0` - Image processing before upload\r\n- `zod@^3.24.0` - File validation schemas\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **10 documented issues**:\r\n\r\n### Issue #1: Missing Environment Variable\r\n**Error**: `Error: BLOB_READ_WRITE_TOKEN is not defined`\r\n**Source**: https://vercel.com/docs/storage/vercel-blob\r\n**Why It Happens**: Token not set in environment\r\n**Prevention**: Run `vercel env pull .env.local` and ensure `.env.local` in `.gitignore`.\r\n\r\n### Issue #2: Client Upload Token Exposed\r\n**Error**: Security vulnerability, unauthorized uploads\r\n**Source**: https://vercel.com/docs/storage/vercel-blob/client-upload\r\n**Why It Happens**: Using `BLOB_READ_WRITE_TOKEN` directly in client code\r\n**Prevention**: Use `handleUpload()` to generate client-specific tokens with constraints.\r\n\r\n### Issue #3: File Size Limit Exceeded\r\n**Error**: `Error: File size exceeds limit` (500MB)\r\n**Source**: https://vercel.com/docs/storage/vercel-blob/limits\r\n**Why It Happens**: Uploading file >500MB without multipart upload\r\n**Prevention**: Validate file size before upload, use multipart upload for large files.\r\n\r\n### Issue #4: Wrong Content-Type\r\n**Error**: Browser downloads file instead of displaying (e.g., PDF opens as text)\r\n**Source**: Production debugging\r\n**Why It Happens**: Not setting `contentType` option, Blob guesses incorrectly\r\n**Prevention**: Always set `contentType: file.type` or explicit MIME type.\r\n\r\n### Issue #5: Public File Not Cached\r\n**Error**: Slow file delivery, high egress costs\r\n**Source**: Vercel Blob best practices\r\n**Why It Happens**: Using `access: 'private'` for files that should be public\r\n**Prevention**: Use `access: 'public'` for publicly accessible files (CDN caching).\r\n\r\n### Issue #6: List Pagination Not Handled\r\n**Error**: Only first 1000 files returned, missing files\r\n**Source**: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list\r\n**Why It Happens**: Not iterating with cursor for large file lists\r\n**Prevention**: Use cursor-based pagination in loop until `cursor` is undefined.\r\n\r\n### Issue #7: Delete Fails Silently\r\n**Error**: Files not deleted, storage quota fills up\r\n**Source**: https://github.com/vercel/storage/issues/150\r\n**Why It Happens**: Using wrong URL format, blob not found\r\n**Prevention**: Use full blob URL from `put()` response, check deletion result.\r\n\r\n### Issue #8: Upload Timeout (Large Files)\r\n**Error**: `Error: Request timeout` for files >100MB\r\n**Source**: Vercel function timeout limits\r\n**Why It Happens**: Serverless function timeout (10s free tier, 60s pro)\r\n**Prevention**: Use client-side upload with `handleUpload()` for large files.\r\n\r\n### Issue #9: Filename Collisions\r\n**Error**: Files overwritten, data loss\r\n**Source**: Production debugging\r\n**Why It Happens**: Using same filename for multiple uploads\r\n**Prevention**: Add timestamp/UUID: `` `uploads/${Date.now()}-${file.name}` `` or `addRandomSuffix: true`.\r\n\r\n### Issue #10: Missing Upload Callback\r\n**Error**: Upload completes but app state not updated\r\n**Source**: https://vercel.com/docs/storage/vercel-blob/client-upload#callback-after-upload\r\n**Why It Happens**: Not implementing `onUploadCompleted` callback\r\n**Prevention**: Use `onUploadCompleted` in `handleUpload()` to update database/state.\r\n\r\n---",
    "Official Documentation": "- **Vercel Blob**: https://vercel.com/docs/storage/vercel-blob\r\n- **Client Upload**: https://vercel.com/docs/storage/vercel-blob/client-upload\r\n- **SDK Reference**: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk\r\n- **GitHub**: https://github.com/vercel/storage\r\n\r\n---",
    "Common Patterns": "### Pattern 1: Avatar Upload\r\n\r\n```typescript\r\n'use server';\r\n\r\nimport { put, del } from '@vercel/blob';\r\n\r\nexport async function updateAvatar(userId: string, formData: FormData) {\r\n  const file = formData.get('avatar') as File;\r\n\r\n  // Validate\r\n  if (!file.type.startsWith('image/')) {\r\n    throw new Error('Only images allowed');\r\n  }\r\n\r\n  // Delete old avatar\r\n  const user = await db.query.users.findFirst({ where: eq(users.id, userId) });\r\n  if (user?.avatarUrl) {\r\n    await del(user.avatarUrl);\r\n  }\r\n\r\n  // Upload new\r\n  const blob = await put(`avatars/${userId}.jpg`, file, {\r\n    access: 'public',\r\n    contentType: file.type\r\n  });\r\n\r\n  // Update database\r\n  await db.update(users).set({ avatarUrl: blob.url }).where(eq(users.id, userId));\r\n\r\n  return blob.url;\r\n}\r\n```\r\n\r\n### Pattern 2: Protected File Upload\r\n\r\n```typescript\r\n'use server';\r\n\r\nimport { put } from '@vercel/blob';\r\nimport { auth } from '@/lib/auth';\r\n\r\nexport async function uploadDocument(formData: FormData) {\r\n  const session = await auth();\r\n  if (!session) throw new Error('Unauthorized');\r\n\r\n  const file = formData.get('document') as File;\r\n\r\n  // Upload as private\r\n  const blob = await put(`documents/${session.user.id}/${file.name}`, file, {\r\n    access: 'private' // Requires authentication to access\r\n  });\r\n\r\n  // Store in database with user reference\r\n  await db.insert(documents).values({\r\n    userId: session.user.id,\r\n    url: blob.url,\r\n    filename: file.name,\r\n    size: file.size\r\n  });\r\n\r\n  return blob;\r\n}\r\n```\r\n\r\n### Pattern 3: Image Gallery with Pagination\r\n\r\n```typescript\r\nimport { list } from '@vercel/blob';\r\n\r\nexport async function getGalleryImages(cursor?: string) {\r\n  const { blobs, cursor: nextCursor } = await list({\r\n    prefix: 'gallery/',\r\n    limit: 20,\r\n    cursor\r\n  });\r\n\r\n  const images = blobs.map(blob => ({\r\n    url: blob.url,\r\n    uploadedAt: blob.uploadedAt,\r\n    size: blob.size\r\n  }));\r\n\r\n  return { images, nextCursor };\r\n}\r\n```\r\n\r\n---",
    "Complete Setup Checklist": "- [ ] Blob store created in Vercel dashboard\r\n- [ ] `BLOB_READ_WRITE_TOKEN` environment variable set\r\n- [ ] `@vercel/blob` package installed\r\n- [ ] File validation implemented (type, size)\r\n- [ ] Client upload uses `handleUpload()` (not direct token)\r\n- [ ] Content-type set for uploads\r\n- [ ] Access level correct (`public` vs `private`)\r\n- [ ] Deletion of old files implemented\r\n- [ ] List pagination handles cursor\r\n- [ ] Tested file upload/download/delete locally and in production\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check official docs: https://vercel.com/docs/storage/vercel-blob\r\n2. Verify environment variables are set\r\n3. Ensure using client upload tokens for client-side uploads\r\n4. Monitor storage usage in Vercel dashboard",
    "The 5-Step Setup Process": "### Step 1: Create Blob Store\r\n\r\n**Vercel Dashboard**:\r\n1. Project → Storage → Create Database → Blob\r\n2. Copy `BLOB_READ_WRITE_TOKEN`\r\n\r\n**Local Development**:\r\n```bash\r\nvercel env pull .env.local\r\n```\r\n\r\nCreates `.env.local`:\r\n```bash\r\nBLOB_READ_WRITE_TOKEN=\"vercel_blob_rw_xxx\"\r\n```\r\n\r\n**Key Points:**\r\n- Free tier: 100GB bandwidth/month\r\n- File size limit: 500MB per file\r\n- Automatic CDN distribution\r\n- Public files are cached globally\r\n\r\n---\r\n\r\n### Step 2: Server-Side Upload\r\n\r\n**Next.js Server Action:**\r\n```typescript\r\n'use server';\r\n\r\nimport { put } from '@vercel/blob';\r\n\r\nexport async function uploadAvatar(formData: FormData) {\r\n  const file = formData.get('avatar') as File;\r\n\r\n  // Validate file\r\n  if (!file.type.startsWith('image/')) {\r\n    throw new Error('Only images allowed');\r\n  }\r\n\r\n  if (file.size > 5 * 1024 * 1024) {\r\n    throw new Error('Max file size: 5MB');\r\n  }\r\n\r\n  // Upload\r\n  const blob = await put(`avatars/${Date.now()}-${file.name}`, file, {\r\n    access: 'public',\r\n    addRandomSuffix: false\r\n  });\r\n\r\n  return {\r\n    url: blob.url,\r\n    pathname: blob.pathname\r\n  };\r\n}\r\n```\r\n\r\n**API Route (Edge Runtime):**\r\n```typescript\r\nimport { put } from '@vercel/blob';\r\n\r\nexport const runtime = 'edge';\r\n\r\nexport async function POST(request: Request) {\r\n  const formData = await request.formData();\r\n  const file = formData.get('file') as File;\r\n\r\n  const blob = await put(file.name, file, { access: 'public' });\r\n\r\n  return Response.json(blob);\r\n}\r\n```\r\n\r\n---\r\n\r\n### Step 3: Client-Side Upload (Presigned URLs)\r\n\r\n**Create Upload Token (Server Action):**\r\n```typescript\r\n'use server';\r\n\r\nimport { handleUpload, type HandleUploadBody } from '@vercel/blob/client';\r\n\r\nexport async function getUploadToken(filename: string) {\r\n  const jsonResponse = await handleUpload({\r\n    body: {\r\n      type: 'blob.generate-client-token',\r\n      payload: {\r\n        pathname: `uploads/${filename}`,\r\n        access: 'public',\r\n        onUploadCompleted: {\r\n          callbackUrl: `${process.env.NEXT_PUBLIC_URL}/api/upload-complete`\r\n        }\r\n      }\r\n    },\r\n    request: new Request('https://dummy'),\r\n    onBeforeGenerateToken: async (pathname) => {\r\n      // Optional: validate user permissions\r\n      return {\r\n        allowedContentTypes: ['image/jpeg', 'image/png', 'image/webp'],\r\n        maximumSizeInBytes: 5 * 1024 * 1024 // 5MB\r\n      };\r\n    },\r\n    onUploadCompleted: async ({ blob, tokenPayload }) => {\r\n      console.log('Upload completed:', blob.url);\r\n    }\r\n  });\r\n\r\n  return jsonResponse;\r\n}\r\n```\r\n\r\n**Client Upload:**\r\n```typescript\r\n'use client';\r\n\r\nimport { upload } from '@vercel/blob/client';\r\nimport { getUploadToken } from './actions';\r\n\r\nexport function UploadForm() {\r\n  async function handleSubmit(e: React.FormEvent<HTMLFormElement>) {\r\n    e.preventDefault();\r\n    const form = e.currentTarget;\r\n    const file = (form.elements.namedItem('file') as HTMLInputElement).files?.[0];\r\n\r\n    if (!file) return;\r\n\r\n    const tokenResponse = await getUploadToken(file.name);\r\n\r\n    const blob = await upload(file.name, file, {\r\n      access: 'public',\r\n      handleUploadUrl: tokenResponse.url\r\n    });\r\n\r\n    console.log('Uploaded:', blob.url);\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit}>\r\n      <input type=\"file\" name=\"file\" required />\r\n      <button type=\"submit\">Upload</button>\r\n    </form>\r\n  );\r\n}\r\n```\r\n\r\n---\r\n\r\n### Step 4: List, Download, Delete\r\n\r\n**List Files:**\r\n```typescript\r\nimport { list } from '@vercel/blob';\r\n\r\nconst { blobs } = await list({\r\n  prefix: 'avatars/',\r\n  limit: 100\r\n});\r\n\r\n// Returns: { url, pathname, size, uploadedAt, ... }[]\r\n```\r\n\r\n**List with Pagination:**\r\n```typescript\r\nlet cursor: string | undefined;\r\nconst allBlobs = [];\r\n\r\ndo {\r\n  const { blobs, cursor: nextCursor } = await list({\r\n    prefix: 'uploads/',\r\n    cursor\r\n  });\r\n  allBlobs.push(...blobs);\r\n  cursor = nextCursor;\r\n} while (cursor);\r\n```\r\n\r\n**Download File:**\r\n```typescript\r\n// Files are publicly accessible if access: 'public'\r\nconst url = 'https://xyz.public.blob.vercel-storage.com/file.pdf';\r\nconst response = await fetch(url);\r\nconst blob = await response.blob();\r\n```\r\n\r\n**Delete File:**\r\n```typescript\r\nimport { del } from '@vercel/blob';\r\n\r\nawait del('https://xyz.public.blob.vercel-storage.com/file.jpg');\r\n\r\n// Or delete multiple\r\nawait del([url1, url2, url3]);\r\n```\r\n\r\n---\r\n\r\n### Step 5: Streaming & Multipart\r\n\r\n**Streaming Upload:**\r\n```typescript\r\nimport { put } from '@vercel/blob';\r\nimport { createReadStream } from 'fs';\r\n\r\nconst stream = createReadStream('./large-file.mp4');\r\n\r\nconst blob = await put('videos/large-file.mp4', stream, {\r\n  access: 'public',\r\n  contentType: 'video/mp4'\r\n});\r\n```\r\n\r\n**Multipart Upload (Large Files >500MB):**\r\n```typescript\r\nimport { createMultipartUpload, uploadPart, completeMultipartUpload } from '@vercel/blob';\r\n\r\n// 1. Start multipart upload\r\nconst upload = await createMultipartUpload('large-video.mp4', {\r\n  access: 'public'\r\n});\r\n\r\n// 2. Upload parts (chunks)\r\nconst partSize = 100 * 1024 * 1024; // 100MB chunks\r\nconst parts = [];\r\n\r\nfor (let i = 0; i < totalParts; i++) {\r\n  const chunk = getChunk(i, partSize);\r\n  const part = await uploadPart(chunk, {\r\n    uploadId: upload.uploadId,\r\n    partNumber: i + 1\r\n  });\r\n  parts.push(part);\r\n}\r\n\r\n// 3. Complete upload\r\nconst blob = await completeMultipartUpload({\r\n  uploadId: upload.uploadId,\r\n  parts\r\n});\r\n```\r\n\r\n---"
  }
}