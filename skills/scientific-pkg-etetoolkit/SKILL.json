{
  "description": "\"Phylogenetic tree toolkit (ETE). Tree manipulation (Newick/NHX), evolutionary event detection, orthology/paralogy, NCBI taxonomy, visualization (PDF/SVG), for phylogenomics.\"",
  "references": {
    "files": [
      "references/api_reference.md",
      "references/visualization.md",
      "references/workflows.md"
    ]
  },
  "content": "### 1. Tree Manipulation and Analysis\r\n\r\nLoad, manipulate, and analyze hierarchical tree structures with support for:\r\n\r\n- **Tree I/O**: Read and write Newick, NHX, PhyloXML, and NeXML formats\r\n- **Tree traversal**: Navigate trees using preorder, postorder, or levelorder strategies\r\n- **Topology modification**: Prune, root, collapse nodes, resolve polytomies\r\n- **Distance calculations**: Compute branch lengths and topological distances between nodes\r\n- **Tree comparison**: Calculate Robinson-Foulds distances and identify topological differences\r\n\r\n**Common patterns:**\r\n\r\n```python\r\nfrom ete3 import Tree\r\n\r\ntree = Tree(\"tree.nw\", format=1)\r\n\r\nprint(f\"Leaves: {len(tree)}\")\r\nprint(f\"Total nodes: {len(list(tree.traverse()))}\")\r\n\r\ntaxa_to_keep = [\"species1\", \"species2\", \"species3\"]\r\ntree.prune(taxa_to_keep, preserve_branch_length=True)\r\n\r\nmidpoint = tree.get_midpoint_outgroup()\r\ntree.set_outgroup(midpoint)\r\n\r\ntree.write(outfile=\"rooted_tree.nw\")\r\n```\r\n\r\nUse `scripts/tree_operations.py` for command-line tree manipulation:\r\n\r\n```bash\r\npython scripts/tree_operations.py stats tree.nw\r\n\r\npython scripts/tree_operations.py convert tree.nw output.nw --in-format 0 --out-format 1\r\n\r\npython scripts/tree_operations.py reroot tree.nw rooted.nw --midpoint\r\n\r\npython scripts/tree_operations.py prune tree.nw pruned.nw --keep-taxa \"sp1,sp2,sp3\"\r\n\r\npython scripts/tree_operations.py ascii tree.nw\r\n```\r\n\r\n### 2. Phylogenetic Analysis\r\n\r\nAnalyze gene trees with evolutionary event detection:\r\n\r\n- **Sequence alignment integration**: Link trees to multiple sequence alignments (FASTA, Phylip)\r\n- **Species naming**: Automatic or custom species extraction from gene names\r\n- **Evolutionary events**: Detect duplication and speciation events using Species Overlap or tree reconciliation\r\n- **Orthology detection**: Identify orthologs and paralogs based on evolutionary events\r\n- **Gene family analysis**: Split trees by duplications, collapse lineage-specific expansions\r\n\r\n**Workflow for gene tree analysis:**\r\n\r\n```python\r\nfrom ete3 import PhyloTree\r\n\r\ntree = PhyloTree(\"gene_tree.nw\", alignment=\"alignment.fasta\")\r\n\r\ndef get_species(gene_name):\r\n    return gene_name.split(\"_\")[0]\r\n\r\ntree.set_species_naming_function(get_species)\r\n\r\nevents = tree.get_descendant_evol_events()\r\n\r\nfor node in tree.traverse():\r\n    if hasattr(node, \"evoltype\"):\r\n        if node.evoltype == \"D\":\r\n            print(f\"Duplication at {node.name}\")\r\n        elif node.evoltype == \"S\":\r\n            print(f\"Speciation at {node.name}\")\r\n\r\northo_groups = tree.get_speciation_trees()\r\nfor i, ortho_tree in enumerate(ortho_groups):\r\n    ortho_tree.write(outfile=f\"ortholog_group_{i}.nw\")\r\n```\r\n\r\n**Finding orthologs and paralogs:**\r\n\r\n```python\r\nquery = tree & \"species1_gene1\"\r\n\r\northologs = []\r\nparalogs = []\r\n\r\nfor event in events:\r\n    if query in event.in_seqs:\r\n        if event.etype == \"S\":\r\n            orthologs.extend([s for s in event.out_seqs if s != query])\r\n        elif event.etype == \"D\":\r\n            paralogs.extend([s for s in event.out_seqs if s != query])\r\n```\r\n\r\n### 3. NCBI Taxonomy Integration\r\n\r\nIntegrate taxonomic information from NCBI Taxonomy database:\r\n\r\n- **Database access**: Automatic download and local caching of NCBI taxonomy (~300MB)\r\n- **Taxid/name translation**: Convert between taxonomic IDs and scientific names\r\n- **Lineage retrieval**: Get complete evolutionary lineages\r\n- **Taxonomy trees**: Build species trees connecting specified taxa\r\n- **Tree annotation**: Automatically annotate trees with taxonomic information\r\n\r\n**Building taxonomy-based trees:**\r\n\r\n```python\r\nfrom ete3 import NCBITaxa\r\n\r\nncbi = NCBITaxa()\r\n\r\nspecies = [\"Homo sapiens\", \"Pan troglodytes\", \"Mus musculus\"]\r\nname2taxid = ncbi.get_name_translator(species)\r\ntaxids = [name2taxid[sp][0] for sp in species]\r\n\r\ntree = ncbi.get_topology(taxids)\r\n\r\nfor node in tree.traverse():\r\n    if hasattr(node, \"sci_name\"):\r\n        print(f\"{node.sci_name} - Rank: {node.rank} - TaxID: {node.taxid}\")\r\n```\r\n\r\n**Annotating existing trees:**\r\n\r\n```python\r\nfor leaf in tree:\r\n    species = extract_species_from_name(leaf.name)\r\n    taxid = ncbi.get_name_translator([species])[species][0]\r\n\r\n    # Get lineage\r\n    lineage = ncbi.get_lineage(taxid)\r\n    ranks = ncbi.get_rank(lineage)\r\n    names = ncbi.get_taxid_translator(lineage)\r\n\r\n    # Add to node\r\n    leaf.add_feature(\"taxid\", taxid)\r\n    leaf.add_feature(\"lineage\", [names[t] for t in lineage])\r\n```\r\n\r\n### 4. Tree Visualization\r\n\r\nCreate publication-quality tree visualizations:\r\n\r\n- **Output formats**: PNG (raster), PDF, and SVG (vector) for publications\r\n- **Layout modes**: Rectangular and circular tree layouts\r\n- **Interactive GUI**: Explore trees interactively with zoom, pan, and search\r\n- **Custom styling**: NodeStyle for node appearance (colors, shapes, sizes)\r\n- **Faces**: Add graphical elements (text, images, charts, heatmaps) to nodes\r\n- **Layout functions**: Dynamic styling based on node properties\r\n\r\n**Basic visualization workflow:**\r\n\r\n```python\r\nfrom ete3 import Tree, TreeStyle, NodeStyle\r\n\r\ntree = Tree(\"tree.nw\")\r\n\r\nts = TreeStyle()\r\nts.show_leaf_name = True\r\nts.show_branch_support = True\r\nts.scale = 50  # pixels per branch length unit\r\n\r\nfor node in tree.traverse():\r\n    nstyle = NodeStyle()\r\n\r\n    if node.is_leaf():\r\n        nstyle[\"fgcolor\"] = \"blue\"\r\n        nstyle[\"size\"] = 8\r\n    else:\r\n        # Color by support\r\n        if node.support > 0.9:\r\n            nstyle[\"fgcolor\"] = \"darkgreen\"\r\n        else:\r\n            nstyle[\"fgcolor\"] = \"red\"\r\n        nstyle[\"size\"] = 5\r\n\r\n    node.set_style(nstyle)\r\n\r\ntree.render(\"tree.pdf\", tree_style=ts)\r\ntree.render(\"tree.png\", w=800, h=600, units=\"px\", dpi=300)\r\n```\r\n\r\nUse `scripts/quick_visualize.py` for rapid visualization:\r\n\r\n```bash\r\npython scripts/quick_visualize.py tree.nw output.pdf\r\n\r\npython scripts/quick_visualize.py tree.nw output.pdf --mode c --color-by-support\r\n\r\npython scripts/quick_visualize.py tree.nw output.png --width 1200 --height 800 --units px --dpi 300\r\n\r\npython scripts/quick_visualize.py tree.nw output.pdf --title \"Species Phylogeny\" --show-support\r\n```\r\n\r\n**Advanced visualization with faces:**\r\n\r\n```python\r\nfrom ete3 import Tree, TreeStyle, TextFace, CircleFace\r\n\r\ntree = Tree(\"tree.nw\")\r\n\r\nfor leaf in tree:\r\n    leaf.add_feature(\"habitat\", \"marine\" if \"fish\" in leaf.name else \"land\")\r\n\r\ndef layout(node):\r\n    if node.is_leaf():\r\n        # Add colored circle\r\n        color = \"blue\" if node.habitat == \"marine\" else \"green\"\r\n        circle = CircleFace(radius=5, color=color)\r\n        node.add_face(circle, column=0, position=\"aligned\")\r\n\r\n        # Add label\r\n        label = TextFace(node.name, fsize=10)\r\n        node.add_face(label, column=1, position=\"aligned\")\r\n\r\nts = TreeStyle()\r\nts.layout_fn = layout\r\nts.show_leaf_name = False\r\n\r\ntree.render(\"annotated_tree.pdf\", tree_style=ts)\r\n```\r\n\r\n### 5. Clustering Analysis\r\n\r\nAnalyze hierarchical clustering results with data integration:\r\n\r\n- **ClusterTree**: Specialized class for clustering dendrograms\r\n- **Data matrix linking**: Connect tree leaves to numerical profiles\r\n- **Cluster metrics**: Silhouette coefficient, Dunn index, inter/intra-cluster distances\r\n- **Validation**: Test cluster quality with different distance metrics\r\n- **Heatmap visualization**: Display data matrices alongside trees\r\n\r\n**Clustering workflow:**\r\n\r\n```python\r\nfrom ete3 import ClusterTree\r\n\r\nmatrix = \"\"\"#Names\\tSample1\\tSample2\\tSample3\r\nGene1\\t1.5\\t2.3\\t0.8\r\nGene2\\t0.9\\t1.1\\t1.8\r\nGene3\\t2.1\\t2.5\\t0.5\"\"\"\r\n\r\ntree = ClusterTree(\"((Gene1,Gene2),Gene3);\", text_array=matrix)\r\n\r\nfor node in tree.traverse():\r\n    if not node.is_leaf():\r\n        silhouette = node.get_silhouette()\r\n        dunn = node.get_dunn()\r\n\r\n        print(f\"Cluster: {node.name}\")\r\n        print(f\"  Silhouette: {silhouette:.3f}\")\r\n        print(f\"  Dunn index: {dunn:.3f}\")\r\n\r\ntree.show(\"heatmap\")\r\n```\r\n\r\n### 6. Tree Comparison\r\n\r\nQuantify topological differences between trees:\r\n\r\n- **Robinson-Foulds distance**: Standard metric for tree comparison\r\n- **Normalized RF**: Scale-invariant distance (0.0 to 1.0)\r\n- **Partition analysis**: Identify unique and shared bipartitions\r\n- **Consensus trees**: Analyze support across multiple trees\r\n- **Batch comparison**: Compare multiple trees pairwise\r\n\r\n**Compare two trees:**\r\n\r\n```python\r\nfrom ete3 import Tree\r\n\r\ntree1 = Tree(\"tree1.nw\")\r\ntree2 = Tree(\"tree2.nw\")\r\n\r\nrf, max_rf, common_leaves, parts_t1, parts_t2 = tree1.robinson_foulds(tree2)\r\n\r\nprint(f\"RF distance: {rf}/{max_rf}\")\r\nprint(f\"Normalized RF: {rf/max_rf:.3f}\")\r\nprint(f\"Common leaves: {len(common_leaves)}\")\r\n\r\nunique_t1 = parts_t1 - parts_t2\r\nunique_t2 = parts_t2 - parts_t1\r\n\r\nprint(f\"Unique to tree1: {len(unique_t1)}\")\r\nprint(f\"Unique to tree2: {len(unique_t2)}\")\r\n```\r\n\r\n**Compare multiple trees:**\r\n\r\n```python\r\nimport numpy as np\r\n\r\ntrees = [Tree(f\"tree{i}.nw\") for i in range(4)]\r\n\r\n\r\nInstall ETE toolkit:\r\n\r\n```bash\r\npip install ete3\r\n\r\nbrew install qt@5\r\n\r\nsudo apt-get install python3-pyqt5 python3-pyqt5.qtsvg\r\n\r\n\r\n### Use Case 1: Phylogenomic Pipeline\r\n\r\nComplete workflow from gene tree to ortholog identification:\r\n\r\n```python\r\nfrom ete3 import PhyloTree, NCBITaxa\r\n\r\ntree = PhyloTree(\"gene_tree.nw\", alignment=\"alignment.fasta\")\r\n\r\ntree.set_species_naming_function(lambda x: x.split(\"_\")[0])\r\n\r\ntree.get_descendant_evol_events()\r\n\r\nncbi = NCBITaxa()\r\nfor leaf in tree:\r\n    if leaf.species in species_to_taxid:\r\n        taxid = species_to_taxid[leaf.species]\r\n        lineage = ncbi.get_lineage(taxid)\r\n        leaf.add_feature(\"lineage\", lineage)\r\n\r\northo_groups = tree.get_speciation_trees()\r\n\r\nfor i, ortho in enumerate(ortho_groups):\r\n    ortho.write(outfile=f\"ortho_{i}.nw\")\r\n```\r\n\r\n### Use Case 2: Tree Preprocessing and Formatting\r\n\r\nBatch process trees for analysis:\r\n\r\n```bash\r\npython scripts/tree_operations.py convert input.nw output.nw --in-format 0 --out-format 1\r\n\r\npython scripts/tree_operations.py reroot input.nw rooted.nw --midpoint\r\n\r\npython scripts/tree_operations.py prune rooted.nw pruned.nw --keep-taxa taxa_list.txt\r\n\r\npython scripts/tree_operations.py stats pruned.nw\r\n```\r\n\r\n### Use Case 3: Publication-Quality Figures\r\n\r\nCreate styled visualizations:\r\n\r\n```python\r\nfrom ete3 import Tree, TreeStyle, NodeStyle, TextFace\r\n\r\ntree = Tree(\"tree.nw\")\r\n\r\nclade_colors = {\r\n    \"Mammals\": \"red\",\r\n    \"Birds\": \"blue\",\r\n    \"Fish\": \"green\"\r\n}\r\n\r\ndef layout(node):\r\n    # Highlight clades\r\n    if node.is_leaf():\r\n        for clade, color in clade_colors.items():\r\n            if clade in node.name:\r\n                nstyle = NodeStyle()\r\n                nstyle[\"fgcolor\"] = color\r\n                nstyle[\"size\"] = 8\r\n                node.set_style(nstyle)\r\n    else:\r\n        # Add support values\r\n        if node.support > 0.95:\r\n            support = TextFace(f\"{node.support:.2f}\", fsize=8)\r\n            node.add_face(support, column=0, position=\"branch-top\")\r\n\r\nts = TreeStyle()\r\nts.layout_fn = layout\r\nts.show_scale = True\r\n\r\n\r\nFor comprehensive API documentation, code examples, and detailed guides, refer to the following resources in the `references/` directory:\r\n\r\n- **`api_reference.md`**: Complete API documentation for all ETE classes and methods (Tree, PhyloTree, ClusterTree, NCBITaxa), including parameters, return types, and code examples\r\n- **`workflows.md`**: Common workflow patterns organized by task (tree operations, phylogenetic analysis, tree comparison, taxonomy integration, clustering analysis)\r\n- **`visualization.md`**: Comprehensive visualization guide covering TreeStyle, NodeStyle, Faces, layout functions, and advanced visualization techniques\r\n\r\nLoad these references when detailed information is needed:\r\n\r\n```python\r\n\r\n\r\n\r\n**Import errors:**\r\n\r\n```bash\r\npip install ete3\r\n\r\npip install ete3[gui]\r\n```\r\n\r\n**Rendering issues:**\r\n\r\nIf `tree.render()` or `tree.show()` fails with Qt-related errors, install system dependencies:\r\n\r\n```bash\r\nbrew install qt@5\r\n\r\nsudo apt-get install python3-pyqt5 python3-pyqt5.qtsvg\r\n```\r\n\r\n**NCBI Taxonomy database:**\r\n\r\nIf database download fails or becomes corrupted:\r\n\r\n```python\r\nfrom ete3 import NCBITaxa\r\nncbi = NCBITaxa()\r\nncbi.update_taxonomy_database()  # Redownload database\r\n```\r\n\r\n**Memory issues with large trees:**\r\n\r\nFor very large trees (>10,000 leaves), use iterators instead of list comprehensions:\r\n\r\n```python\r\nfor leaf in tree.iter_leaves():\r\n    process(leaf)",
  "name": "etetoolkit",
  "id": "scientific-pkg-etetoolkit",
  "sections": {
    "Reference Documentation": "```",
    "Troubleshooting": "for leaf in tree.get_leaves():  # Loads all into memory\r\n    process(leaf)\r\n```",
    "Overview": "ETE (Environment for Tree Exploration) is a toolkit for phylogenetic and hierarchical tree analysis. Manipulate trees, analyze evolutionary events, visualize results, and integrate with biological databases for phylogenomic research and clustering analysis.",
    "Installation and Setup": "pip install ete3[gui]\r\n```\r\n\r\n**First-time NCBI Taxonomy setup:**\r\n\r\nThe first time NCBITaxa is instantiated, it automatically downloads the NCBI taxonomy database (~300MB) to `~/.etetoolkit/taxa.sqlite`. This happens only once:\r\n\r\n```python\r\nfrom ete3 import NCBITaxa\r\nncbi = NCBITaxa()  # Downloads database on first run\r\n```\r\n\r\nUpdate taxonomy database:\r\n\r\n```python\r\nncbi.update_taxonomy_database()  # Download latest NCBI data\r\n```",
    "Best Practices": "1. **Preserve branch lengths**: Use `preserve_branch_length=True` when pruning for phylogenetic analysis\r\n2. **Cache content**: Use `get_cached_content()` for repeated access to node contents on large trees\r\n3. **Use iterators**: Employ `iter_*` methods for memory-efficient processing of large trees\r\n4. **Choose appropriate traversal**: Postorder for bottom-up analysis, preorder for top-down\r\n5. **Validate monophyly**: Always check returned clade type (monophyletic/paraphyletic/polyphyletic)\r\n6. **Vector formats for publication**: Use PDF or SVG for publication figures (scalable, editable)\r\n7. **Interactive testing**: Use `tree.show()` to test visualizations before rendering to file\r\n8. **PhyloTree for phylogenetics**: Use PhyloTree class for gene trees and evolutionary analysis\r\n9. **Copy method selection**: \"newick\" for speed, \"cpickle\" for full fidelity, \"deepcopy\" for complex objects\r\n10. **NCBI query caching**: Store NCBI taxonomy query results to avoid repeated database access",
    "Newick Format Reference": "ETE supports multiple Newick format specifications (0-100):\r\n\r\n- **Format 0**: Flexible with branch lengths (default)\r\n- **Format 1**: With internal node names\r\n- **Format 2**: With bootstrap/support values\r\n- **Format 5**: Internal node names + branch lengths\r\n- **Format 8**: All features (names, distances, support)\r\n- **Format 9**: Leaf names only\r\n- **Format 100**: Topology only\r\n\r\nSpecify format when reading/writing:\r\n\r\n```python\r\ntree = Tree(\"tree.nw\", format=1)\r\ntree.write(outfile=\"output.nw\", format=5)\r\n```\r\n\r\nNHX (New Hampshire eXtended) format preserves custom features:\r\n\r\n```python\r\ntree.write(outfile=\"tree.nhx\", features=[\"habitat\", \"temperature\", \"depth\"])\r\n```",
    "Common Use Cases": "tree.render(\"figure.pdf\", w=200, units=\"mm\", tree_style=ts)\r\ntree.render(\"figure.svg\", tree_style=ts)  # Editable vector\r\n```\r\n\r\n### Use Case 4: Automated Tree Analysis\r\n\r\nProcess multiple trees systematically:\r\n\r\n```python\r\nfrom ete3 import Tree\r\nimport os\r\n\r\ninput_dir = \"trees\"\r\noutput_dir = \"processed\"\r\n\r\nfor filename in os.listdir(input_dir):\r\n    if filename.endswith(\".nw\"):\r\n        tree = Tree(os.path.join(input_dir, filename))\r\n\r\n        # Standardize: midpoint root, resolve polytomies\r\n        midpoint = tree.get_midpoint_outgroup()\r\n        tree.set_outgroup(midpoint)\r\n        tree.resolve_polytomy(recursive=True)\r\n\r\n        # Filter low support branches\r\n        for node in tree.traverse():\r\n            if hasattr(node, 'support') and node.support < 0.5:\r\n                if not node.is_leaf() and not node.is_root():\r\n                    node.delete()\r\n\r\n        # Save processed tree\r\n        output_file = os.path.join(output_dir, f\"processed_{filename}\")\r\n        tree.write(outfile=output_file)\r\n```",
    "Core Capabilities": "n = len(trees)\r\ndist_matrix = np.zeros((n, n))\r\n\r\nfor i in range(n):\r\n    for j in range(i+1, n):\r\n        rf, max_rf, _, _, _ = trees[i].robinson_foulds(trees[j])\r\n        norm_rf = rf / max_rf if max_rf > 0 else 0\r\n        dist_matrix[i, j] = norm_rf\r\n        dist_matrix[j, i] = norm_rf\r\n```"
  }
}