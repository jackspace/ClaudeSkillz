{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-21\r\n**Dependencies**: cloudflare-worker-base (recommended)\r\n**Latest Versions**: agents@latest, @modelcontextprotocol/sdk@latest\r\n**Production Tested**: Cloudflare's own MCP servers (https://github.com/cloudflare/mcp-server-cloudflare)\r\n\r\n---\r\n\r\n\r\nBuild MCP servers using the Agents SDK.\r\n\r\n### MCP Server Setup\r\n\r\n```bash\r\nnpm install @modelcontextprotocol/sdk agents\r\n```\r\n\r\n### Basic MCP Server\r\n\r\n```typescript\r\nimport { McpAgent } from \"agents/mcp\";\r\nimport { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\r\nimport { z } from \"zod\";\r\n\r\nexport class MyMCP extends McpAgent {\r\n  server = new McpServer({ name: \"Demo\", version: \"1.0.0\" });\r\n\r\n  async init() {\r\n    // Define a tool\r\n    this.server.tool(\r\n      \"add\",\r\n      \"Add two numbers together\",\r\n      {\r\n        a: z.number().describe(\"First number\"),\r\n        b: z.number().describe(\"Second number\")\r\n      },\r\n      async ({ a, b }) => ({\r\n        content: [{ type: \"text\", text: String(a + b) }]\r\n      })\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### Stateful MCP Server\r\n\r\n```typescript\r\ntype State = { counter: number };\r\n\r\nexport class StatefulMCP extends McpAgent<Env, State> {\r\n  server = new McpServer({ name: \"Counter\", version: \"1.0.0\" });\r\n\r\n  initialState: State = { counter: 0 };\r\n\r\n  async init() {\r\n    // Resource\r\n    this.server.resource(\r\n      \"counter\",\r\n      \"mcp://resource/counter\",\r\n      (uri) => ({\r\n        contents: [{ uri: uri.href, text: String(this.state.counter) }]\r\n      })\r\n    );\r\n\r\n    // Tool\r\n    this.server.tool(\r\n      \"increment\",\r\n      \"Increment the counter\",\r\n      { amount: z.number() },\r\n      async ({ amount }) => {\r\n        this.setState({\r\n          ...this.state,\r\n          counter: this.state.counter + amount\r\n        });\r\n\r\n        return {\r\n          content: [{\r\n            type: \"text\",\r\n            text: `Counter is now ${this.state.counter}`\r\n          }]\r\n        };\r\n      }\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n### MCP Transport Configuration\r\n\r\n```typescript\r\nimport { Hono } from 'hono';\r\n\r\nconst app = new Hono();\r\n\r\n// Modern streamable HTTP transport (recommended)\r\napp.mount('/mcp', MyMCP.serve('/mcp').fetch, { replaceRequest: false });\r\n\r\n// Legacy SSE transport (deprecated)\r\napp.mount('/sse', MyMCP.serveSSE('/sse').fetch, { replaceRequest: false });\r\n\r\nexport default app;\r\n```\r\n\r\n**Transport Comparison:**\r\n- **/mcp**: Streamable HTTP (modern, recommended)\r\n- **/sse**: Server-Sent Events (legacy, deprecated)\r\n\r\n### MCP with OAuth\r\n\r\n```typescript\r\nimport { OAuthProvider } from '@cloudflare/workers-oauth-provider';\r\n\r\nexport default new OAuthProvider({\r\n  apiHandlers: {\r\n    '/sse': MyMCP.serveSSE('/sse'),\r\n    '/mcp': MyMCP.serve('/mcp')\r\n  },\r\n  // OAuth configuration\r\n  clientId: 'your-client-id',\r\n  clientSecret: 'your-client-secret',\r\n  // ... other OAuth settings\r\n});\r\n```\r\n\r\n### Testing MCP Server\r\n\r\n```bash\r\nnpx @modelcontextprotocol/inspector@latest",
  "name": "cloudflare-agents",
  "id": "cloudflare-agents",
  "sections": {
    "Configuration Deep Dive": "### Complete wrangler.jsonc Example\r\n\r\n```jsonc\r\n{\r\n  \"$schema\": \"node_modules/wrangler/config-schema.json\",\r\n  \"name\": \"my-agent\",\r\n  \"main\": \"src/index.ts\",\r\n  \"account_id\": \"YOUR_ACCOUNT_ID\",\r\n  \"compatibility_date\": \"2025-10-21\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n\r\n  // Durable Objects configuration (REQUIRED)\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"MyAgent\",\r\n        \"class_name\": \"MyAgent\"\r\n      }\r\n    ]\r\n  },\r\n\r\n  // Migrations (REQUIRED)\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"MyAgent\"]  // Enables state persistence\r\n    }\r\n  ],\r\n\r\n  // Optional: Workers AI binding (for AI model calls)\r\n  \"ai\": {\r\n    \"binding\": \"AI\"\r\n  },\r\n\r\n  // Optional: Vectorize binding (for RAG)\r\n  \"vectorize\": {\r\n    \"bindings\": [\r\n      {\r\n        \"binding\": \"VECTORIZE\",\r\n        \"index_name\": \"my-agent-vectors\"\r\n      }\r\n    ]\r\n  },\r\n\r\n  // Optional: Browser Rendering binding (for web browsing)\r\n  \"browser\": {\r\n    \"binding\": \"BROWSER\"\r\n  },\r\n\r\n  // Optional: Workflows binding (for async workflows)\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"MY_WORKFLOW\",\r\n      \"class_name\": \"MyWorkflow\",\r\n      \"script_name\": \"my-workflow-script\"  // If in different project\r\n    }\r\n  ],\r\n\r\n  // Optional: D1 binding (for additional persistent data)\r\n  \"d1_databases\": [\r\n    {\r\n      \"binding\": \"DB\",\r\n      \"database_name\": \"my-agent-db\",\r\n      \"database_id\": \"your-database-id\"\r\n    }\r\n  ],\r\n\r\n  // Optional: R2 binding (for file storage)\r\n  \"r2_buckets\": [\r\n    {\r\n      \"binding\": \"BUCKET\",\r\n      \"bucket_name\": \"my-agent-files\"\r\n    }\r\n  ],\r\n\r\n  // Optional: Environment variables\r\n  \"vars\": {\r\n    \"ENVIRONMENT\": \"production\"\r\n  },\r\n\r\n  // Optional: Secrets (set with: wrangler secret put KEY)\r\n  // OPENAI_API_KEY, ANTHROPIC_API_KEY, etc.\r\n\r\n  // Observability\r\n  \"observability\": {\r\n    \"enabled\": true\r\n  }\r\n}\r\n```\r\n\r\n### Migrations Best Practices\r\n\r\n**Atomic Deployments**: Migrations are **atomic operations** - they cannot be gradually deployed.\r\n\r\n```jsonc\r\n{\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"MyAgent\"]  // Initial: enable SQLite\r\n    },\r\n    {\r\n      \"tag\": \"v2\",\r\n      \"renamed_classes\": [\r\n        {\"from\": \"MyAgent\", \"to\": \"MyRenamedAgent\"}\r\n      ]\r\n    },\r\n    {\r\n      \"tag\": \"v3\",\r\n      \"deleted_classes\": [\"OldAgent\"]\r\n    },\r\n    {\r\n      \"tag\": \"v4\",\r\n      \"transferred_classes\": [\r\n        {\r\n          \"from\": \"AgentInOldScript\",\r\n          \"from_script\": \"old-worker\",\r\n          \"to\": \"AgentInNewScript\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Migration Rules:**\r\n- ✅ Each migration needs a unique `tag`\r\n- ✅ Cannot enable SQLite on existing deployed class (must be in first migration)\r\n- ✅ Migrations apply in order during deployment\r\n- ✅ Cannot edit or remove previous migration tags\r\n- ❌ Never deploy new migrations gradually (atomic only)\r\n\r\n### Environment-Specific Migrations\r\n\r\n```jsonc\r\n{\r\n  \"migrations\": [{\"tag\": \"v1\", \"new_sqlite_classes\": [\"MyAgent\"]}],\r\n  \"env\": {\r\n    \"staging\": {\r\n      \"migrations\": [\r\n        {\"tag\": \"v1\", \"new_sqlite_classes\": [\"MyAgent\"]},\r\n        {\"tag\": \"v2-staging\", \"renamed_classes\": [{\"from\": \"MyAgent\", \"to\": \"StagingAgent\"}]}\r\n      ]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Browse the Web": "Agents can browse the web using [Browser Rendering](https://developers.cloudflare.com/browser-rendering/).\r\n\r\n### Browser Rendering Binding\r\n\r\n`wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"browser\": {\r\n    \"binding\": \"BROWSER\"\r\n  }\r\n}\r\n```\r\n\r\n### Installation\r\n\r\n```bash\r\nnpm install @cloudflare/puppeteer\r\n```\r\n\r\n### Web Scraping Example\r\n\r\n```typescript\r\nimport { Agent } from \"agents\";\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  BROWSER: Fetcher;\r\n  OPENAI_API_KEY: string;\r\n}\r\n\r\nexport class BrowserAgent extends Agent<Env> {\r\n  async browse(urls: string[]) {\r\n    const responses = [];\r\n\r\n    for (const url of urls) {\r\n      const browser = await puppeteer.launch(this.env.BROWSER);\r\n      const page = await browser.newPage();\r\n\r\n      await page.goto(url);\r\n      await page.waitForSelector(\"body\");\r\n\r\n      const bodyContent = await page.$eval(\"body\", el => el.innerHTML);\r\n\r\n      // Extract data with AI\r\n      const data = await this.extractData(bodyContent);\r\n      responses.push({ url, data });\r\n\r\n      await browser.close();\r\n    }\r\n\r\n    return responses;\r\n  }\r\n\r\n  async extractData(html: string): Promise<any> {\r\n    // Use OpenAI or Workers AI to extract structured data\r\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${this.env.OPENAI_API_KEY}`,\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({\r\n        model: 'gpt-4o-mini',\r\n        messages: [{\r\n          role: 'user',\r\n          content: `Extract product info from HTML: ${html.slice(0, 4000)}`\r\n        }],\r\n        response_format: { type: \"json_object\" }\r\n      })\r\n    });\r\n\r\n    const result = await response.json();\r\n    return JSON.parse(result.choices[0].message.content);\r\n  }\r\n\r\n  async onRequest(request: Request): Promise<Response> {\r\n    const url = new URL(request.url).searchParams.get('url');\r\n    if (!url) {\r\n      return new Response(\"Missing url parameter\", { status: 400 });\r\n    }\r\n\r\n    const results = await this.browse([url]);\r\n    return Response.json(results);\r\n  }\r\n}\r\n```\r\n\r\n### Screenshot Capture\r\n\r\n```typescript\r\nexport class ScreenshotAgent extends Agent<Env> {\r\n  async captureScreenshot(url: string): Promise<Buffer> {\r\n    const browser = await puppeteer.launch(this.env.BROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    await page.goto(url);\r\n    const screenshot = await page.screenshot({ fullPage: true });\r\n\r\n    await browser.close();\r\n\r\n    return screenshot;\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **15+** documented issues:\r\n\r\n### Issue 1: Migrations Not Atomic\r\n**Error**: \"Cannot gradually deploy migration\"\r\n**Source**: https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/\r\n**Why**: Migrations apply to all instances simultaneously\r\n**Prevention**: Deploy migrations independently of code changes, use `npx wrangler versions deploy`\r\n\r\n### Issue 2: Missing new_sqlite_classes\r\n**Error**: \"Cannot enable SQLite on existing class\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/configuration/\r\n**Why**: SQLite must be enabled in first migration\r\n**Prevention**: Include `new_sqlite_classes` in tag \"v1\" migration\r\n\r\n### Issue 3: Agent Class Not Exported\r\n**Error**: \"Binding not found\" or \"Cannot access undefined\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/agents-api/\r\n**Why**: Durable Objects require exported class\r\n**Prevention**: `export class MyAgent extends Agent` (with export keyword)\r\n\r\n### Issue 4: Binding Name Mismatch\r\n**Error**: \"Binding 'X' not found\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/configuration/\r\n**Why**: Binding name must match class name exactly\r\n**Prevention**: Ensure `name` and `class_name` are identical in wrangler.jsonc\r\n\r\n### Issue 5: Global Uniqueness Not Understood\r\n**Error**: Unexpected behavior with agent instances\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/agents-api/\r\n**Why**: Same name always returns same agent instance globally\r\n**Prevention**: Use unique identifiers (userId, sessionId) for instance names\r\n\r\n### Issue 6: WebSocket State Not Persisted\r\n**Error**: Connection state lost after disconnect\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/websockets/\r\n**Why**: WebSocket connections don't persist, but agent state does\r\n**Prevention**: Store important data in agent state via setState(), not connection state\r\n\r\n### Issue 7: Scheduled Task Callback Doesn't Exist\r\n**Error**: \"Method X does not exist on Agent\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/\r\n**Why**: this.schedule() calls method that isn't defined\r\n**Prevention**: Ensure callback method exists before scheduling\r\n\r\n### Issue 8: State Size Limit Exceeded\r\n**Error**: \"Maximum database size exceeded\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/store-and-sync-state/\r\n**Why**: Agent state + scheduled tasks exceed 1GB\r\n**Prevention**: Monitor state size, use external storage (D1, R2) for large data\r\n\r\n### Issue 9: Scheduled Task Too Large\r\n**Error**: \"Task payload exceeds 2MB\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/schedule-tasks/\r\n**Why**: Each task maps to database row with 2MB limit\r\n**Prevention**: Keep task payloads minimal, store large data in agent state/SQL\r\n\r\n### Issue 10: Workflow Binding Missing\r\n**Error**: \"Cannot read property 'create' of undefined\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/run-workflows/\r\n**Why**: Workflow binding not configured in wrangler.jsonc\r\n**Prevention**: Add workflow binding before using this.env.WORKFLOW\r\n\r\n### Issue 11: Browser Binding Required\r\n**Error**: \"BROWSER binding undefined\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/browse-the-web/\r\n**Why**: Browser Rendering requires explicit binding\r\n**Prevention**: Add `\"browser\": { \"binding\": \"BROWSER\" }` to wrangler.jsonc\r\n\r\n### Issue 12: Vectorize Index Not Found\r\n**Error**: \"Index does not exist\"\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/rag/\r\n**Why**: Vectorize index must be created before use\r\n**Prevention**: Run `wrangler vectorize create` before deploying agent\r\n\r\n### Issue 13: MCP Transport Confusion\r\n**Error**: \"SSE transport deprecated\"\r\n**Source**: https://developers.cloudflare.com/agents/model-context-protocol/transport/\r\n**Why**: SSE transport is legacy, streamable HTTP is recommended\r\n**Prevention**: Use `/mcp` endpoint with `MyMCP.serve('/mcp')`, not `/sse`\r\n\r\n### Issue 14: Authentication Bypass\r\n**Error**: Security vulnerability\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/calling-agents/\r\n**Why**: Authentication done in Agent instead of Worker\r\n**Prevention**: Always authenticate in Worker before calling getAgentByName()\r\n\r\n### Issue 15: Instance Naming Errors\r\n**Error**: Cross-user data leakage\r\n**Source**: https://developers.cloudflare.com/agents/api-reference/calling-agents/\r\n**Why**: Poor instance naming allows access to wrong agent\r\n**Prevention**: Use namespaced names like `user-${userId}`, validate ownership\r\n\r\n---",
    "Dependencies": "### Required\r\n- **cloudflare-worker-base** - Foundation (Hono, Vite, Workers setup)\r\n\r\n### Optional (by feature)\r\n- **cloudflare-workers-ai** - For Workers AI model calls\r\n- **cloudflare-vectorize** - For RAG with Vectorize\r\n- **cloudflare-d1** - For additional persistent storage beyond agent state\r\n- **cloudflare-r2** - For file storage\r\n- **cloudflare-queues** - For message queues\r\n\r\n### NPM Packages\r\n- `agents` - Agents SDK (required)\r\n- `@modelcontextprotocol/sdk` - For building MCP servers\r\n- `@cloudflare/puppeteer` - For web browsing\r\n- `ai` - AI SDK for model calls\r\n- `@ai-sdk/openai` - OpenAI models\r\n- `@ai-sdk/anthropic` - Anthropic models\r\n\r\n---",
    "Agent Class API": "The `Agent` class is the foundation of the Agents SDK. Extend it to create your agent.\r\n\r\n### Basic Agent Structure\r\n\r\n```typescript\r\nimport { Agent } from \"agents\";\r\n\r\ninterface Env {\r\n  // Environment variables and bindings\r\n  OPENAI_API_KEY: string;\r\n  AI: Ai;\r\n  VECTORIZE: Vectorize;\r\n  DB: D1Database;\r\n}\r\n\r\ninterface State {\r\n  // Your agent's persistent state\r\n  counter: number;\r\n  messages: string[];\r\n  lastUpdated: Date | null;\r\n}\r\n\r\nexport class MyAgent extends Agent<Env, State> {\r\n  // Optional: Set initial state (first time agent is created)\r\n  initialState: State = {\r\n    counter: 0,\r\n    messages: [],\r\n    lastUpdated: null\r\n  };\r\n\r\n  // Optional: Called when agent instance starts or wakes from hibernation\r\n  async onStart() {\r\n    console.log('Agent started:', this.name, 'State:', this.state);\r\n  }\r\n\r\n  // Handle HTTP requests\r\n  async onRequest(request: Request): Promise<Response> {\r\n    return Response.json({ message: \"Hello from Agent\", state: this.state });\r\n  }\r\n\r\n  // Handle WebSocket connections (optional)\r\n  async onConnect(connection: Connection, ctx: ConnectionContext) {\r\n    console.log('Client connected:', connection.id);\r\n    // Connections are automatically accepted\r\n  }\r\n\r\n  // Handle WebSocket messages (optional)\r\n  async onMessage(connection: Connection, message: WSMessage) {\r\n    if (typeof message === 'string') {\r\n      connection.send(`Echo: ${message}`);\r\n    }\r\n  }\r\n\r\n  // Handle WebSocket errors (optional)\r\n  async onError(connection: Connection, error: unknown): Promise<void> {\r\n    console.error('Connection error:', error);\r\n  }\r\n\r\n  // Handle WebSocket close (optional)\r\n  async onClose(connection: Connection, code: number, reason: string, wasClean: boolean): Promise<void> {\r\n    console.log('Connection closed:', code, reason);\r\n  }\r\n\r\n  // Called when state is updated from any source (optional)\r\n  onStateUpdate(state: State, source: \"server\" | Connection) {\r\n    console.log('State updated:', state, 'Source:', source);\r\n  }\r\n\r\n  // Custom methods (call from any handler)\r\n  async customMethod(data: any) {\r\n    this.setState({\r\n      ...this.state,\r\n      counter: this.state.counter + 1,\r\n      lastUpdated: new Date()\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### Accessing Agent Properties\r\n\r\nWithin any Agent method:\r\n\r\n```typescript\r\nexport class MyAgent extends Agent<Env, State> {\r\n  async someMethod() {\r\n    // Access environment variables and bindings\r\n    const apiKey = this.env.OPENAI_API_KEY;\r\n    const ai = this.env.AI;\r\n\r\n    // Access current state (read-only)\r\n    const counter = this.state.counter;\r\n\r\n    // Update state (persisted automatically)\r\n    this.setState({ ...this.state, counter: counter + 1 });\r\n\r\n    // Access SQL database\r\n    const results = await this.sql`SELECT * FROM users`;\r\n\r\n    // Get agent instance name\r\n    const instanceName = this.name;  // e.g., \"user-123\"\r\n\r\n    // Schedule tasks\r\n    await this.schedule(60, \"runLater\", { data: \"example\" });\r\n\r\n    // Call other methods\r\n    await this.customMethod({ foo: \"bar\" });\r\n  }\r\n}\r\n```\r\n\r\n---",
    "What is Cloudflare Agents?": "The Cloudflare Agents SDK enables building AI-powered autonomous agents that run on Cloudflare Workers + Durable Objects. Agents can:\r\n\r\n- **Communicate in real-time** via WebSockets and Server-Sent Events\r\n- **Persist state** with built-in SQLite database (up to 1GB per agent)\r\n- **Schedule tasks** using delays, specific dates, or cron expressions\r\n- **Run workflows** by triggering asynchronous Cloudflare Workflows\r\n- **Browse the web** using Browser Rendering API + Puppeteer\r\n- **Implement RAG** with Vectorize vector database + Workers AI embeddings\r\n- **Build MCP servers** implementing the Model Context Protocol\r\n- **Support human-in-the-loop** patterns for review and approval\r\n- **Scale to millions** of independent agent instances globally\r\n\r\nEach agent instance is a **globally unique, stateful micro-server** that can run for seconds, minutes, or hours.\r\n\r\n---",
    "Quick Start (10 Minutes)": "### 1. Scaffold Project with Template\r\n\r\n```bash\r\nnpm create cloudflare@latest my-agent -- \\\r\n  --template=cloudflare/agents-starter \\\r\n  --ts \\\r\n  --git \\\r\n  --deploy false\r\n```\r\n\r\n**What this creates:**\r\n- Complete Agent project structure\r\n- TypeScript configuration\r\n- wrangler.jsonc with Durable Objects bindings\r\n- Example chat agent implementation\r\n- React client with useAgent hook\r\n\r\n### 2. Or Add to Existing Worker\r\n\r\n```bash\r\ncd my-existing-worker\r\nnpm install agents\r\n```\r\n\r\n**Then create an Agent class:**\r\n\r\n```typescript\r\n// src/index.ts\r\nimport { Agent, AgentNamespace } from \"agents\";\r\n\r\nexport class MyAgent extends Agent {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    return new Response(\"Hello from Agent!\");\r\n  }\r\n}\r\n\r\nexport default MyAgent;\r\n```\r\n\r\n### 3. Configure Durable Objects Binding\r\n\r\nCreate or update `wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"$schema\": \"node_modules/wrangler/config-schema.json\",\r\n  \"name\": \"my-agent\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-21\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"MyAgent\",        // MUST match class name\r\n        \"class_name\": \"MyAgent\"   // MUST match exported class\r\n      }\r\n    ]\r\n  },\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"MyAgent\"]  // CRITICAL: Enables SQLite storage\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**CRITICAL Configuration Rules:**\r\n- ✅ `name` and `class_name` **MUST be identical**\r\n- ✅ `new_sqlite_classes` **MUST be in first migration** (cannot add later)\r\n- ✅ Agent class **MUST be exported** (or binding will fail)\r\n- ✅ Migration tags **CANNOT be reused** (each migration needs unique tag)\r\n\r\n### 4. Deploy\r\n\r\n```bash\r\nnpx wrangler@latest deploy\r\n```\r\n\r\nYour agent is now running at: `https://my-agent.<subdomain>.workers.dev`\r\n\r\n---",
    "WebSockets": "### Complete WebSocket Example\r\n\r\n```typescript\r\nimport { Agent, Connection, ConnectionContext, WSMessage } from \"agents\";\r\n\r\ninterface ChatState {\r\n  messages: Array<{ id: string; text: string; sender: string; timestamp: number }>;\r\n  participants: string[];\r\n}\r\n\r\nexport class ChatAgent extends Agent<Env, ChatState> {\r\n  initialState: ChatState = {\r\n    messages: [],\r\n    participants: []\r\n  };\r\n\r\n  async onConnect(connection: Connection, ctx: ConnectionContext) {\r\n    // Access original HTTP request for auth\r\n    const authHeader = ctx.request.headers.get('Authorization');\r\n    const userId = ctx.request.headers.get('X-User-ID') || 'anonymous';\r\n\r\n    // Connections are automatically accepted\r\n    // Optionally close connection if unauthorized:\r\n    // if (!authHeader) {\r\n    //   connection.close(401, \"Unauthorized\");\r\n    //   return;\r\n    // }\r\n\r\n    // Add to participants\r\n    this.setState({\r\n      ...this.state,\r\n      participants: [...this.state.participants, userId]\r\n    });\r\n\r\n    // Send welcome message\r\n    connection.send(JSON.stringify({\r\n      type: 'welcome',\r\n      message: 'Connected to chat',\r\n      participants: this.state.participants\r\n    }));\r\n  }\r\n\r\n  async onMessage(connection: Connection, message: WSMessage) {\r\n    if (typeof message === 'string') {\r\n      try {\r\n        const data = JSON.parse(message);\r\n\r\n        if (data.type === 'chat') {\r\n          // Add message to state\r\n          const newMessage = {\r\n            id: crypto.randomUUID(),\r\n            text: data.text,\r\n            sender: data.sender || 'anonymous',\r\n            timestamp: Date.now()\r\n          };\r\n\r\n          this.setState({\r\n            ...this.state,\r\n            messages: [...this.state.messages, newMessage]\r\n          });\r\n\r\n          // Broadcast to this connection (state sync will broadcast to all)\r\n          connection.send(JSON.stringify({\r\n            type: 'message_added',\r\n            message: newMessage\r\n          }));\r\n        }\r\n      } catch (e) {\r\n        connection.send(JSON.stringify({ type: 'error', message: 'Invalid message format' }));\r\n      }\r\n    }\r\n  }\r\n\r\n  async onError(connection: Connection, error: unknown): Promise<void> {\r\n    console.error('WebSocket error:', error);\r\n    // Optionally log to external monitoring\r\n  }\r\n\r\n  async onClose(connection: Connection, code: number, reason: string, wasClean: boolean): Promise<void> {\r\n    console.log(`Connection ${connection.id} closed:`, code, reason, wasClean);\r\n    // Clean up connection-specific state if needed\r\n  }\r\n}\r\n```\r\n\r\n### Connection Management\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async onMessage(connection: Connection, message: WSMessage) {\r\n    // Connection properties\r\n    const connId = connection.id;  // Unique connection ID\r\n    const connState = connection.state;  // Connection-specific state\r\n\r\n    // Update connection state (not agent state)\r\n    connection.setState({ ...connection.state, lastActive: Date.now() });\r\n\r\n    // Send to this connection only\r\n    connection.send(\"Message to this client\");\r\n\r\n    // Close connection programmatically\r\n    connection.close(1000, \"Goodbye\");\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Bundled Resources": "### Templates (templates/)\r\n- `wrangler-agents-config.jsonc` - Complete configuration example\r\n- `basic-agent.ts` - Minimal HTTP agent\r\n- `websocket-agent.ts` - WebSocket handlers\r\n- `state-sync-agent.ts` - State management patterns\r\n- `scheduled-agent.ts` - Task scheduling\r\n- `workflow-agent.ts` - Workflow integration\r\n- `browser-agent.ts` - Web browsing\r\n- `rag-agent.ts` - RAG implementation\r\n- `chat-agent-streaming.ts` - Streaming chat\r\n- `calling-agents-worker.ts` - Agent routing\r\n- `react-useagent-client.tsx` - React client\r\n- `mcp-server-basic.ts` - MCP server\r\n- `hitl-agent.ts` - Human-in-the-loop\r\n\r\n### References (references/)\r\n- `agent-class-api.md` - Complete Agent class reference\r\n- `client-api-reference.md` - Browser client APIs\r\n- `state-management-guide.md` - State and SQL deep dive\r\n- `websockets-sse.md` - WebSocket vs SSE comparison\r\n- `scheduling-api.md` - Task scheduling details\r\n- `workflows-integration.md` - Workflows guide\r\n- `browser-rendering.md` - Web browsing patterns\r\n- `rag-patterns.md` - RAG best practices\r\n- `mcp-server-guide.md` - MCP server development\r\n- `mcp-tools-reference.md` - MCP tools API\r\n- `hitl-patterns.md` - Human-in-the-loop workflows\r\n- `best-practices.md` - Production patterns\r\n\r\n### Examples (examples/)\r\n- `chat-bot-complete.md` - Full chat agent\r\n- `multi-agent-workflow.md` - Agent orchestration\r\n- `scheduled-reports.md` - Recurring tasks\r\n- `browser-scraper-agent.md` - Web scraping\r\n- `rag-knowledge-base.md` - RAG system\r\n- `mcp-remote-server.md` - Production MCP server\r\n\r\n---\r\n\r\n**Last Verified**: 2025-10-21\r\n**Package Versions**: agents@latest\r\n**Compliance**: Cloudflare Agents SDK official documentation",
    "HTTP & Server-Sent Events": "### HTTP Request Handling\r\n\r\n```typescript\r\nexport class MyAgent extends Agent<Env> {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    const url = new URL(request.url);\r\n    const method = request.method;\r\n\r\n    if (method === \"POST\" && url.pathname === \"/increment\") {\r\n      const counter = (this.state.counter || 0) + 1;\r\n      this.setState({ ...this.state, counter });\r\n      return Response.json({ counter });\r\n    }\r\n\r\n    if (method === \"GET\" && url.pathname === \"/status\") {\r\n      return Response.json({ state: this.state, name: this.name });\r\n    }\r\n\r\n    return new Response(\"Not Found\", { status: 404 });\r\n  }\r\n}\r\n```\r\n\r\n### Server-Sent Events (SSE) Streaming\r\n\r\n```typescript\r\nexport class MyAgent extends Agent<Env> {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    const stream = new ReadableStream({\r\n      async start(controller) {\r\n        const encoder = new TextEncoder();\r\n\r\n        // Send events to client\r\n        controller.enqueue(encoder.encode('data: {\"message\": \"Starting\"}\\n\\n'));\r\n\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n        controller.enqueue(encoder.encode('data: {\"message\": \"Processing\"}\\n\\n'));\r\n\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n\r\n        controller.enqueue(encoder.encode('data: {\"message\": \"Complete\"}\\n\\n'));\r\n\r\n        controller.close();\r\n      }\r\n    });\r\n\r\n    return new Response(stream, {\r\n      headers: {\r\n        'Content-Type': 'text/event-stream',\r\n        'Cache-Control': 'no-cache',\r\n        'Connection': 'keep-alive'\r\n      }\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n**SSE vs WebSockets:**\r\n\r\n| Feature | SSE | WebSockets |\r\n|---------|-----|------------|\r\n| Direction | Server → Client only | Bi-directional |\r\n| Protocol | HTTP | ws:// or wss:// |\r\n| Reconnection | Automatic | Manual |\r\n| Binary Data | Limited | Full support |\r\n| Use Case | Streaming responses, notifications | Chat, real-time collaboration |\r\n\r\n**Recommendation**: Use WebSockets for most agent applications (full duplex, better for long sessions).\r\n\r\n---",
    "Official Documentation": "- **Agents SDK**: https://developers.cloudflare.com/agents/\r\n- **API Reference**: https://developers.cloudflare.com/agents/api-reference/\r\n- **Durable Objects**: https://developers.cloudflare.com/durable-objects/\r\n- **Workflows**: https://developers.cloudflare.com/workflows/\r\n- **Vectorize**: https://developers.cloudflare.com/vectorize/\r\n- **Browser Rendering**: https://developers.cloudflare.com/browser-rendering/\r\n- **Model Context Protocol**: https://modelcontextprotocol.io/\r\n- **Cloudflare MCP Servers**: https://github.com/cloudflare/mcp-server-cloudflare\r\n\r\n---",
    "Critical Rules": "### Always Do ✅\r\n\r\n1. **Export Agent class** - Must be exported for binding to work\r\n2. **Include new_sqlite_classes in v1 migration** - Cannot add SQLite later\r\n3. **Match binding name to class name** - Prevents \"binding not found\" errors\r\n4. **Authenticate in Worker, not Agent** - Security best practice\r\n5. **Use tagged template literals for SQL** - Prevents SQL injection\r\n6. **Handle WebSocket disconnections** - State persists, connections don't\r\n7. **Verify scheduled task callback exists** - Throws error if method missing\r\n8. **Use global unique instance names** - Same name = same agent globally\r\n9. **Check state size limits** - Max 1GB total per agent\r\n10. **Monitor task payload size** - Max 2MB per scheduled task\r\n11. **Use workflow bindings correctly** - Must be configured in wrangler.jsonc\r\n12. **Create Vectorize indexes before inserting** - Required for metadata filtering\r\n13. **Close browser instances** - Prevent resource leaks\r\n14. **Use setState() for persistence** - Don't just modify this.state\r\n15. **Test migrations locally first** - Migrations are atomic, can't rollback\r\n\r\n### Never Do ❌\r\n\r\n1. **Don't add SQLite to existing deployed class** - Must be in first migration\r\n2. **Don't gradually deploy migrations** - Atomic only\r\n3. **Don't skip authentication in Worker** - Always auth before agent access\r\n4. **Don't construct SQL strings manually** - Use tagged templates\r\n5. **Don't exceed 1GB state per agent** - Hard limit\r\n6. **Don't schedule tasks with non-existent callbacks** - Runtime error\r\n7. **Don't assume same name = different agent** - Global uniqueness\r\n8. **Don't use SSE for MCP** - Deprecated, use /mcp transport\r\n9. **Don't forget browser binding** - Required for web browsing\r\n10. **Don't modify this.state directly** - Use setState() instead\r\n\r\n---",
    "Run Workflows": "Agents can trigger asynchronous [Cloudflare Workflows](https://developers.cloudflare.com/workflows/).\r\n\r\n### Workflow Binding Configuration\r\n\r\n`wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"MY_WORKFLOW\",\r\n      \"class_name\": \"MyWorkflow\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\nIf Workflow is in a different script:\r\n\r\n```jsonc\r\n{\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"EMAIL_WORKFLOW\",\r\n      \"class_name\": \"EmailWorkflow\",\r\n      \"script_name\": \"email-workflows\"  // Different project\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### Triggering a Workflow\r\n\r\n```typescript\r\nimport { Agent } from \"agents\";\r\nimport { WorkflowEntrypoint, WorkflowEvent, WorkflowStep } from \"cloudflare:workers\";\r\n\r\ninterface Env {\r\n  MY_WORKFLOW: Workflow;\r\n  MyAgent: AgentNamespace<MyAgent>;\r\n}\r\n\r\nexport class MyAgent extends Agent<Env> {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    const userId = new URL(request.url).searchParams.get('userId');\r\n\r\n    // Trigger a workflow immediately\r\n    const instance = await this.env.MY_WORKFLOW.create({\r\n      id: `user-${userId}`,\r\n      params: { userId, action: \"process\" }\r\n    });\r\n\r\n    // Or schedule a delayed workflow trigger\r\n    await this.schedule(300, \"runWorkflow\", { userId });\r\n\r\n    return Response.json({ workflowId: instance.id });\r\n  }\r\n\r\n  async runWorkflow(data: { userId: string }) {\r\n    const instance = await this.env.MY_WORKFLOW.create({\r\n      id: `delayed-${data.userId}`,\r\n      params: data\r\n    });\r\n\r\n    // Monitor workflow status periodically\r\n    await this.schedule(\"*/5 * * * *\", \"checkWorkflowStatus\", { id: instance.id });\r\n  }\r\n\r\n  async checkWorkflowStatus(data: { id: string }) {\r\n    // Check workflow status (see Workflows docs for details)\r\n    console.log('Checking workflow:', data.id);\r\n  }\r\n}\r\n\r\n// Workflow definition (can be in same or different file/project)\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env> {\r\n  async run(event: WorkflowEvent<{ userId: string }>, step: WorkflowStep) {\r\n    // Workflow implementation\r\n    const result = await step.do('process-data', async () => {\r\n      return { processed: true };\r\n    });\r\n\r\n    return result;\r\n  }\r\n}\r\n```\r\n\r\n### Agents vs Workflows\r\n\r\n| Feature | Agents | Workflows |\r\n|---------|--------|-----------|\r\n| **Purpose** | Interactive, user-facing | Background processing |\r\n| **Duration** | Seconds to hours | Minutes to hours |\r\n| **State** | SQLite database | Step-based checkpoints |\r\n| **Interaction** | WebSockets, HTTP | No direct interaction |\r\n| **Retry** | Manual | Automatic per step |\r\n| **Use Case** | Chat, real-time UI | ETL, batch processing |\r\n\r\n**Best Practice**: Use Agents to **coordinate** multiple Workflows. Agents can trigger, monitor, and respond to Workflow results while maintaining user interaction.\r\n\r\n---",
    "Calling Agents": "### Using routeAgentRequest\r\n\r\nAutomatically route requests to agents based on URL pattern `/agents/:agent/:name`:\r\n\r\n```typescript\r\nimport { Agent, AgentNamespace, routeAgentRequest } from 'agents';\r\n\r\ninterface Env {\r\n  MyAgent: AgentNamespace<MyAgent>;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    // Routes to: /agents/my-agent/user-123\r\n    const response = await routeAgentRequest(request, env);\r\n\r\n    if (response) {\r\n      return response;\r\n    }\r\n\r\n    return new Response(\"Not Found\", { status: 404 });\r\n  }\r\n} satisfies ExportedHandler<Env>;\r\n\r\nexport class MyAgent extends Agent<Env> {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    return Response.json({ agent: this.name });\r\n  }\r\n}\r\n```\r\n\r\n**URL Pattern**: `/agents/my-agent/user-123`\r\n- `my-agent` = class name in kebab-case\r\n- `user-123` = agent instance name\r\n\r\n### Using getAgentByName\r\n\r\nFor custom routing or calling agents from Workers:\r\n\r\n```typescript\r\nimport { Agent, AgentNamespace, getAgentByName } from 'agents';\r\n\r\ninterface Env {\r\n  MyAgent: AgentNamespace<MyAgent>;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const userId = new URL(request.url).searchParams.get('userId') || 'anonymous';\r\n\r\n    // Get or create agent instance\r\n    const agent = getAgentByName<Env, MyAgent>(env.MyAgent, `user-${userId}`);\r\n\r\n    // Pass request to agent\r\n    return (await agent).fetch(request);\r\n  }\r\n} satisfies ExportedHandler<Env>;\r\n\r\nexport class MyAgent extends Agent<Env> {\r\n  // Agent implementation\r\n}\r\n```\r\n\r\n### Calling Agent Methods Directly\r\n\r\n```typescript\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const agent = getAgentByName<Env, MyAgent>(env.MyAgent, 'user-123');\r\n\r\n    // Call custom methods on agent using RPC\r\n    const result = await (await agent).customMethod({ data: \"example\" });\r\n\r\n    return Response.json({ result });\r\n  }\r\n}\r\n\r\nexport class MyAgent extends Agent<Env> {\r\n  async customMethod(params: { data: string }): Promise<any> {\r\n    return { processed: params.data };\r\n  }\r\n}\r\n```\r\n\r\n### Multi-Agent Communication\r\n\r\n```typescript\r\ninterface Env {\r\n  AgentA: AgentNamespace<AgentA>;\r\n  AgentB: AgentNamespace<AgentB>;\r\n}\r\n\r\nexport class AgentA extends Agent<Env> {\r\n  async processData(data: any) {\r\n    // Call another agent\r\n    const agentB = getAgentByName<Env, AgentB>(this.env.AgentB, 'processor-1');\r\n    const result = await (await agentB).analyze(data);\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nexport class AgentB extends Agent<Env> {\r\n  async analyze(data: any) {\r\n    return { analyzed: true, data };\r\n  }\r\n}\r\n```\r\n\r\n### Authentication Patterns\r\n\r\n```typescript\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    // Authenticate BEFORE invoking agent\r\n    const authHeader = request.headers.get('Authorization');\r\n    if (!authHeader) {\r\n      return new Response(\"Unauthorized\", { status: 401 });\r\n    }\r\n\r\n    const userId = await verifyToken(authHeader);\r\n    if (!userId) {\r\n      return new Response(\"Forbidden\", { status: 403 });\r\n    }\r\n\r\n    // Only create/access agent for authenticated users\r\n    const agent = getAgentByName<Env, MyAgent>(env.MyAgent, `user-${userId}`);\r\n    return (await agent).fetch(request);\r\n  }\r\n}\r\n```\r\n\r\n**CRITICAL**: Always authenticate in Worker, **NOT** in Agent. Agents should assume the caller is authorized.\r\n\r\n---",
    "Client APIs": "### AgentClient (Browser)\r\n\r\n```typescript\r\nimport { AgentClient } from \"agents/client\";\r\n\r\n// Connect to agent instance\r\nconst client = new AgentClient({\r\n  agent: \"chat-agent\",        // Class name in kebab-case\r\n  name: \"room-123\",           // Instance name\r\n  host: window.location.host\r\n});\r\n\r\nclient.onopen = () => {\r\n  console.log(\"Connected\");\r\n  client.send(JSON.stringify({ type: \"join\", user: \"alice\" }));\r\n};\r\n\r\nclient.onmessage = (event) => {\r\n  const data = JSON.parse(event.data);\r\n  console.log(\"Received:\", data);\r\n};\r\n\r\nclient.onclose = () => {\r\n  console.log(\"Disconnected\");\r\n};\r\n```\r\n\r\n### agentFetch (HTTP Requests)\r\n\r\n```typescript\r\nimport { agentFetch } from \"agents/client\";\r\n\r\nasync function getData() {\r\n  const response = await agentFetch(\r\n    { agent: \"my-agent\", name: \"user-123\" },\r\n    {\r\n      method: \"GET\",\r\n      headers: { \"Authorization\": `Bearer ${token}` }\r\n    }\r\n  );\r\n\r\n  const data = await response.json();\r\n  return data;\r\n}\r\n```\r\n\r\n### useAgent Hook (React)\r\n\r\n```typescript\r\nimport { useAgent } from \"agents/react\";\r\nimport { useState } from \"react\";\r\n\r\nfunction ChatUI() {\r\n  const [messages, setMessages] = useState([]);\r\n\r\n  const connection = useAgent({\r\n    agent: \"chat-agent\",\r\n    name: \"room-123\",\r\n    onMessage: (event) => {\r\n      const data = JSON.parse(event.data);\r\n      if (data.type === 'message') {\r\n        setMessages(prev => [...prev, data.message]);\r\n      }\r\n    },\r\n    onOpen: () => console.log(\"Connected\"),\r\n    onClose: () => console.log(\"Disconnected\")\r\n  });\r\n\r\n  const sendMessage = (text: string) => {\r\n    connection.send(JSON.stringify({ type: 'chat', text }));\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {messages.map((msg, i) => <div key={i}>{msg.text}</div>)}\r\n      <button onClick={() => sendMessage(\"Hello\")}>Send</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### State Synchronization\r\n\r\n```typescript\r\nimport { useAgent } from \"agents/react\";\r\nimport { useState } from \"react\";\r\n\r\nfunction Counter() {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const agent = useAgent({\r\n    agent: \"counter-agent\",\r\n    name: \"my-counter\",\r\n    onStateUpdate: (newState) => {\r\n      setCount(newState.counter);\r\n    }\r\n  });\r\n\r\n  const increment = () => {\r\n    agent.setState({ counter: count + 1 });\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <p>Count: {count}</p>\r\n      <button onClick={increment}>Increment</button>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### useAgentChat Hook\r\n\r\n```typescript\r\nimport { useAgentChat } from \"agents/ai-react\";\r\n\r\nfunction ChatInterface() {\r\n  const { messages, input, handleInputChange, handleSubmit, isLoading } = useAgentChat({\r\n    agent: \"ai-chat-agent\",\r\n    name: \"chat-session-123\"\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <div>\r\n        {messages.map((msg, i) => (\r\n          <div key={i}>\r\n            <strong>{msg.role}:</strong> {msg.content}\r\n          </div>\r\n        ))}\r\n      </div>\r\n\r\n      <form onSubmit={handleSubmit}>\r\n        <input\r\n          value={input}\r\n          onChange={handleInputChange}\r\n          placeholder=\"Type a message...\"\r\n          disabled={isLoading}\r\n        />\r\n        <button type=\"submit\" disabled={isLoading}>\r\n          {isLoading ? \"Thinking...\" : \"Send\"}\r\n        </button>\r\n      </form>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n---",
    "Model Context Protocol (MCP)": "```\r\n\r\n**Cloudflare's MCP Servers**: See [reference](https://developers.cloudflare.com/agents/model-context-protocol/mcp-servers-for-cloudflare/) for production examples.\r\n\r\n---",
    "Retrieval Augmented Generation (RAG)": "Implement RAG using Vectorize + Workers AI embeddings.\r\n\r\n### Vectorize Binding\r\n\r\n`wrangler.jsonc`:\r\n\r\n```jsonc\r\n{\r\n  \"ai\": {\r\n    \"binding\": \"AI\"\r\n  },\r\n  \"vectorize\": {\r\n    \"bindings\": [\r\n      {\r\n        \"binding\": \"VECTORIZE\",\r\n        \"index_name\": \"my-agent-vectors\"\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### Create Index\r\n\r\n```bash\r\nnpx wrangler vectorize create my-agent-vectors \\\r\n  --dimensions=768 \\\r\n  --metric=cosine\r\n```\r\n\r\n### Complete RAG Implementation\r\n\r\n```typescript\r\nimport { Agent } from \"agents\";\r\nimport { generateText } from \"ai\";\r\nimport { openai } from \"@ai-sdk/openai\";\r\n\r\ninterface Env {\r\n  AI: Ai;\r\n  VECTORIZE: Vectorize;\r\n  OPENAI_API_KEY: string;\r\n}\r\n\r\nexport class RAGAgent extends Agent<Env> {\r\n  // Ingest documents\r\n  async ingestDocuments(documents: Array<{ id: string; text: string; metadata: any }>) {\r\n    const vectors = [];\r\n\r\n    for (const doc of documents) {\r\n      // Generate embedding with Workers AI\r\n      const { data } = await this.env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n        text: [doc.text]\r\n      });\r\n\r\n      vectors.push({\r\n        id: doc.id,\r\n        values: data[0],\r\n        metadata: { ...doc.metadata, text: doc.text }\r\n      });\r\n    }\r\n\r\n    // Insert into Vectorize\r\n    await this.env.VECTORIZE.upsert(vectors);\r\n\r\n    return { ingested: vectors.length };\r\n  }\r\n\r\n  // Query knowledge base\r\n  async queryKnowledge(userQuery: string, topK: number = 5) {\r\n    // Generate query embedding\r\n    const { data } = await this.env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n      text: [userQuery]\r\n    });\r\n\r\n    // Search Vectorize\r\n    const results = await this.env.VECTORIZE.query(data[0], { topK });\r\n\r\n    // Extract relevant documents\r\n    const context = results.matches.map(match => match.metadata.text).join('\\n\\n');\r\n\r\n    return context;\r\n  }\r\n\r\n  // RAG Chat\r\n  async chat(userMessage: string) {\r\n    // Retrieve relevant context\r\n    const context = await this.queryKnowledge(userMessage);\r\n\r\n    // Generate response with context\r\n    const { text } = await generateText({\r\n      model: openai('gpt-4o-mini'),\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: `You are a helpful assistant. Use the following context to answer questions:\\n\\n${context}`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: userMessage\r\n        }\r\n      ]\r\n    });\r\n\r\n    return { response: text, context };\r\n  }\r\n\r\n  async onRequest(request: Request): Promise<Response> {\r\n    const { message } = await request.json();\r\n    const result = await this.chat(message);\r\n    return Response.json(result);\r\n  }\r\n}\r\n```\r\n\r\n### Metadata Filtering\r\n\r\n```typescript\r\n// Create metadata indexes BEFORE inserting vectors\r\nawait this.env.VECTORIZE.createMetadataIndex(\"category\");\r\nawait this.env.VECTORIZE.createMetadataIndex(\"language\");\r\n\r\n// Query with filters\r\nconst results = await this.env.VECTORIZE.query(queryVector, {\r\n  topK: 10,\r\n  filter: {\r\n    category: { $eq: \"documentation\" },\r\n    language: { $eq: \"en\" }\r\n  }\r\n});\r\n```\r\n\r\n**See**: [cloudflare-vectorize skill](../cloudflare-vectorize/) for complete Vectorize guide.\r\n\r\n---",
    "Using AI Models": "### AI SDK (Vercel)\r\n\r\n```bash\r\nnpm install ai @ai-sdk/openai @ai-sdk/anthropic\r\n```\r\n\r\n```typescript\r\nimport { Agent } from \"agents\";\r\nimport { generateText, streamText } from \"ai\";\r\nimport { openai } from \"@ai-sdk/openai\";\r\nimport { anthropic } from \"@ai-sdk/anthropic\";\r\n\r\nexport class AIAgent extends Agent {\r\n  // Simple text generation\r\n  async generateResponse(prompt: string) {\r\n    const { text } = await generateText({\r\n      model: openai('gpt-4o-mini'),\r\n      prompt\r\n    });\r\n\r\n    return text;\r\n  }\r\n\r\n  // Streaming response\r\n  async streamResponse(prompt: string): Promise<Response> {\r\n    const result = streamText({\r\n      model: anthropic('claude-sonnet-4-5'),\r\n      prompt\r\n    });\r\n\r\n    return result.toTextStreamResponse();\r\n  }\r\n\r\n  // Structured output\r\n  async extractData(text: string) {\r\n    const { object } = await generateObject({\r\n      model: openai('gpt-4o-mini'),\r\n      schema: z.object({\r\n        name: z.string(),\r\n        email: z.string().email(),\r\n        age: z.number().optional()\r\n      }),\r\n      prompt: `Extract user info from: ${text}`\r\n    });\r\n\r\n    return object;\r\n  }\r\n}\r\n```\r\n\r\n### Workers AI\r\n\r\n```typescript\r\ninterface Env {\r\n  AI: Ai;\r\n}\r\n\r\nexport class WorkersAIAgent extends Agent<Env> {\r\n  async generateText(prompt: string) {\r\n    const response = await this.env.AI.run('@cf/meta/llama-3-8b-instruct', {\r\n      messages: [{ role: 'user', content: prompt }]\r\n    });\r\n\r\n    return response;\r\n  }\r\n\r\n  async generateImage(prompt: string) {\r\n    const response = await this.env.AI.run('@cf/black-forest-labs/flux-1-schnell', {\r\n      prompt\r\n    });\r\n\r\n    return response;\r\n  }\r\n}\r\n```\r\n\r\n**See**: [cloudflare-workers-ai skill](../cloudflare-workers-ai/) for complete Workers AI guide.\r\n\r\n---",
    "Schedule Tasks": "Agents can schedule tasks to run in the future using `this.schedule()`.\r\n\r\n### Delay (Seconds)\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async onRequest(request: Request): Promise<Response> {\r\n    // Schedule task to run in 60 seconds\r\n    const { id } = await this.schedule(60, \"checkStatus\", { requestId: \"123\" });\r\n\r\n    return Response.json({ scheduledTaskId: id });\r\n  }\r\n\r\n  // This method will be called in 60 seconds\r\n  async checkStatus(data: { requestId: string }) {\r\n    console.log('Checking status for request:', data.requestId);\r\n    // Perform check, update state, send notification, etc.\r\n  }\r\n}\r\n```\r\n\r\n### Specific Date\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async scheduleReminder(reminderDate: string) {\r\n    const date = new Date(reminderDate);\r\n\r\n    const { id } = await this.schedule(date, \"sendReminder\", {\r\n      message: \"Time for your appointment!\"\r\n    });\r\n\r\n    return id;\r\n  }\r\n\r\n  async sendReminder(data: { message: string }) {\r\n    console.log('Sending reminder:', data.message);\r\n    // Send email, push notification, etc.\r\n  }\r\n}\r\n```\r\n\r\n### Cron Expressions\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async setupRecurringTasks() {\r\n    // Every 10 minutes\r\n    await this.schedule(\"*/10 * * * *\", \"checkUpdates\", {});\r\n\r\n    // Every day at 8 AM\r\n    await this.schedule(\"0 8 * * *\", \"dailyReport\", {});\r\n\r\n    // Every Monday at 9 AM\r\n    await this.schedule(\"0 9 * * 1\", \"weeklyReport\", {});\r\n\r\n    // Every hour on the hour\r\n    await this.schedule(\"0 * * * *\", \"hourlyCheck\", {});\r\n  }\r\n\r\n  async checkUpdates(data: any) {\r\n    console.log('Checking for updates...');\r\n  }\r\n\r\n  async dailyReport(data: any) {\r\n    console.log('Generating daily report...');\r\n  }\r\n\r\n  async weeklyReport(data: any) {\r\n    console.log('Generating weekly report...');\r\n  }\r\n\r\n  async hourlyCheck(data: any) {\r\n    console.log('Running hourly check...');\r\n  }\r\n}\r\n```\r\n\r\n### Managing Scheduled Tasks\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async manageSchedules() {\r\n    // Get all scheduled tasks\r\n    const allTasks = this.getSchedules();\r\n    console.log('Total tasks:', allTasks.length);\r\n\r\n    // Get specific task by ID\r\n    const taskId = \"some-task-id\";\r\n    const task = await this.getSchedule(taskId);\r\n\r\n    if (task) {\r\n      console.log('Task:', task.callback, 'at', new Date(task.time));\r\n      console.log('Payload:', task.payload);\r\n      console.log('Type:', task.type);  // \"scheduled\" | \"delayed\" | \"cron\"\r\n\r\n      // Cancel the task\r\n      const cancelled = await this.cancelSchedule(taskId);\r\n      console.log('Cancelled:', cancelled);\r\n    }\r\n\r\n    // Get tasks in time range\r\n    const upcomingTasks = this.getSchedules({\r\n      timeRange: {\r\n        start: new Date(),\r\n        end: new Date(Date.now() + 24 * 60 * 60 * 1000)  // Next 24 hours\r\n      }\r\n    });\r\n\r\n    console.log('Upcoming tasks:', upcomingTasks.length);\r\n\r\n    // Filter by type\r\n    const cronTasks = this.getSchedules({ type: \"cron\" });\r\n    const delayedTasks = this.getSchedules({ type: \"delayed\" });\r\n  }\r\n}\r\n```\r\n\r\n**Scheduling Constraints:**\r\n- Each task maps to a SQL database row (max 2 MB per task)\r\n- Total tasks limited by: `(task_size * count) + other_state < 1GB`\r\n- Cron tasks continue running until explicitly cancelled\r\n- Callback method MUST exist on Agent class (throws error if missing)\r\n\r\n**CRITICAL ERROR**: If callback method doesn't exist:\r\n```typescript\r\n// ❌ BAD: Method doesn't exist\r\nawait this.schedule(60, \"nonExistentMethod\", {});\r\n\r\n// ✅ GOOD: Method exists\r\nawait this.schedule(60, \"existingMethod\", {});\r\n\r\nasync existingMethod(data: any) {\r\n  // Implementation\r\n}\r\n```\r\n\r\n---",
    "State Management": "### Using setState()\r\n\r\n```typescript\r\ninterface UserState {\r\n  name: string;\r\n  email: string;\r\n  preferences: { theme: string; notifications: boolean };\r\n  loginCount: number;\r\n  lastLogin: Date | null;\r\n}\r\n\r\nexport class UserAgent extends Agent<Env, UserState> {\r\n  initialState: UserState = {\r\n    name: \"\",\r\n    email: \"\",\r\n    preferences: { theme: \"dark\", notifications: true },\r\n    loginCount: 0,\r\n    lastLogin: null\r\n  };\r\n\r\n  async onRequest(request: Request): Promise<Response> {\r\n    if (request.method === \"POST\" && new URL(request.url).pathname === \"/login\") {\r\n      // Update state\r\n      this.setState({\r\n        ...this.state,\r\n        loginCount: this.state.loginCount + 1,\r\n        lastLogin: new Date()\r\n      });\r\n\r\n      // State is automatically persisted and synced to connected clients\r\n      return Response.json({ success: true, state: this.state });\r\n    }\r\n\r\n    return Response.json({ state: this.state });\r\n  }\r\n\r\n  onStateUpdate(state: UserState, source: \"server\" | Connection) {\r\n    console.log('State updated:', state);\r\n    console.log('Source:', source);  // \"server\" or Connection object\r\n\r\n    // React to state changes\r\n    if (state.loginCount > 10) {\r\n      console.log('Frequent user!');\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**State Rules:**\r\n- ✅ State is JSON-serializable (objects, arrays, strings, numbers, booleans, null)\r\n- ✅ State persists across agent restarts\r\n- ✅ State is immediately consistent within the agent\r\n- ✅ State automatically syncs to connected WebSocket clients\r\n- ❌ State cannot contain functions or circular references\r\n- ❌ Total state size limited by database size (1GB max per agent)\r\n\r\n### Using SQL Database\r\n\r\nEach agent has a built-in SQLite database accessible via `this.sql`:\r\n\r\n```typescript\r\nexport class MyAgent extends Agent {\r\n  async onStart() {\r\n    // Create tables on first start\r\n    await this.sql`\r\n      CREATE TABLE IF NOT EXISTS users (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        name TEXT NOT NULL,\r\n        email TEXT UNIQUE NOT NULL,\r\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n      )\r\n    `;\r\n\r\n    await this.sql`\r\n      CREATE INDEX IF NOT EXISTS idx_email ON users(email)\r\n    `;\r\n  }\r\n\r\n  async addUser(name: string, email: string) {\r\n    // Insert with prepared statement (prevents SQL injection)\r\n    const result = await this.sql`\r\n      INSERT INTO users (name, email)\r\n      VALUES (${name}, ${email})\r\n    `;\r\n\r\n    return result;\r\n  }\r\n\r\n  async getUser(email: string) {\r\n    // Query returns array of results\r\n    const users = await this.sql`\r\n      SELECT * FROM users WHERE email = ${email}\r\n    `;\r\n\r\n    return users[0] || null;\r\n  }\r\n\r\n  async getAllUsers() {\r\n    const users = await this.sql`\r\n      SELECT * FROM users ORDER BY created_at DESC\r\n    `;\r\n\r\n    return users;\r\n  }\r\n\r\n  async updateUser(id: number, name: string) {\r\n    await this.sql`\r\n      UPDATE users SET name = ${name} WHERE id = ${id}\r\n    `;\r\n  }\r\n\r\n  async deleteUser(id: number) {\r\n    await this.sql`\r\n      DELETE FROM users WHERE id = ${id}\r\n    `;\r\n  }\r\n}\r\n```\r\n\r\n**SQL Best Practices:**\r\n- ✅ Use tagged template literals (prevents SQL injection)\r\n- ✅ Create indexes for frequently queried columns\r\n- ✅ Use transactions for multiple related operations\r\n- ✅ Query results are always arrays (even for single row)\r\n- ❌ Don't construct SQL strings manually\r\n- ❌ Be mindful of 1GB database size limit\r\n\r\n---",
    "Patterns & Concepts": "### Chat Agents (AIChatAgent)\r\n\r\n```typescript\r\nimport { AIChatAgent } from \"agents/ai-chat-agent\";\r\nimport { streamText } from \"ai\";\r\nimport { openai } from \"@ai-sdk/openai\";\r\n\r\nexport class MyChatAgent extends AIChatAgent<Env> {\r\n  async onChatMessage(onFinish) {\r\n    const result = streamText({\r\n      model: openai('gpt-4o-mini'),\r\n      messages: this.messages,\r\n      onFinish\r\n    });\r\n\r\n    return result.toTextStreamResponse();\r\n  }\r\n\r\n  // Optional: Customize message persistence\r\n  async onStateUpdate(state, source) {\r\n    console.log('Chat state updated:', this.messages.length, 'messages');\r\n  }\r\n}\r\n```\r\n\r\n### Human-in-the-Loop (HITL)\r\n\r\n```typescript\r\nexport class ApprovalAgent extends Agent {\r\n  async processRequest(data: any) {\r\n    // Process automatically\r\n    const processed = await this.autoProcess(data);\r\n\r\n    // If confidence low, request human review\r\n    if (processed.confidence < 0.8) {\r\n      this.setState({\r\n        ...this.state,\r\n        pendingReview: {\r\n          data: processed,\r\n          requestedAt: Date.now(),\r\n          status: 'pending'\r\n        }\r\n      });\r\n\r\n      // Send notification to human\r\n      await this.notifyHuman(processed);\r\n\r\n      return { status: 'pending_review', id: processed.id };\r\n    }\r\n\r\n    // High confidence, proceed automatically\r\n    return this.complete(processed);\r\n  }\r\n\r\n  async approveReview(id: string, approved: boolean) {\r\n    const pending = this.state.pendingReview;\r\n\r\n    if (approved) {\r\n      await this.complete(pending.data);\r\n    } else {\r\n      await this.reject(pending.data);\r\n    }\r\n\r\n    this.setState({\r\n      ...this.state,\r\n      pendingReview: null\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n### Tools Concept\r\n\r\nTools enable agents to interact with external services:\r\n\r\n```typescript\r\nexport class ToolAgent extends Agent {\r\n  // Tool: Search flights\r\n  async searchFlights(from: string, to: string, date: string) {\r\n    const response = await fetch(`https://api.flights.com/search`, {\r\n      method: 'POST',\r\n      body: JSON.stringify({ from, to, date })\r\n    });\r\n    return response.json();\r\n  }\r\n\r\n  // Tool: Book flight\r\n  async bookFlight(flightId: string, passengers: any[]) {\r\n    const response = await fetch(`https://api.flights.com/book`, {\r\n      method: 'POST',\r\n      body: JSON.stringify({ flightId, passengers })\r\n    });\r\n    return response.json();\r\n  }\r\n\r\n  // Tool: Send confirmation email\r\n  async sendEmail(to: string, subject: string, body: string) {\r\n    // Use email service\r\n    return { sent: true };\r\n  }\r\n\r\n  // Orchestrate tools\r\n  async bookTrip(params: any) {\r\n    const flights = await this.searchFlights(params.from, params.to, params.date);\r\n    const booking = await this.bookFlight(flights[0].id, params.passengers);\r\n    await this.sendEmail(params.email, \"Booking Confirmed\", `Booking ID: ${booking.id}`);\r\n\r\n    return booking;\r\n  }\r\n}\r\n```\r\n\r\n### Multi-Agent Orchestration\r\n\r\n```typescript\r\ninterface Env {\r\n  ResearchAgent: AgentNamespace<ResearchAgent>;\r\n  WriterAgent: AgentNamespace<WriterAgent>;\r\n  EditorAgent: AgentNamespace<EditorAgent>;\r\n}\r\n\r\nexport class OrchestratorAgent extends Agent<Env> {\r\n  async createArticle(topic: string) {\r\n    // 1. Research agent gathers information\r\n    const researcher = getAgentByName<Env, ResearchAgent>(\r\n      this.env.ResearchAgent,\r\n      `research-${topic}`\r\n    );\r\n    const research = await (await researcher).research(topic);\r\n\r\n    // 2. Writer agent creates draft\r\n    const writer = getAgentByName<Env, WriterAgent>(\r\n      this.env.WriterAgent,\r\n      `writer-${topic}`\r\n    );\r\n    const draft = await (await writer).write(research);\r\n\r\n    // 3. Editor agent reviews\r\n    const editor = getAgentByName<Env, EditorAgent>(\r\n      this.env.EditorAgent,\r\n      `editor-${topic}`\r\n    );\r\n    const final = await (await editor).edit(draft);\r\n\r\n    return final;\r\n  }\r\n}\r\n```\r\n\r\n---"
  }
}