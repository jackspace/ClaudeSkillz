{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/example-reference.md"
    ]
  },
  "content": "**Status**: Production Ready\r\n**Last Updated**: 2025-10-29\r\n**Dependencies**: None\r\n**Latest Versions**: next@15.3.2, ai@5.0.82, zod@3.24.2, zustand@5.0.3\r\n\r\n---",
  "name": "better-chatbot-patterns",
  "id": "better-chatbot-patterns",
  "sections": {
    "Production Example": "These patterns are extracted from **better-chatbot**:\r\n- **Live**: https://betterchatbot.vercel.app\r\n- **Tests**: 48+ E2E tests passing\r\n- **Errors**: 0 (patterns proven in production)\r\n- **Validation**: ✅ Multi-user, multi-provider, workflow execution\r\n\r\n---\r\n\r\n**Token Efficiency**: ~65% savings | **Errors Prevented**: 5 | **Production Verified**: Yes",
    "Pattern 3: Multi-AI Provider Setup": "### The Problem\r\nSupporting multiple AI providers (OpenAI, Anthropic, Google, xAI, etc.) requires:\r\n- Different SDK initialization patterns\r\n- Provider-specific configurations\r\n- Unified interface for switching providers\r\n\r\n### The Solution: Provider Registry\r\n\r\nCreate `lib/ai/providers.ts`:\r\n\r\n```typescript\r\nimport { createOpenAI } from \"@ai-sdk/openai\"\r\nimport { createAnthropic } from \"@ai-sdk/anthropic\"\r\nimport { createGoogleGenerativeAI } from \"@ai-sdk/google\"\r\n\r\nexport type AIProvider = \"openai\" | \"anthropic\" | \"google\" | \"xai\" | \"groq\"\r\n\r\nexport const providers = {\r\n  openai: createOpenAI({\r\n    apiKey: process.env.OPENAI_API_KEY,\r\n    compatibility: \"strict\"\r\n  }),\r\n\r\n  anthropic: createAnthropic({\r\n    apiKey: process.env.ANTHROPIC_API_KEY\r\n  }),\r\n\r\n  google: createGoogleGenerativeAI({\r\n    apiKey: process.env.GOOGLE_API_KEY\r\n  }),\r\n\r\n  xai: createOpenAI({\r\n    apiKey: process.env.XAI_API_KEY,\r\n    baseURL: \"https://api.x.ai/v1\"\r\n  }),\r\n\r\n  groq: createOpenAI({\r\n    apiKey: process.env.GROQ_API_KEY,\r\n    baseURL: \"https://api.groq.com/openai/v1\"\r\n  })\r\n}\r\n\r\n// Model registry\r\nexport const models = {\r\n  openai: {\r\n    \"gpt-5\": providers.openai(\"gpt-5\"),\r\n    \"gpt-5-mini\": providers.openai(\"gpt-5-mini\")\r\n  },\r\n  anthropic: {\r\n    \"claude-sonnet-4-5\": providers.anthropic(\"claude-sonnet-4-5\"),\r\n    \"claude-haiku-4-5\": providers.anthropic(\"claude-haiku-4-5\")\r\n  },\r\n  google: {\r\n    \"gemini-2.5-pro\": providers.google(\"gemini-2.5-pro\"),\r\n    \"gemini-2.5-flash\": providers.google(\"gemini-2.5-flash\")\r\n  }\r\n}\r\n\r\n// Helper to get model\r\nexport function getModel(provider: AIProvider, modelName: string) {\r\n  const providerModels = models[provider]\r\n  if (!providerModels || !providerModels[modelName]) {\r\n    throw new Error(`Model ${modelName} not found for provider ${provider}`)\r\n  }\r\n  return providerModels[modelName]\r\n}\r\n```\r\n\r\n### Usage Example\r\n\r\n```typescript\r\nimport { streamText } from \"ai\"\r\nimport { getModel } from \"@/lib/ai/providers\"\r\n\r\n// In your API route\r\nexport async function POST(req: Request) {\r\n  const { messages, provider, model } = await req.json()\r\n\r\n  const selectedModel = getModel(provider, model)\r\n\r\n  const result = await streamText({\r\n    model: selectedModel,\r\n    messages\r\n  })\r\n\r\n  return result.toDataStreamResponse()\r\n}\r\n```\r\n\r\n**When to use**:\r\n- Multi-provider support needed\r\n- User choice of AI model\r\n- Fallback between providers\r\n\r\n---",
    "Pattern 4: State Management (Zustand)": "### The Problem\r\nManaging complex nested state (workflows, UI config) without mutations\r\n\r\n### The Solution: Shallow Update Pattern\r\n\r\nCreate `app/store/workflow.ts`:\r\n\r\n```typescript\r\nimport { create } from \"zustand\"\r\n\r\ntype WorkflowNode = {\r\n  id: string\r\n  status: \"pending\" | \"running\" | \"complete\" | \"error\"\r\n  data: any\r\n}\r\n\r\ntype WorkflowStore = {\r\n  workflow: {\r\n    id: string\r\n    nodes: WorkflowNode[]\r\n  } | null\r\n  updateNodeStatus: (nodeId: string, status: WorkflowNode[\"status\"]) => void\r\n  updateNodeData: (nodeId: string, data: any) => void\r\n}\r\n\r\nexport const useWorkflowStore = create<WorkflowStore>((set) => ({\r\n  workflow: null,\r\n\r\n  // Shallow update pattern - no deep mutation\r\n  updateNodeStatus: (nodeId, status) =>\r\n    set(state => ({\r\n      workflow: state.workflow ? {\r\n        ...state.workflow,\r\n        nodes: state.workflow.nodes.map(node =>\r\n          node.id === nodeId ? { ...node, status } : node\r\n        )\r\n      } : null\r\n    })),\r\n\r\n  updateNodeData: (nodeId, data) =>\r\n    set(state => ({\r\n      workflow: state.workflow ? {\r\n        ...state.workflow,\r\n        nodes: state.workflow.nodes.map(node =>\r\n          node.id === nodeId ? { ...node, data: { ...node.data, ...data } } : node\r\n        )\r\n      } : null\r\n    }))\r\n}))\r\n```\r\n\r\n**When to use**:\r\n- Complex nested state\r\n- Frequent updates without mutations\r\n- Avoiding re-render issues\r\n\r\n---",
    "Pattern 1: Server Action Validators": "### The Problem\r\nManual server action auth and validation leads to:\r\n- Inconsistent auth checks\r\n- Repeated FormData parsing boilerplate\r\n- Non-standard error handling\r\n- Type safety issues\r\n\r\n### The Solution: Validated Action Utilities\r\n\r\nCreate `lib/action-utils.ts`:\r\n\r\n```typescript\r\nimport { z } from \"zod\"\r\n\r\n// Type for action result\r\ntype ActionResult<T> =\r\n  | { success: true; data: T }\r\n  | { success: false; error: string }\r\n\r\n// Pattern 1: Simple validation (no auth)\r\nexport function validatedAction<TSchema extends z.ZodType>(\r\n  schema: TSchema,\r\n  handler: (\r\n    data: z.infer<TSchema>,\r\n    formData: FormData\r\n  ) => Promise<ActionResult<any>>\r\n) {\r\n  return async (formData: FormData): Promise<ActionResult<any>> => {\r\n    try {\r\n      const rawData = Object.fromEntries(formData.entries())\r\n      const parsed = schema.safeParse(rawData)\r\n\r\n      if (!parsed.success) {\r\n        return { success: false, error: parsed.error.errors[0].message }\r\n      }\r\n\r\n      return await handler(parsed.data, formData)\r\n    } catch (error) {\r\n      return { success: false, error: String(error) }\r\n    }\r\n  }\r\n}\r\n\r\n// Pattern 2: With user context (adapt getUser() to your auth system)\r\nexport function validatedActionWithUser<TSchema extends z.ZodType>(\r\n  schema: TSchema,\r\n  handler: (\r\n    data: z.infer<TSchema>,\r\n    formData: FormData,\r\n    user: { id: string; email: string } // Adapt to your User type\r\n  ) => Promise<ActionResult<any>>\r\n) {\r\n  return async (formData: FormData): Promise<ActionResult<any>> => {\r\n    try {\r\n      // Adapt this to your auth system (Better Auth, Clerk, Auth.js, etc.)\r\n      const user = await getUser()\r\n      if (!user) {\r\n        return { success: false, error: \"Unauthorized\" }\r\n      }\r\n\r\n      const rawData = Object.fromEntries(formData.entries())\r\n      const parsed = schema.safeParse(rawData)\r\n\r\n      if (!parsed.success) {\r\n        return { success: false, error: parsed.error.errors[0].message }\r\n      }\r\n\r\n      return await handler(parsed.data, formData, user)\r\n    } catch (error) {\r\n      return { success: false, error: String(error) }\r\n    }\r\n  }\r\n}\r\n\r\n// Pattern 3: With permission check (adapt to your roles system)\r\nexport function validatedActionWithPermission<TSchema extends z.ZodType>(\r\n  schema: TSchema,\r\n  permission: \"admin\" | \"user-manage\" | string, // Your permission types\r\n  handler: (\r\n    data: z.infer<TSchema>,\r\n    formData: FormData,\r\n    user: { id: string; email: string; role: string }\r\n  ) => Promise<ActionResult<any>>\r\n) {\r\n  return async (formData: FormData): Promise<ActionResult<any>> => {\r\n    try {\r\n      const user = await getUser()\r\n      if (!user) {\r\n        return { success: false, error: \"Unauthorized\" }\r\n      }\r\n\r\n      // Adapt this to your permission system\r\n      const hasPermission = await checkPermission(user, permission)\r\n      if (!hasPermission) {\r\n        return { success: false, error: \"Forbidden\" }\r\n      }\r\n\r\n      const rawData = Object.fromEntries(formData.entries())\r\n      const parsed = schema.safeParse(rawData)\r\n\r\n      if (!parsed.success) {\r\n        return { success: false, error: parsed.error.errors[0].message }\r\n      }\r\n\r\n      return await handler(parsed.data, formData, user)\r\n    } catch (error) {\r\n      return { success: false, error: String(error) }\r\n    }\r\n  }\r\n}\r\n\r\n// Placeholder functions - replace with your auth system\r\nasync function getUser() {\r\n  // Better Auth: await auth()\r\n  // Clerk: const { userId } = auth(); if (!userId) return null; return await currentUser()\r\n  // Auth.js: const session = await getServerSession(); return session?.user\r\n  throw new Error(\"Implement getUser() with your auth provider\")\r\n}\r\n\r\nasync function checkPermission(user: any, permission: string) {\r\n  // Implement based on your role system\r\n  throw new Error(\"Implement checkPermission() with your role system\")\r\n}\r\n```\r\n\r\n### Usage Example\r\n\r\n```typescript\r\n// app/actions/profile.ts\r\n\"use server\"\r\n\r\nimport { validatedActionWithUser } from \"@/lib/action-utils\"\r\nimport { z } from \"zod\"\r\nimport { db } from \"@/lib/db\"\r\n\r\nconst updateProfileSchema = z.object({\r\n  name: z.string().min(1),\r\n  email: z.string().email()\r\n})\r\n\r\nexport const updateProfile = validatedActionWithUser(\r\n  updateProfileSchema,\r\n  async (data, formData, user) => {\r\n    // user is guaranteed authenticated\r\n    // data is validated and typed\r\n    await db.update(users).set(data).where(eq(users.id, user.id))\r\n    return { success: true, data: { updated: true } }\r\n  }\r\n)\r\n```\r\n\r\n**When to use**:\r\n- Any server action requiring auth\r\n- Form submissions needing validation\r\n- Preventing inconsistent error handling\r\n\r\n---",
    "Overview": "This skill extracts reusable patterns from the better-chatbot project for use in custom AI chatbot implementations. Unlike the `better-chatbot` skill (which teaches project conventions), this skill provides **portable templates** you can adapt to any project.\r\n\r\n**Patterns included**:\r\n1. Server action validators (auth, validation, FormData)\r\n2. Tool abstraction system (multi-type tool handling)\r\n3. Multi-AI provider setup\r\n4. Workflow execution patterns\r\n5. State management conventions\r\n\r\n---",
    "Pattern 5: Cross-Field Validation (Zod)": "### The Problem\r\nValidating related fields (password confirmation, date ranges, etc.)\r\n\r\n### The Solution: Zod superRefine\r\n\r\n```typescript\r\nimport { z } from \"zod\"\r\n\r\n// Password match validation\r\nconst passwordSchema = z.object({\r\n  password: z.string().min(8),\r\n  confirmPassword: z.string()\r\n}).superRefine((data, ctx) => {\r\n  if (data.password !== data.confirmPassword) {\r\n    ctx.addIssue({\r\n      path: [\"confirmPassword\"],\r\n      code: z.ZodIssueCode.custom,\r\n      message: \"Passwords must match\"\r\n    })\r\n  }\r\n})\r\n\r\n// Date range validation\r\nconst dateRangeSchema = z.object({\r\n  startDate: z.string().datetime(),\r\n  endDate: z.string().datetime()\r\n}).superRefine((data, ctx) => {\r\n  if (new Date(data.endDate) < new Date(data.startDate)) {\r\n    ctx.addIssue({\r\n      path: [\"endDate\"],\r\n      code: z.ZodIssueCode.custom,\r\n      message: \"End date must be after start date\"\r\n    })\r\n  }\r\n})\r\n\r\n// Conditional required fields\r\nconst conditionalSchema = z.object({\r\n  type: z.enum([\"email\", \"sms\"]),\r\n  email: z.string().email().optional(),\r\n  phone: z.string().optional()\r\n}).superRefine((data, ctx) => {\r\n  if (data.type === \"email\" && !data.email) {\r\n    ctx.addIssue({\r\n      path: [\"email\"],\r\n      code: z.ZodIssueCode.custom,\r\n      message: \"Email is required when type is 'email'\"\r\n    })\r\n  }\r\n  if (data.type === \"sms\" && !data.phone) {\r\n    ctx.addIssue({\r\n      path: [\"phone\"],\r\n      code: z.ZodIssueCode.custom,\r\n      message: \"Phone is required when type is 'sms'\"\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n**When to use**:\r\n- Password confirmation\r\n- Date range validation\r\n- Conditional required fields\r\n- Cross-field business rules\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ Adapt patterns to your auth system (Better Auth, Clerk, Auth.js, etc.)\r\n✅ Use branded type tags for runtime type checking\r\n✅ Use shallow updates for nested Zustand state\r\n✅ Use Zod `superRefine` for cross-field validation\r\n✅ Type your tool abstractions properly\r\n\r\n### Never Do\r\n\r\n❌ Copy code without adapting to your auth/role system\r\n❌ Assume tool type without runtime check\r\n❌ Mutate Zustand state directly\r\n❌ Use separate validators for related fields\r\n❌ Skip type branding for extensible systems\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- zod@3.24.2 - Validation (all patterns)\r\n- zustand@5.0.3 - State management (Pattern 4)\r\n- ai@5.0.82 - Vercel AI SDK (Pattern 3)\r\n\r\n**Optional** (based on patterns used):\r\n- @ai-sdk/openai - OpenAI provider\r\n- @ai-sdk/anthropic - Anthropic provider\r\n- @ai-sdk/google - Google provider\r\n\r\n---",
    "Pattern 2: Tool Abstraction System": "### The Problem\r\nHandling multiple tool types (MCP, Workflow, Default) with different execution patterns leads to:\r\n- Type mismatches at runtime\r\n- Repeated type checking boilerplate\r\n- Difficulty adding new tool types\r\n\r\n### The Solution: Branded Type Tags\r\n\r\nCreate `lib/tool-tags.ts`:\r\n\r\n```typescript\r\n// Branded type system for runtime type narrowing\r\nexport class ToolTag<T extends string> {\r\n  private readonly _tag: T\r\n  private readonly _branded: unique symbol\r\n\r\n  private constructor(tag: T) {\r\n    this._tag = tag\r\n  }\r\n\r\n  static create<TTag extends string>(tag: TTag) {\r\n    return new ToolTag(tag) as ToolTag<TTag>\r\n  }\r\n\r\n  is(tag: string): boolean {\r\n    return this._tag === tag\r\n  }\r\n\r\n  get tag(): T {\r\n    return this._tag\r\n  }\r\n}\r\n\r\n// Define your tool types\r\nexport type MCPTool = { type: \"mcp\"; name: string; execute: (...args: any[]) => Promise<any> }\r\nexport type WorkflowTool = { type: \"workflow\"; id: string; nodes: any[] }\r\nexport type DefaultTool = { type: \"default\"; name: string }\r\n\r\n// Branded tag system\r\nexport const VercelAIMcpToolTag = {\r\n  create: (tool: any) => ({ ...tool, _tag: ToolTag.create(\"mcp\") }),\r\n  isMaybe: (tool: any): tool is MCPTool & { _tag: ToolTag<\"mcp\"> } =>\r\n    tool?._tag?.is(\"mcp\")\r\n}\r\n\r\nexport const VercelAIWorkflowToolTag = {\r\n  create: (tool: any) => ({ ...tool, _tag: ToolTag.create(\"workflow\") }),\r\n  isMaybe: (tool: any): tool is WorkflowTool & { _tag: ToolTag<\"workflow\"> } =>\r\n    tool?._tag?.is(\"workflow\")\r\n}\r\n\r\nexport const VercelAIDefaultToolTag = {\r\n  create: (tool: any) => ({ ...tool, _tag: ToolTag.create(\"default\") }),\r\n  isMaybe: (tool: any): tool is DefaultTool & { _tag: ToolTag<\"default\"> } =>\r\n    tool?._tag?.is(\"default\")\r\n}\r\n```\r\n\r\n### Usage Example\r\n\r\n```typescript\r\n// lib/ai/tool-executor.ts\r\nimport {\r\n  VercelAIMcpToolTag,\r\n  VercelAIWorkflowToolTag,\r\n  VercelAIDefaultToolTag\r\n} from \"@/lib/tool-tags\"\r\n\r\nasync function executeTool(tool: unknown) {\r\n  // Runtime type narrowing with branded tags\r\n  if (VercelAIMcpToolTag.isMaybe(tool)) {\r\n    console.log(\"Executing MCP tool:\", tool.name)\r\n    return await tool.execute()\r\n  } else if (VercelAIWorkflowToolTag.isMaybe(tool)) {\r\n    console.log(\"Executing workflow:\", tool.id)\r\n    return await executeWorkflow(tool.nodes)\r\n  } else if (VercelAIDefaultToolTag.isMaybe(tool)) {\r\n    console.log(\"Executing default tool:\", tool.name)\r\n    return await executeDefault(tool)\r\n  }\r\n\r\n  throw new Error(\"Unknown tool type\")\r\n}\r\n\r\n// When creating tools, tag them\r\nconst mcpTool = VercelAIMcpToolTag.create({\r\n  type: \"mcp\",\r\n  name: \"search\",\r\n  execute: async () => { /* ... */ }\r\n})\r\n\r\nconst workflowTool = VercelAIWorkflowToolTag.create({\r\n  type: \"workflow\",\r\n  id: \"workflow-123\",\r\n  nodes: []\r\n})\r\n```\r\n\r\n**When to use**:\r\n- Multi-type tool systems\r\n- Runtime type checking needed\r\n- Adding extensible tool types\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **5** common issues:\r\n\r\n### Issue #1: Inconsistent Auth Checks\r\n**Prevention**: Use `validatedActionWithUser` pattern (adapt to your auth)\r\n\r\n### Issue #2: Tool Type Mismatches\r\n**Prevention**: Use branded type tags with `.isMaybe()` checks\r\n\r\n### Issue #3: State Mutation Bugs\r\n**Prevention**: Use shallow Zustand update pattern\r\n\r\n### Issue #4: Cross-Field Validation Failures\r\n**Prevention**: Use Zod `superRefine` for related fields\r\n\r\n### Issue #5: Provider Configuration Errors\r\n**Prevention**: Use provider registry with unified interface\r\n\r\n---",
    "Using Bundled Resources": "### Templates (templates/)\r\n\r\n- `templates/action-utils.ts` - Complete server action validators\r\n- `templates/tool-tags.ts` - Complete tool abstraction system\r\n- `templates/providers.ts` - Multi-AI provider setup\r\n- `templates/workflow-store.ts` - Zustand workflow store\r\n\r\n**Copy to your project** and adapt placeholders (`getUser()`, `checkPermission()`, etc.)\r\n\r\n---",
    "Official Documentation": "- **Vercel AI SDK**: https://sdk.vercel.ai/docs\r\n- **Zod**: https://zod.dev\r\n- **Zustand**: https://zustand-demo.pmnd.rs\r\n- **better-chatbot** (source): https://github.com/cgoinglove/better-chatbot\r\n\r\n---"
  }
}