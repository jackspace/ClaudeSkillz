{
  "description": "Process-based discrete-event simulation framework in Python. Use this skill when building simulations of systems with processes, queues, resources, and time-based events such as manufacturing systems, service operations, network traffic, logistics, or any system where entities interact with shared resources over time.",
  "references": {
    "files": [
      "references/events.md",
      "references/monitoring.md",
      "references/process-interaction.md",
      "references/real-time.md",
      "references/resources.md"
    ]
  },
  "content": "### Basic Simulation Structure\r\n\r\n```python\r\nimport simpy\r\n\r\ndef process(env, name):\r\n    \"\"\"A simple process that waits and prints.\"\"\"\r\n    print(f'{name} starting at {env.now}')\r\n    yield env.timeout(5)\r\n    print(f'{name} finishing at {env.now}')\r\n\r\nenv = simpy.Environment()\r\n\r\nenv.process(process(env, 'Process 1'))\r\nenv.process(process(env, 'Process 2'))\r\n\r\n\r\n### 1. Environment\r\n\r\nThe simulation environment manages time and schedules events.\r\n\r\n```python\r\nimport simpy\r\n\r\nenv = simpy.Environment(initial_time=0)\r\n\r\nimport simpy.rt\r\nenv_rt = simpy.rt.RealtimeEnvironment(factor=1.0)\r\n\r\nenv.run(until=100)  # Run until time 100\r\nenv.run()  # Run until no events remain\r\n```\r\n\r\n### 2. Processes\r\n\r\nProcesses are defined using Python generator functions (functions with `yield` statements).\r\n\r\n```python\r\ndef my_process(env, param1, param2):\r\n    \"\"\"Process that yields events to pause execution.\"\"\"\r\n    print(f'Starting at {env.now}')\r\n\r\n    # Wait for time to pass\r\n    yield env.timeout(5)\r\n\r\n    print(f'Resumed at {env.now}')\r\n\r\n    # Wait for another event\r\n    yield env.timeout(3)\r\n\r\n    print(f'Done at {env.now}')\r\n    return 'result'\r\n\r\n\r\nSimPy provides several resource types for different scenarios. For comprehensive details, see `references/resources.md`.\r\n\r\n### Resource Types Summary\r\n\r\n| Resource Type | Use Case |\r\n|---------------|----------|\r\n| Resource | Limited capacity (servers, machines) |\r\n| PriorityResource | Priority-based queuing |\r\n| PreemptiveResource | High-priority can interrupt low-priority |\r\n| Container | Bulk materials (fuel, water) |\r\n| Store | Python object storage (FIFO) |\r\n| FilterStore | Selective item retrieval |\r\n| PriorityStore | Priority-ordered items |\r\n\r\n### Quick Reference\r\n\r\n```python\r\nimport simpy\r\n\r\nenv = simpy.Environment()\r\n\r\nresource = simpy.Resource(env, capacity=2)\r\n\r\npriority_resource = simpy.PriorityResource(env, capacity=1)\r\n\r\nfuel_tank = simpy.Container(env, capacity=100, init=50)\r\n\r\n\r\n### Step 1: Define the System\r\n\r\nIdentify:\r\n- **Entities**: What moves through the system? (customers, parts, packets)\r\n- **Resources**: What are the constraints? (servers, machines, bandwidth)\r\n- **Processes**: What are the activities? (arrival, service, departure)\r\n- **Metrics**: What to measure? (wait times, utilization, throughput)\r\n\r\n### Step 2: Implement Process Functions\r\n\r\nCreate generator functions for each process type:\r\n\r\n```python\r\ndef entity_process(env, name, resources, parameters):\r\n    # Arrival logic\r\n    arrival_time = env.now\r\n\r\n    # Request resources\r\n    with resource.request() as req:\r\n        yield req\r\n\r\n        # Service logic\r\n        service_time = calculate_service_time(parameters)\r\n        yield env.timeout(service_time)\r\n\r\n    # Departure logic\r\n    collect_statistics(env.now - arrival_time)\r\n```\r\n\r\n### Step 3: Set Up Monitoring\r\n\r\nUse monitoring utilities to collect data. See `references/monitoring.md` for comprehensive techniques.\r\n\r\n```python\r\nfrom scripts.resource_monitor import ResourceMonitor\r\n\r\nresource = simpy.Resource(env, capacity=2)\r\nmonitor = ResourceMonitor(env, resource, \"Server\")\r\n\r\nmonitor.report()\r\n```\r\n\r\n### Step 4: Run and Analyze\r\n\r\n```python\r\nenv.run(until=simulation_time)\r\n\r\nmonitor.report()\r\nstats.report()\r\n\r\n\r\n### Process Interaction\r\n\r\nProcesses can interact through events, process yields, and interrupts. See `references/process-interaction.md` for detailed patterns.\r\n\r\n**Key mechanisms:**\r\n- **Event signaling**: Shared events for coordination\r\n- **Process yields**: Wait for other processes to complete\r\n- **Interrupts**: Forcefully resume processes for preemption\r\n\r\n### Real-Time Simulations\r\n\r\nSynchronize simulation with wall-clock time for hardware-in-the-loop or interactive applications. See `references/real-time.md`.\r\n\r\n```python\r\nimport simpy.rt\r\n\r\nenv = simpy.rt.RealtimeEnvironment(factor=1.0)  # 1:1 time mapping\r\n\r\n### basic_simulation_template.py\r\n\r\nComplete template for building queue simulations with:\r\n- Configurable parameters\r\n- Statistics collection\r\n- Customer generation\r\n- Resource usage\r\n- Report generation\r\n\r\n**Usage:**\r\n```python\r\nfrom scripts.basic_simulation_template import SimulationConfig, run_simulation\r\n\r\nconfig = SimulationConfig()\r\nconfig.num_resources = 2\r\nconfig.sim_time = 100\r\nstats = run_simulation(config)\r\nstats.report()\r\n```\r\n\r\n### resource_monitor.py\r\n\r\nReusable monitoring utilities:\r\n- `ResourceMonitor` - Track single resource\r\n- `MultiResourceMonitor` - Monitor multiple resources\r\n- `ContainerMonitor` - Track container levels\r\n- Automatic statistics calculation\r\n- CSV export functionality\r\n\r\n**Usage:**\r\n```python\r\nfrom scripts.resource_monitor import ResourceMonitor\r\n\r\nmonitor = ResourceMonitor(env, resource, \"My Resource\")",
  "name": "simpy",
  "id": "scientific-pkg-simpy",
  "sections": {
    "Overview": "SimPy is a process-based discrete-event simulation framework based on standard Python. Use SimPy to model systems where entities (customers, vehicles, packets, etc.) interact with each other and compete for shared resources (servers, machines, bandwidth, etc.) over time.\r\n\r\n**Core capabilities:**\r\n- Process modeling using Python generator functions\r\n- Shared resource management (servers, containers, stores)\r\n- Event-driven scheduling and synchronization\r\n- Real-time simulations synchronized with wall-clock time\r\n- Comprehensive monitoring and data collection",
    "Advanced Features": "```\r\n\r\n### Comprehensive Monitoring\r\n\r\nMonitor processes, resources, and events. See `references/monitoring.md` for techniques including:\r\n- State variable tracking\r\n- Resource monkey-patching\r\n- Event tracing\r\n- Statistical collection",
    "Reference Documentation": "Detailed guides for specific topics:\r\n\r\n- **`references/resources.md`** - All resource types with examples\r\n- **`references/events.md`** - Event system and patterns\r\n- **`references/process-interaction.md`** - Process synchronization\r\n- **`references/monitoring.md`** - Data collection techniques\r\n- **`references/real-time.md`** - Real-time simulation setup",
    "Common Simulation Patterns": "### Pattern 1: Customer-Server Queue\r\n\r\n```python\r\nimport simpy\r\nimport random\r\n\r\ndef customer(env, name, server):\r\n    arrival = env.now\r\n    with server.request() as req:\r\n        yield req\r\n        wait = env.now - arrival\r\n        print(f'{name} waited {wait:.2f}, served at {env.now}')\r\n        yield env.timeout(random.uniform(2, 4))\r\n\r\ndef customer_generator(env, server):\r\n    i = 0\r\n    while True:\r\n        yield env.timeout(random.uniform(1, 3))\r\n        i += 1\r\n        env.process(customer(env, f'Customer {i}', server))\r\n\r\nenv = simpy.Environment()\r\nserver = simpy.Resource(env, capacity=2)\r\nenv.process(customer_generator(env, server))\r\nenv.run(until=20)\r\n```\r\n\r\n### Pattern 2: Producer-Consumer\r\n\r\n```python\r\nimport simpy\r\n\r\ndef producer(env, store):\r\n    item_id = 0\r\n    while True:\r\n        yield env.timeout(2)\r\n        item = f'Item {item_id}'\r\n        yield store.put(item)\r\n        print(f'Produced {item} at {env.now}')\r\n        item_id += 1\r\n\r\ndef consumer(env, store):\r\n    while True:\r\n        item = yield store.get()\r\n        print(f'Consumed {item} at {env.now}')\r\n        yield env.timeout(3)\r\n\r\nenv = simpy.Environment()\r\nstore = simpy.Store(env, capacity=10)\r\nenv.process(producer(env, store))\r\nenv.process(consumer(env, store))\r\nenv.run(until=20)\r\n```\r\n\r\n### Pattern 3: Parallel Task Execution\r\n\r\n```python\r\nimport simpy\r\n\r\ndef task(env, name, duration):\r\n    print(f'{name} starting at {env.now}')\r\n    yield env.timeout(duration)\r\n    print(f'{name} done at {env.now}')\r\n    return f'{name} result'\r\n\r\ndef coordinator(env):\r\n    # Start tasks in parallel\r\n    task1 = env.process(task(env, 'Task 1', 5))\r\n    task2 = env.process(task(env, 'Task 2', 3))\r\n    task3 = env.process(task(env, 'Task 3', 4))\r\n\r\n    # Wait for all to complete\r\n    results = yield task1 & task2 & task3\r\n    print(f'All done at {env.now}')\r\n\r\nenv = simpy.Environment()\r\nenv.process(coordinator(env))\r\nenv.run()\r\n```",
    "Scripts and Templates": "monitor.report()\r\nmonitor.export_csv('data.csv')\r\n```",
    "Core Concepts": "env.process(my_process(env, 'value1', 'value2'))\r\n```\r\n\r\n### 3. Events\r\n\r\nEvents are the fundamental mechanism for process synchronization. Processes yield events and resume when those events are triggered.\r\n\r\n**Common event types:**\r\n- `env.timeout(delay)` - Wait for time to pass\r\n- `resource.request()` - Request a resource\r\n- `env.event()` - Create a custom event\r\n- `env.process(func())` - Process as an event\r\n- `event1 & event2` - Wait for all events (AllOf)\r\n- `event1 | event2` - Wait for any event (AnyOf)",
    "Best Practices": "1. **Generator functions**: Always use `yield` in process functions\r\n2. **Resource context managers**: Use `with resource.request() as req:` for automatic cleanup\r\n3. **Reproducibility**: Set `random.seed()` for consistent results\r\n4. **Monitoring**: Collect data throughout simulation, not just at the end\r\n5. **Validation**: Compare simple cases with analytical solutions\r\n6. **Documentation**: Comment process logic and parameter choices\r\n7. **Modular design**: Separate process logic, statistics, and configuration",
    "Example Use Cases": "- **Manufacturing**: Machine scheduling, production lines, inventory management\r\n- **Healthcare**: Emergency room simulation, patient flow, staff allocation\r\n- **Telecommunications**: Network traffic, packet routing, bandwidth allocation\r\n- **Transportation**: Traffic flow, logistics, vehicle routing\r\n- **Service operations**: Call centers, retail checkout, appointment scheduling\r\n- **Computer systems**: CPU scheduling, memory management, I/O operations",
    "When to Use This Skill": "Use the SimPy skill when:\r\n\r\n1. **Modeling discrete-event systems** - Systems where events occur at irregular intervals\r\n2. **Resource contention** - Entities compete for limited resources (servers, machines, staff)\r\n3. **Queue analysis** - Studying waiting lines, service times, and throughput\r\n4. **Process optimization** - Analyzing manufacturing, logistics, or service processes\r\n5. **Network simulation** - Packet routing, bandwidth allocation, latency analysis\r\n6. **Capacity planning** - Determining optimal resource levels for desired performance\r\n7. **System validation** - Testing system behavior before implementation\r\n\r\n**Not suitable for:**\r\n- Continuous simulations with fixed time steps (consider SciPy ODE solvers)\r\n- Independent processes without resource sharing\r\n- Pure mathematical optimization (consider SciPy optimize)",
    "Resources": "warehouse = simpy.Store(env, capacity=10)\r\n```",
    "Common Pitfalls": "1. **Forgetting yield**: Processes must yield events to pause\r\n2. **Event reuse**: Events can only be triggered once\r\n3. **Resource leaks**: Use context managers or ensure release\r\n4. **Blocking operations**: Avoid Python blocking calls in processes\r\n5. **Time units**: Stay consistent with time unit interpretation\r\n6. **Deadlocks**: Ensure at least one process can make progress",
    "Workflow Guide": "monitor.export_csv('results.csv')\r\n```",
    "Quick Start": "env.run(until=10)\r\n```\r\n\r\n### Resource Usage Pattern\r\n\r\n```python\r\nimport simpy\r\n\r\ndef customer(env, name, resource):\r\n    \"\"\"Customer requests resource, uses it, then releases.\"\"\"\r\n    with resource.request() as req:\r\n        yield req  # Wait for resource\r\n        print(f'{name} got resource at {env.now}')\r\n        yield env.timeout(3)  # Use resource\r\n        print(f'{name} released resource at {env.now}')\r\n\r\nenv = simpy.Environment()\r\nserver = simpy.Resource(env, capacity=1)\r\n\r\nenv.process(customer(env, 'Customer 1', server))\r\nenv.process(customer(env, 'Customer 2', server))\r\nenv.run()\r\n```"
  }
}