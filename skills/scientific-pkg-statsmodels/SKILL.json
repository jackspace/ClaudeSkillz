{
  "description": "\"Statistical modeling toolkit. OLS, GLM, logistic, ARIMA, time series, hypothesis tests, diagnostics, AIC/BIC, for rigorous statistical inference and econometric analysis.\"",
  "references": {
    "files": [
      "references/discrete_choice.md",
      "references/glm.md",
      "references/linear_models.md",
      "references/stats_diagnostics.md",
      "references/time_series.md"
    ]
  },
  "content": "### Linear Regression (OLS)\r\n\r\n```python\r\nimport statsmodels.api as sm\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\nX = sm.add_constant(X_data)\r\n\r\nmodel = sm.OLS(y, X)\r\nresults = model.fit()\r\n\r\nprint(results.summary())\r\n\r\nprint(f\"R-squared: {results.rsquared:.4f}\")\r\nprint(f\"Coefficients:\\\\n{results.params}\")\r\nprint(f\"P-values:\\\\n{results.pvalues}\")\r\n\r\npredictions = results.get_prediction(X_new)\r\npred_summary = predictions.summary_frame()\r\nprint(pred_summary)  # includes mean, CI, prediction intervals\r\n\r\nfrom statsmodels.stats.diagnostic import het_breuschpagan\r\nbp_test = het_breuschpagan(results.resid, X)\r\nprint(f\"Breusch-Pagan p-value: {bp_test[1]:.4f}\")\r\n\r\nimport matplotlib.pyplot as plt\r\nplt.scatter(results.fittedvalues, results.resid)\r\nplt.axhline(y=0, color='r', linestyle='--')\r\nplt.xlabel('Fitted values')\r\nplt.ylabel('Residuals')\r\nplt.show()\r\n```\r\n\r\n### Logistic Regression (Binary Outcomes)\r\n\r\n```python\r\nfrom statsmodels.discrete.discrete_model import Logit\r\n\r\nX = sm.add_constant(X_data)\r\n\r\nmodel = Logit(y_binary, X)\r\nresults = model.fit()\r\n\r\nprint(results.summary())\r\n\r\nodds_ratios = np.exp(results.params)\r\nprint(\"Odds ratios:\\\\n\", odds_ratios)\r\n\r\nprobs = results.predict(X)\r\n\r\npredictions = (probs > 0.5).astype(int)\r\n\r\nfrom sklearn.metrics import classification_report, roc_auc_score\r\n\r\nprint(classification_report(y_binary, predictions))\r\nprint(f\"AUC: {roc_auc_score(y_binary, probs):.4f}\")\r\n\r\nmarginal = results.get_margeff()\r\nprint(marginal.summary())\r\n```\r\n\r\n### Time Series (ARIMA)\r\n\r\n```python\r\nfrom statsmodels.tsa.arima.model import ARIMA\r\nfrom statsmodels.graphics.tsaplots import plot_acf, plot_pacf\r\n\r\nfrom statsmodels.tsa.stattools import adfuller\r\n\r\nadf_result = adfuller(y_series)\r\nprint(f\"ADF p-value: {adf_result[1]:.4f}\")\r\n\r\nif adf_result[1] > 0.05:\r\n    # Series is non-stationary, difference it\r\n    y_diff = y_series.diff().dropna()\r\n\r\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))\r\nplot_acf(y_diff, lags=40, ax=ax1)\r\nplot_pacf(y_diff, lags=40, ax=ax2)\r\nplt.show()\r\n\r\nmodel = ARIMA(y_series, order=(1, 1, 1))\r\nresults = model.fit()\r\n\r\nprint(results.summary())\r\n\r\nforecast = results.forecast(steps=10)\r\nforecast_obj = results.get_forecast(steps=10)\r\nforecast_df = forecast_obj.summary_frame()\r\n\r\nprint(forecast_df)  # includes mean and confidence intervals\r\n\r\nresults.plot_diagnostics(figsize=(12, 8))\r\nplt.show()\r\n```\r\n\r\n### Generalized Linear Models (GLM)\r\n\r\n```python\r\nimport statsmodels.api as sm\r\n\r\nX = sm.add_constant(X_data)\r\nmodel = sm.GLM(y_counts, X, family=sm.families.Poisson())\r\nresults = model.fit()\r\n\r\nprint(results.summary())\r\n\r\nrate_ratios = np.exp(results.params)\r\nprint(\"Rate ratios:\\\\n\", rate_ratios)\r\n\r\n\r\nStatsmodels supports R-style formulas for intuitive model specification:\r\n\r\n```python\r\nimport statsmodels.formula.api as smf\r\n\r\nresults = smf.ols('y ~ x1 + x2 + x1:x2', data=df).fit()\r\n\r\nresults = smf.ols('y ~ x1 + C(category)', data=df).fit()\r\n\r\nresults = smf.ols('y ~ x1 * x2', data=df).fit()  # x1 + x2 + x1:x2\r\n\r\nresults = smf.ols('y ~ x + I(x**2)', data=df).fit()\r\n\r\nresults = smf.logit('y ~ x1 + x2 + C(group)', data=df).fit()\r\n\r\nresults = smf.poisson('count ~ x1 + x2', data=df).fit()\r\n\r\n\r\n### Information Criteria\r\n\r\n```python\r\nmodels = {\r\n    'Model 1': model1_results,\r\n    'Model 2': model2_results,\r\n    'Model 3': model3_results\r\n}\r\n\r\ncomparison = pd.DataFrame({\r\n    'AIC': {name: res.aic for name, res in models.items()},\r\n    'BIC': {name: res.bic for name, res in models.items()},\r\n    'Log-Likelihood': {name: res.llf for name, res in models.items()}\r\n})\r\n\r\nprint(comparison.sort_values('AIC'))\r\n```\r\n\r\n### Likelihood Ratio Test (Nested Models)\r\n\r\n```python\r\n\r\nThis skill includes comprehensive reference files for detailed guidance:\r\n\r\n### references/linear_models.md\r\nDetailed coverage of linear regression models including:\r\n- OLS, WLS, GLS, GLSAR, Quantile Regression\r\n- Mixed effects models\r\n- Recursive and rolling regression\r\n- Comprehensive diagnostics (heteroskedasticity, autocorrelation, multicollinearity)\r\n- Influence statistics and outlier detection\r\n- Robust standard errors (HC, HAC, cluster)\r\n- Hypothesis testing and model comparison\r\n\r\n### references/glm.md\r\nComplete guide to generalized linear models:\r\n- All distribution families (Binomial, Poisson, Gamma, etc.)\r\n- Link functions and when to use each\r\n- Model fitting and interpretation\r\n- Pseudo R-squared and goodness of fit\r\n- Diagnostics and residual analysis\r\n- Applications (logistic, Poisson, Gamma regression)\r\n\r\n### references/discrete_choice.md\r\nComprehensive guide to discrete outcome models:\r\n- Binary models (Logit, Probit)\r\n- Multinomial models (MNLogit, Conditional Logit)\r\n- Count models (Poisson, Negative Binomial, Zero-Inflated, Hurdle)\r\n- Ordinal models\r\n- Marginal effects and interpretation\r\n- Model diagnostics and comparison\r\n\r\n### references/time_series.md\r\nIn-depth time series analysis guidance:\r\n- Univariate models (AR, ARIMA, SARIMAX, Exponential Smoothing)\r\n- Multivariate models (VAR, VARMAX, Dynamic Factor)\r\n- State space models\r\n- Stationarity testing and diagnostics\r\n- Forecasting methods and evaluation\r\n- Granger causality, IRF, FEVD\r\n\r\n### references/stats_diagnostics.md\r\nComprehensive statistical testing and diagnostics:\r\n- Residual diagnostics (autocorrelation, heteroskedasticity, normality)\r\n- Influence and outlier detection\r\n- Hypothesis tests (parametric and non-parametric)\r\n- ANOVA and post-hoc tests\r\n- Multiple comparisons correction\r\n- Robust covariance matrices\r\n- Power analysis and effect sizes\r\n\r\n**When to reference:**\r\n- Need detailed parameter explanations\r\n- Choosing between similar models\r\n- Troubleshooting convergence or diagnostic issues\r\n- Understanding specific test statistics\r\n- Looking for code examples for advanced features\r\n\r\n**Search patterns:**\r\n```bash\r\ngrep -r \"Quantile Regression\" references/\r\n\r\ngrep -r \"Breusch-Pagan\" references/stats_diagnostics.md",
  "name": "statsmodels",
  "id": "scientific-pkg-statsmodels",
  "sections": {
    "Reference Documentation": "grep -r \"SARIMAX\" references/time_series.md\r\n```",
    "Quick Start Guide": "overdispersion = results.pearson_chi2 / results.df_resid\r\nprint(f\"Overdispersion: {overdispersion:.2f}\")\r\n\r\nif overdispersion > 1.5:\r\n    # Use Negative Binomial instead\r\n    from statsmodels.discrete.count_model import NegativeBinomial\r\n    nb_model = NegativeBinomial(y_counts, X)\r\n    nb_results = nb_model.fit()\r\n    print(nb_results.summary())\r\n```",
    "Common Pitfalls to Avoid": "1. **Forgetting constant term**: Always use `sm.add_constant()` unless no intercept desired\r\n2. **Ignoring assumptions**: Check residuals, heteroskedasticity, autocorrelation\r\n3. **Wrong model for outcome type**: Binary→Logit/Probit, Count→Poisson/NB, not OLS\r\n4. **Not checking convergence**: Look for optimization warnings\r\n5. **Misinterpreting coefficients**: Remember link functions (log, logit, etc.)\r\n6. **Using Poisson with overdispersion**: Check dispersion, use Negative Binomial if needed\r\n7. **Not using robust SEs**: When heteroskedasticity or clustering present\r\n8. **Overfitting**: Too many parameters relative to sample size\r\n9. **Data leakage**: Fitting on test data or using future information\r\n10. **Not validating predictions**: Always check out-of-sample performance\r\n11. **Comparing non-nested models**: Use AIC/BIC, not LR test\r\n12. **Ignoring influential observations**: Check Cook's distance and leverage\r\n13. **Multiple testing**: Correct p-values when testing many hypotheses\r\n14. **Not differencing time series**: Fit ARIMA on non-stationary data\r\n15. **Confusing prediction vs confidence intervals**: Prediction intervals are wider",
    "Core Statistical Modeling Capabilities": "### 1. Linear Regression Models\r\n\r\nComprehensive suite of linear models for continuous outcomes with various error structures.\r\n\r\n**Available models:**\r\n- **OLS**: Standard linear regression with i.i.d. errors\r\n- **WLS**: Weighted least squares for heteroskedastic errors\r\n- **GLS**: Generalized least squares for arbitrary covariance structure\r\n- **GLSAR**: GLS with autoregressive errors for time series\r\n- **Quantile Regression**: Conditional quantiles (robust to outliers)\r\n- **Mixed Effects**: Hierarchical/multilevel models with random effects\r\n- **Recursive/Rolling**: Time-varying parameter estimation\r\n\r\n**Key features:**\r\n- Comprehensive diagnostic tests\r\n- Robust standard errors (HC, HAC, cluster-robust)\r\n- Influence statistics (Cook's distance, leverage, DFFITS)\r\n- Hypothesis testing (F-tests, Wald tests)\r\n- Model comparison (AIC, BIC, likelihood ratio tests)\r\n- Prediction with confidence and prediction intervals\r\n\r\n**When to use:** Continuous outcome variable, want inference on coefficients, need diagnostics\r\n\r\n**Reference:** See `references/linear_models.md` for detailed guidance on model selection, diagnostics, and best practices.\r\n\r\n### 2. Generalized Linear Models (GLM)\r\n\r\nFlexible framework extending linear models to non-normal distributions.\r\n\r\n**Distribution families:**\r\n- **Binomial**: Binary outcomes or proportions (logistic regression)\r\n- **Poisson**: Count data\r\n- **Negative Binomial**: Overdispersed counts\r\n- **Gamma**: Positive continuous, right-skewed data\r\n- **Inverse Gaussian**: Positive continuous with specific variance structure\r\n- **Gaussian**: Equivalent to OLS\r\n- **Tweedie**: Flexible family for semi-continuous data\r\n\r\n**Link functions:**\r\n- Logit, Probit, Log, Identity, Inverse, Sqrt, CLogLog, Power\r\n- Choose based on interpretation needs and model fit\r\n\r\n**Key features:**\r\n- Maximum likelihood estimation via IRLS\r\n- Deviance and Pearson residuals\r\n- Goodness-of-fit statistics\r\n- Pseudo R-squared measures\r\n- Robust standard errors\r\n\r\n**When to use:** Non-normal outcomes, need flexible variance and link specifications\r\n\r\n**Reference:** See `references/glm.md` for family selection, link functions, interpretation, and diagnostics.\r\n\r\n### 3. Discrete Choice Models\r\n\r\nModels for categorical and count outcomes.\r\n\r\n**Binary models:**\r\n- **Logit**: Logistic regression (odds ratios)\r\n- **Probit**: Probit regression (normal distribution)\r\n\r\n**Multinomial models:**\r\n- **MNLogit**: Unordered categories (3+ levels)\r\n- **Conditional Logit**: Choice models with alternative-specific variables\r\n- **Ordered Model**: Ordinal outcomes (ordered categories)\r\n\r\n**Count models:**\r\n- **Poisson**: Standard count model\r\n- **Negative Binomial**: Overdispersed counts\r\n- **Zero-Inflated**: Excess zeros (ZIP, ZINB)\r\n- **Hurdle Models**: Two-stage models for zero-heavy data\r\n\r\n**Key features:**\r\n- Maximum likelihood estimation\r\n- Marginal effects at means or average marginal effects\r\n- Model comparison via AIC/BIC\r\n- Predicted probabilities and classification\r\n- Goodness-of-fit tests\r\n\r\n**When to use:** Binary, categorical, or count outcomes\r\n\r\n**Reference:** See `references/discrete_choice.md` for model selection, interpretation, and evaluation.\r\n\r\n### 4. Time Series Analysis\r\n\r\nComprehensive time series modeling and forecasting capabilities.\r\n\r\n**Univariate models:**\r\n- **AutoReg (AR)**: Autoregressive models\r\n- **ARIMA**: Autoregressive integrated moving average\r\n- **SARIMAX**: Seasonal ARIMA with exogenous variables\r\n- **Exponential Smoothing**: Simple, Holt, Holt-Winters\r\n- **ETS**: Innovations state space models\r\n\r\n**Multivariate models:**\r\n- **VAR**: Vector autoregression\r\n- **VARMAX**: VAR with MA and exogenous variables\r\n- **Dynamic Factor Models**: Extract common factors\r\n- **VECM**: Vector error correction models (cointegration)\r\n\r\n**Advanced models:**\r\n- **State Space**: Kalman filtering, custom specifications\r\n- **Regime Switching**: Markov switching models\r\n- **ARDL**: Autoregressive distributed lag\r\n\r\n**Key features:**\r\n- ACF/PACF analysis for model identification\r\n- Stationarity tests (ADF, KPSS)\r\n- Forecasting with prediction intervals\r\n- Residual diagnostics (Ljung-Box, heteroskedasticity)\r\n- Granger causality testing\r\n- Impulse response functions (IRF)\r\n- Forecast error variance decomposition (FEVD)\r\n\r\n**When to use:** Time-ordered data, forecasting, understanding temporal dynamics\r\n\r\n**Reference:** See `references/time_series.md` for model selection, diagnostics, and forecasting methods.\r\n\r\n### 5. Statistical Tests and Diagnostics\r\n\r\nExtensive testing and diagnostic capabilities for model validation.\r\n\r\n**Residual diagnostics:**\r\n- Autocorrelation tests (Ljung-Box, Durbin-Watson, Breusch-Godfrey)\r\n- Heteroskedasticity tests (Breusch-Pagan, White, ARCH)\r\n- Normality tests (Jarque-Bera, Omnibus, Anderson-Darling, Lilliefors)\r\n- Specification tests (RESET, Harvey-Collier)\r\n\r\n**Influence and outliers:**\r\n- Leverage (hat values)\r\n- Cook's distance\r\n- DFFITS and DFBETAs\r\n- Studentized residuals\r\n- Influence plots\r\n\r\n**Hypothesis testing:**\r\n- t-tests (one-sample, two-sample, paired)\r\n- Proportion tests\r\n- Chi-square tests\r\n- Non-parametric tests (Mann-Whitney, Wilcoxon, Kruskal-Wallis)\r\n- ANOVA (one-way, two-way, repeated measures)\r\n\r\n**Multiple comparisons:**\r\n- Tukey's HSD\r\n- Bonferroni correction\r\n- False Discovery Rate (FDR)\r\n\r\n**Effect sizes and power:**\r\n- Cohen's d, eta-squared\r\n- Power analysis for t-tests, proportions\r\n- Sample size calculations\r\n\r\n**Robust inference:**\r\n- Heteroskedasticity-consistent SEs (HC0-HC3)\r\n- HAC standard errors (Newey-West)\r\n- Cluster-robust standard errors\r\n\r\n**When to use:** Validating assumptions, detecting problems, ensuring robust inference\r\n\r\n**Reference:** See `references/stats_diagnostics.md` for comprehensive testing and diagnostic procedures.",
    "Overview": "Statsmodels is Python's premier library for statistical modeling, providing tools for estimation, inference, and diagnostics across a wide range of statistical methods. Apply this skill for rigorous statistical analysis, from simple linear regression to complex time series models and econometric analyses.",
    "Best Practices": "### Data Preparation\r\n\r\n1. **Always add constant**: Use `sm.add_constant()` unless excluding intercept\r\n2. **Check for missing values**: Handle or impute before fitting\r\n3. **Scale if needed**: Improves convergence, interpretation (but not required for tree models)\r\n4. **Encode categoricals**: Use formula API or manual dummy coding\r\n\r\n### Model Building\r\n\r\n1. **Start simple**: Begin with basic model, add complexity as needed\r\n2. **Check assumptions**: Test residuals, heteroskedasticity, autocorrelation\r\n3. **Use appropriate model**: Match model to outcome type (binary→Logit, count→Poisson)\r\n4. **Consider alternatives**: If assumptions violated, use robust methods or different model\r\n\r\n### Inference\r\n\r\n1. **Report effect sizes**: Not just p-values\r\n2. **Use robust SEs**: When heteroskedasticity or clustering present\r\n3. **Multiple comparisons**: Correct when testing many hypotheses\r\n4. **Confidence intervals**: Always report alongside point estimates\r\n\r\n### Model Evaluation\r\n\r\n1. **Check residuals**: Plot residuals vs fitted, Q-Q plot\r\n2. **Influence diagnostics**: Identify and investigate influential observations\r\n3. **Out-of-sample validation**: Test on holdout set or cross-validate\r\n4. **Compare models**: Use AIC/BIC for non-nested, LR test for nested\r\n\r\n### Reporting\r\n\r\n1. **Comprehensive summary**: Use `.summary()` for detailed output\r\n2. **Document decisions**: Note transformations, excluded observations\r\n3. **Interpret carefully**: Account for link functions (e.g., exp(β) for log link)\r\n4. **Visualize**: Plot predictions, confidence intervals, diagnostics",
    "When to Use This Skill": "This skill should be used when:\r\n- Fitting regression models (OLS, WLS, GLS, quantile regression)\r\n- Performing generalized linear modeling (logistic, Poisson, Gamma, etc.)\r\n- Analyzing discrete outcomes (binary, multinomial, count, ordinal)\r\n- Conducting time series analysis (ARIMA, SARIMAX, VAR, forecasting)\r\n- Running statistical tests and diagnostics\r\n- Testing model assumptions (heteroskedasticity, autocorrelation, normality)\r\n- Detecting outliers and influential observations\r\n- Comparing models (AIC/BIC, likelihood ratio tests)\r\n- Estimating causal effects\r\n- Producing publication-ready statistical tables and inference",
    "Getting Help": "For detailed documentation and examples:\r\n- Official docs: https://www.statsmodels.org/stable/\r\n- User guide: https://www.statsmodels.org/stable/user-guide.html\r\n- Examples: https://www.statsmodels.org/stable/examples/index.html\r\n- API reference: https://www.statsmodels.org/stable/api.html",
    "Formula API (R-style)": "```",
    "Common Workflows": "### Workflow 1: Linear Regression Analysis\r\n\r\n1. Explore data (plots, descriptives)\r\n2. Fit initial OLS model\r\n3. Check residual diagnostics\r\n4. Test for heteroskedasticity, autocorrelation\r\n5. Check for multicollinearity (VIF)\r\n6. Identify influential observations\r\n7. Refit with robust SEs if needed\r\n8. Interpret coefficients and inference\r\n9. Validate on holdout or via CV\r\n\r\n### Workflow 2: Binary Classification\r\n\r\n1. Fit logistic regression (Logit)\r\n2. Check for convergence issues\r\n3. Interpret odds ratios\r\n4. Calculate marginal effects\r\n5. Evaluate classification performance (AUC, confusion matrix)\r\n6. Check for influential observations\r\n7. Compare with alternative models (Probit)\r\n8. Validate predictions on test set\r\n\r\n### Workflow 3: Count Data Analysis\r\n\r\n1. Fit Poisson regression\r\n2. Check for overdispersion\r\n3. If overdispersed, fit Negative Binomial\r\n4. Check for excess zeros (consider ZIP/ZINB)\r\n5. Interpret rate ratios\r\n6. Assess goodness of fit\r\n7. Compare models via AIC\r\n8. Validate predictions\r\n\r\n### Workflow 4: Time Series Forecasting\r\n\r\n1. Plot series, check for trend/seasonality\r\n2. Test for stationarity (ADF, KPSS)\r\n3. Difference if non-stationary\r\n4. Identify p, q from ACF/PACF\r\n5. Fit ARIMA or SARIMAX\r\n6. Check residual diagnostics (Ljung-Box)\r\n7. Generate forecasts with confidence intervals\r\n8. Evaluate forecast accuracy on test set",
    "Model Selection and Comparison": "from scipy import stats\r\n\r\nlr_stat = 2 * (full_model.llf - reduced_model.llf)\r\ndf = full_model.df_model - reduced_model.df_model\r\np_value = 1 - stats.chi2.cdf(lr_stat, df)\r\n\r\nprint(f\"LR statistic: {lr_stat:.4f}\")\r\nprint(f\"p-value: {p_value:.4f}\")\r\n\r\nif p_value < 0.05:\r\n    print(\"Full model significantly better\")\r\nelse:\r\n    print(\"Reduced model preferred (parsimony)\")\r\n```\r\n\r\n### Cross-Validation\r\n\r\n```python\r\nfrom sklearn.model_selection import KFold\r\nfrom sklearn.metrics import mean_squared_error\r\n\r\nkf = KFold(n_splits=5, shuffle=True, random_state=42)\r\ncv_scores = []\r\n\r\nfor train_idx, val_idx in kf.split(X):\r\n    X_train, X_val = X.iloc[train_idx], X.iloc[val_idx]\r\n    y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]\r\n\r\n    # Fit model\r\n    model = sm.OLS(y_train, X_train).fit()\r\n\r\n    # Predict\r\n    y_pred = model.predict(X_val)\r\n\r\n    # Score\r\n    rmse = np.sqrt(mean_squared_error(y_val, y_pred))\r\n    cv_scores.append(rmse)\r\n\r\nprint(f\"CV RMSE: {np.mean(cv_scores):.4f} ± {np.std(cv_scores):.4f}\")\r\n```"
  }
}