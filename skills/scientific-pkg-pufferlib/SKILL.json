{
  "description": "This skill should be used when working with reinforcement learning tasks including high-performance RL training, custom environment development, vectorized parallel simulation, multi-agent systems, or integration with existing RL environments (Gymnasium, PettingZoo, Atari, Procgen, etc.). Use this skill for implementing PPO training, creating PufferEnv environments, optimizing RL performance, or developing policies with CNNs/LSTMs.",
  "references": {
    "files": [
      "references/environments.md",
      "references/integration.md",
      "references/policies.md",
      "references/training.md",
      "references/vectorization.md"
    ]
  },
  "content": "### 1. High-Performance Training (PuffeRL)\r\n\r\nPuffeRL is PufferLib's optimized PPO+LSTM training algorithm achieving 1M-4M steps/second.\r\n\r\n**Quick start training:**\r\n```bash\r\npuffer train procgen-coinrun --train.device cuda --train.learning-rate 3e-4\r\n\r\ntorchrun --nproc_per_node=4 train.py\r\n```\r\n\r\n**Python training loop:**\r\n```python\r\nimport pufferlib\r\nfrom pufferlib import PuffeRL\r\n\r\nenv = pufferlib.make('procgen-coinrun', num_envs=256)\r\n\r\ntrainer = PuffeRL(\r\n    env=env,\r\n    policy=my_policy,\r\n    device='cuda',\r\n    learning_rate=3e-4,\r\n    batch_size=32768\r\n)\r\n\r\nfor iteration in range(num_iterations):\r\n    trainer.evaluate()  # Collect rollouts\r\n    trainer.train()     # Train on batch\r\n    trainer.mean_and_log()  # Log results\r\n```\r\n\r\n**For comprehensive training guidance**, read `references/training.md` for:\r\n- Complete training workflow and CLI options\r\n- Hyperparameter tuning with Protein\r\n- Distributed multi-GPU/multi-node training\r\n- Logger integration (Weights & Biases, Neptune)\r\n- Checkpointing and resume training\r\n- Performance optimization tips\r\n- Curriculum learning patterns\r\n\r\n### 2. Environment Development (PufferEnv)\r\n\r\nCreate custom high-performance environments with the PufferEnv API.\r\n\r\n**Basic environment structure:**\r\n```python\r\nimport numpy as np\r\nfrom pufferlib import PufferEnv\r\n\r\nclass MyEnvironment(PufferEnv):\r\n    def __init__(self, buf=None):\r\n        super().__init__(buf)\r\n\r\n        # Define spaces\r\n        self.observation_space = self.make_space((4,))\r\n        self.action_space = self.make_discrete(4)\r\n\r\n        self.reset()\r\n\r\n    def reset(self):\r\n        # Reset state and return initial observation\r\n        return np.zeros(4, dtype=np.float32)\r\n\r\n    def step(self, action):\r\n        # Execute action, compute reward, check done\r\n        obs = self._get_observation()\r\n        reward = self._compute_reward()\r\n        done = self._is_done()\r\n        info = {}\r\n\r\n        return obs, reward, done, info\r\n```\r\n\r\n**Use the template script:** `scripts/env_template.py` provides complete single-agent and multi-agent environment templates with examples of:\r\n- Different observation space types (vector, image, dict)\r\n- Action space variations (discrete, continuous, multi-discrete)\r\n- Multi-agent environment structure\r\n- Testing utilities\r\n\r\n**For complete environment development**, read `references/environments.md` for:\r\n- PufferEnv API details and in-place operation patterns\r\n- Observation and action space definitions\r\n- Multi-agent environment creation\r\n- Ocean suite (20+ pre-built environments)\r\n- Performance optimization (Python to C workflow)\r\n- Environment wrappers and best practices\r\n- Debugging and validation techniques\r\n\r\n### 3. Vectorization and Performance\r\n\r\nAchieve maximum throughput with optimized parallel simulation.\r\n\r\n**Vectorization setup:**\r\n```python\r\nimport pufferlib\r\n\r\nenv = pufferlib.make('environment_name', num_envs=256, num_workers=8)\r\n\r\n```\r\n\r\n**Key optimizations:**\r\n- Shared memory buffers for zero-copy observation passing\r\n- Busy-wait flags instead of pipes/queues\r\n- Surplus environments for async returns\r\n- Multiple environments per worker\r\n\r\n**For vectorization optimization**, read `references/vectorization.md` for:\r\n- Architecture and performance characteristics\r\n- Worker and batch size configuration\r\n- Serial vs multiprocessing vs async modes\r\n- Shared memory and zero-copy patterns\r\n- Hierarchical vectorization for large scale\r\n- Multi-agent vectorization strategies\r\n- Performance profiling and troubleshooting\r\n\r\n### 4. Policy Development\r\n\r\nBuild policies as standard PyTorch modules with optional utilities.\r\n\r\n**Basic policy structure:**\r\n```python\r\nimport torch.nn as nn\r\nfrom pufferlib.pytorch import layer_init\r\n\r\nclass Policy(nn.Module):\r\n    def __init__(self, observation_space, action_space):\r\n        super().__init__()\r\n\r\n        # Encoder\r\n        self.encoder = nn.Sequential(\r\n            layer_init(nn.Linear(obs_dim, 256)),\r\n            nn.ReLU(),\r\n            layer_init(nn.Linear(256, 256)),\r\n            nn.ReLU()\r\n        )\r\n\r\n        # Actor and critic heads\r\n        self.actor = layer_init(nn.Linear(256, num_actions), std=0.01)\r\n        self.critic = layer_init(nn.Linear(256, 1), std=1.0)\r\n\r\n    def forward(self, observations):\r\n        features = self.encoder(observations)\r\n        return self.actor(features), self.critic(features)\r\n```\r\n\r\n**For complete policy development**, read `references/policies.md` for:\r\n- CNN policies for image observations\r\n- Recurrent policies with optimized LSTM (3x faster inference)\r\n- Multi-input policies for complex observations\r\n- Continuous action policies\r\n- Multi-agent policies (shared vs independent parameters)\r\n- Advanced architectures (attention, residual)\r\n- Observation normalization and gradient clipping\r\n- Policy debugging and testing\r\n\r\n### 5. Environment Integration\r\n\r\nSeamlessly integrate environments from popular RL frameworks.\r\n\r\n**Gymnasium integration:**\r\n```python\r\nimport gymnasium as gym\r\nimport pufferlib\r\n\r\ngym_env = gym.make('CartPole-v1')\r\nenv = pufferlib.emulate(gym_env, num_envs=256)\r\n\r\nenv = pufferlib.make('gym-CartPole-v1', num_envs=256)\r\n```\r\n\r\n**PettingZoo multi-agent:**\r\n```python\r\n\r\n### Training on Standard Benchmarks\r\n```python\r\nenv = pufferlib.make('atari-pong', num_envs=256)\r\n\r\nenv = pufferlib.make('procgen-coinrun', num_envs=256)\r\n\r\nenv = pufferlib.make('minigrid-empty-8x8', num_envs=256)\r\n```\r\n\r\n### Multi-Agent Learning\r\n```python\r\nenv = pufferlib.make('pettingzoo-pistonball', num_envs=128)\r\n\r\npolicy = create_policy(env.observation_space, env.action_space)\r\ntrainer = PuffeRL(env=env, policy=policy)\r\n```\r\n\r\n### Custom Task Development\r\n```python\r\nclass MyTask(PufferEnv):\r\n    # ... implement environment ...\r\n\r\nenv = pufferlib.emulate(MyTask, num_envs=256)\r\ntrainer = PuffeRL(env=env, policy=my_policy)\r\n```\r\n\r\n### High-Performance Optimization\r\n```python",
  "name": "pufferlib",
  "id": "scientific-pkg-pufferlib",
  "sections": {
    "Installation": "```bash\r\npip install pufferlib\r\n```",
    "Overview": "PufferLib is a high-performance reinforcement learning library designed for fast parallel environment simulation and training. It achieves training at millions of steps per second through optimized vectorization, native multi-agent support, and efficient PPO implementation (PuffeRL). The library provides the Ocean suite of 20+ environments and seamless integration with Gymnasium, PettingZoo, and specialized RL frameworks.",
    "Common Use Cases": "env = pufferlib.make(\r\n    'my-env',\r\n    num_envs=1024,      # Large batch\r\n    num_workers=16,     # Many workers\r\n    envs_per_worker=64  # Optimize per worker\r\n)\r\n```",
    "When to Use This Skill": "Use this skill when:\r\n- **Training RL agents** with PPO on any environment (single or multi-agent)\r\n- **Creating custom environments** using the PufferEnv API\r\n- **Optimizing performance** for parallel environment simulation (vectorization)\r\n- **Integrating existing environments** from Gymnasium, PettingZoo, Atari, Procgen, etc.\r\n- **Developing policies** with CNN, LSTM, or custom architectures\r\n- **Scaling RL** to millions of steps per second for faster experimentation\r\n- **Multi-agent RL** with native multi-agent environment support",
    "Resources": "### scripts/\r\n\r\n**train_template.py** - Complete training script template with:\r\n- Environment creation and configuration\r\n- Policy initialization\r\n- Logger integration (WandB, Neptune)\r\n- Training loop with checkpointing\r\n- Command-line argument parsing\r\n- Multi-GPU distributed training setup\r\n\r\n**env_template.py** - Environment implementation templates:\r\n- Single-agent PufferEnv example (grid world)\r\n- Multi-agent PufferEnv example (cooperative navigation)\r\n- Multiple observation/action space patterns\r\n- Testing utilities\r\n\r\n### references/\r\n\r\n**training.md** - Comprehensive training guide:\r\n- Training workflow and CLI options\r\n- Hyperparameter configuration\r\n- Distributed training (multi-GPU, multi-node)\r\n- Monitoring and logging\r\n- Checkpointing\r\n- Protein hyperparameter tuning\r\n- Performance optimization\r\n- Common training patterns\r\n- Troubleshooting\r\n\r\n**environments.md** - Environment development guide:\r\n- PufferEnv API and characteristics\r\n- Observation and action spaces\r\n- Multi-agent environments\r\n- Ocean suite environments\r\n- Custom environment development workflow\r\n- Python to C optimization path\r\n- Third-party environment integration\r\n- Wrappers and best practices\r\n- Debugging\r\n\r\n**vectorization.md** - Vectorization optimization:\r\n- Architecture and key optimizations\r\n- Vectorization modes (serial, multiprocessing, async)\r\n- Worker and batch configuration\r\n- Shared memory and zero-copy patterns\r\n- Advanced vectorization (hierarchical, custom)\r\n- Multi-agent vectorization\r\n- Performance monitoring and profiling\r\n- Troubleshooting and best practices\r\n\r\n**policies.md** - Policy architecture guide:\r\n- Basic policy structure\r\n- CNN policies for images\r\n- LSTM policies with optimization\r\n- Multi-input policies\r\n- Continuous action policies\r\n- Multi-agent policies\r\n- Advanced architectures (attention, residual)\r\n- Observation processing and unflattening\r\n- Initialization and normalization\r\n- Debugging and testing\r\n\r\n**integration.md** - Framework integration guide:\r\n- Gymnasium integration\r\n- PettingZoo integration (parallel and AEC)\r\n- Third-party environments (Procgen, NetHack, Minigrid, etc.)\r\n- Custom wrappers (observation, reward, frame stacking, etc.)\r\n- Space conversion and unflattening\r\n- Environment registration\r\n- Compatibility patterns\r\n- Performance considerations\r\n- Debugging integration",
    "Core Capabilities": "env = pufferlib.make('pettingzoo-knights-archers-zombies', num_envs=128)\r\n```\r\n\r\n**Supported frameworks:**\r\n- Gymnasium / OpenAI Gym\r\n- PettingZoo (parallel and AEC)\r\n- Atari (ALE)\r\n- Procgen\r\n- NetHack / MiniHack\r\n- Minigrid\r\n- Neural MMO\r\n- Crafter\r\n- GPUDrive\r\n- MicroRTS\r\n- Griddly\r\n- And more...\r\n\r\n**For integration details**, read `references/integration.md` for:\r\n- Complete integration examples for each framework\r\n- Custom wrappers (observation, reward, frame stacking, action repeat)\r\n- Space flattening and unflattening\r\n- Environment registration\r\n- Compatibility patterns\r\n- Performance considerations\r\n- Integration debugging",
    "Documentation": "- Official docs: https://puffer.ai/docs.html\r\n- GitHub: https://github.com/PufferAI/PufferLib\r\n- Discord: Community support available",
    "Tips for Success": "1. **Start simple**: Begin with Ocean environments or Gymnasium integration before creating custom environments\r\n\r\n2. **Profile early**: Measure steps per second from the start to identify bottlenecks\r\n\r\n3. **Use templates**: `scripts/train_template.py` and `scripts/env_template.py` provide solid starting points\r\n\r\n4. **Read references as needed**: Each reference file is self-contained and focused on a specific capability\r\n\r\n5. **Optimize progressively**: Start with Python, profile, then optimize critical paths with C if needed\r\n\r\n6. **Leverage vectorization**: PufferLib's vectorization is key to achieving high throughput\r\n\r\n7. **Monitor training**: Use WandB or Neptune to track experiments and identify issues early\r\n\r\n8. **Test environments**: Validate environment logic before scaling up training\r\n\r\n9. **Check existing environments**: Ocean suite provides 20+ pre-built environments\r\n\r\n10. **Use proper initialization**: Always use `layer_init` from `pufferlib.pytorch` for policies",
    "Quick Start Workflow": "### For Training Existing Environments\r\n\r\n1. Choose environment from Ocean suite or compatible framework\r\n2. Use `scripts/train_template.py` as starting point\r\n3. Configure hyperparameters for your task\r\n4. Run training with CLI or Python script\r\n5. Monitor with Weights & Biases or Neptune\r\n6. Refer to `references/training.md` for optimization\r\n\r\n### For Creating Custom Environments\r\n\r\n1. Start with `scripts/env_template.py`\r\n2. Define observation and action spaces\r\n3. Implement `reset()` and `step()` methods\r\n4. Test environment locally\r\n5. Vectorize with `pufferlib.emulate()` or `make()`\r\n6. Refer to `references/environments.md` for advanced patterns\r\n7. Optimize with `references/vectorization.md` if needed\r\n\r\n### For Policy Development\r\n\r\n1. Choose architecture based on observations:\r\n   - Vector observations → MLP policy\r\n   - Image observations → CNN policy\r\n   - Sequential tasks → LSTM policy\r\n   - Complex observations → Multi-input policy\r\n2. Use `layer_init` for proper weight initialization\r\n3. Follow patterns in `references/policies.md`\r\n4. Test with environment before full training\r\n\r\n### For Performance Optimization\r\n\r\n1. Profile current throughput (steps per second)\r\n2. Check vectorization configuration (num_envs, num_workers)\r\n3. Optimize environment code (in-place ops, numpy vectorization)\r\n4. Consider C implementation for critical paths\r\n5. Use `references/vectorization.md` for systematic optimization"
  }
}