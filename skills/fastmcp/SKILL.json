{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/cli-commands.md",
      "references/cloud-deployment.md",
      "references/common-errors.md",
      "references/context-features.md",
      "references/integration-patterns.md",
      "references/production-patterns.md"
    ]
  },
  "content": "FastMCP is a Python framework for building Model Context Protocol (MCP) servers that expose tools, resources, and prompts to Large Language Models like Claude. This skill provides production-tested patterns, error prevention, and deployment strategies for building robust MCP servers.\r\n\r\n\r\n### Installation\r\n\r\n```bash\r\npip install fastmcp\r\nuv pip install fastmcp\r\n```\r\n\r\n### Minimal Server\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\n\r\nmcp = FastMCP(\"My Server\")\r\n\r\n@mcp.tool()\r\nasync def hello(name: str) -> str:\r\n    \"\"\"Say hello to someone.\"\"\"\r\n    return f\"Hello, {name}!\"\r\n\r\nif __name__ == \"__main__\":\r\n    mcp.run()\r\n```\r\n\r\n**Run it:**\r\n```bash\r\npython server.py\r\n\r\nfastmcp dev server.py\r\n\r\n\r\n### 1. Tools\r\n\r\nTools are functions that LLMs can call to perform actions:\r\n\r\n```python\r\n@mcp.tool()\r\ndef calculate(operation: str, a: float, b: float) -> float:\r\n    \"\"\"Perform mathematical operations.\r\n\r\n    Args:\r\n        operation: add, subtract, multiply, or divide\r\n        a: First number\r\n        b: Second number\r\n\r\n    Returns:\r\n        Result of the operation\r\n    \"\"\"\r\n    operations = {\r\n        \"add\": lambda x, y: x + y,\r\n        \"subtract\": lambda x, y: x - y,\r\n        \"multiply\": lambda x, y: x * y,\r\n        \"divide\": lambda x, y: x / y if y != 0 else None\r\n    }\r\n    return operations.get(operation, lambda x, y: None)(a, b)\r\n```\r\n\r\n**Best Practices:**\r\n- Clear, descriptive function names\r\n- Comprehensive docstrings (LLMs read these!)\r\n- Strong type hints (Pydantic validates automatically)\r\n- Return structured data (dicts/lists)\r\n- Handle errors gracefully\r\n\r\n**Sync vs Async:**\r\n\r\n```python\r\n@mcp.tool()\r\ndef sync_tool(param: str) -> dict:\r\n    return {\"result\": param.upper()}\r\n\r\n@mcp.tool()\r\nasync def async_tool(url: str) -> dict:\r\n    async with httpx.AsyncClient() as client:\r\n        response = await client.get(url)\r\n        return response.json()\r\n```\r\n\r\n### 2. Resources\r\n\r\nResources expose static or dynamic data to LLMs:\r\n\r\n```python\r\n@mcp.resource(\"data://config\")\r\ndef get_config() -> dict:\r\n    \"\"\"Provide application configuration.\"\"\"\r\n    return {\r\n        \"version\": \"1.0.0\",\r\n        \"features\": [\"auth\", \"api\", \"cache\"]\r\n    }\r\n\r\n@mcp.resource(\"info://status\")\r\nasync def server_status() -> dict:\r\n    \"\"\"Get current server status.\"\"\"\r\n    return {\r\n        \"status\": \"healthy\",\r\n        \"timestamp\": datetime.now().isoformat(),\r\n        \"api_configured\": bool(os.getenv(\"API_KEY\"))\r\n    }\r\n```\r\n\r\n**Resource URI Schemes:**\r\n- `data://` - Generic data\r\n- `file://` - File resources\r\n- `resource://` - General resources\r\n- `info://` - Information/metadata\r\n- `api://` - API endpoints\r\n- Custom schemes allowed\r\n\r\n### 3. Resource Templates\r\n\r\nDynamic resources with parameters in the URI:\r\n\r\n```python\r\n@mcp.resource(\"user://{user_id}/profile\")\r\nasync def get_user_profile(user_id: str) -> dict:\r\n    \"\"\"Get user profile by ID.\"\"\"\r\n    user = await fetch_user_from_db(user_id)\r\n    return {\r\n        \"id\": user_id,\r\n        \"name\": user.name,\r\n        \"email\": user.email\r\n    }\r\n\r\n\r\nFastMCP supports pluggable storage backends built on the `py-key-value-aio` library. Storage backends enable persistent state for OAuth tokens, response caching, and client-side token storage.\r\n\r\n### Available Backends\r\n\r\n**Memory Store (Default)**:\r\n- Ephemeral storage (lost on restart)\r\n- Fast, no configuration needed\r\n- Good for development\r\n\r\n**Disk Store**:\r\n- Persistent storage on local filesystem\r\n- Encrypted by default with `FernetEncryptionWrapper`\r\n- Platform-aware defaults (Mac/Windows use disk, Linux uses memory)\r\n\r\n**Redis Store**:\r\n- Distributed storage for production\r\n- Supports multi-instance deployments\r\n- Ideal for response caching across servers\r\n\r\n**Other Supported**:\r\n- DynamoDB (AWS)\r\n- MongoDB\r\n- Elasticsearch\r\n- Memcached\r\n- RocksDB\r\n- Valkey\r\n\r\n### Basic Usage\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nfrom key_value.stores import MemoryStore, DiskStore, RedisStore\r\nfrom key_value.encryption import FernetEncryptionWrapper\r\nfrom cryptography.fernet import Fernet\r\nimport os\r\n\r\nmcp = FastMCP(\"My Server\")\r\n\r\nfrom key_value.stores import DiskStore\r\n\r\nmcp = FastMCP(\r\n    \"My Server\",\r\n    storage=DiskStore(path=\"/app/data/storage\")\r\n)\r\n\r\nfrom key_value.stores import RedisStore\r\n\r\nmcp = FastMCP(\r\n    \"My Server\",\r\n    storage=RedisStore(\r\n        host=os.getenv(\"REDIS_HOST\", \"localhost\"),\r\n        port=int(os.getenv(\"REDIS_PORT\", \"6379\")),\r\n        password=os.getenv(\"REDIS_PASSWORD\")\r\n    )\r\n)\r\n```\r\n\r\n### Encrypted Storage\r\n\r\nStorage backends support automatic encryption:\r\n\r\n```python\r\nfrom cryptography.fernet import Fernet\r\nfrom key_value.encryption import FernetEncryptionWrapper\r\nfrom key_value.stores import DiskStore\r\n\r\n\r\nencrypted_storage = FernetEncryptionWrapper(\r\n    key_value=DiskStore(path=\"/app/data/storage\"),\r\n    fernet=Fernet(os.getenv(\"STORAGE_ENCRYPTION_KEY\"))\r\n)\r\n\r\nmcp = FastMCP(\"My Server\", storage=encrypted_storage)\r\n```\r\n\r\n### OAuth Token Storage\r\n\r\nStorage backends automatically persist OAuth tokens:\r\n\r\n```python\r\nfrom fastmcp.auth import OAuthProxy\r\nfrom key_value.stores import RedisStore\r\nfrom key_value.encryption import FernetEncryptionWrapper\r\nfrom cryptography.fernet import Fernet\r\n\r\nauth = OAuthProxy(\r\n    jwt_signing_key=os.environ[\"JWT_SIGNING_KEY\"],\r\n    client_storage=FernetEncryptionWrapper(\r\n        key_value=RedisStore(\r\n            host=os.getenv(\"REDIS_HOST\"),\r\n            password=os.getenv(\"REDIS_PASSWORD\")\r\n        ),\r\n        fernet=Fernet(os.environ[\"STORAGE_ENCRYPTION_KEY\"])\r\n    ),\r\n    upstream_authorization_endpoint=\"https://provider.com/oauth/authorize\",\r\n    upstream_token_endpoint=\"https://provider.com/oauth/token\",\r\n    upstream_client_id=os.getenv(\"OAUTH_CLIENT_ID\"),\r\n    upstream_client_secret=os.getenv(\"OAUTH_CLIENT_SECRET\")\r\n)\r\n\r\nmcp = FastMCP(\"OAuth Server\", auth=auth)\r\n```\r\n\r\n### Platform-Aware Defaults\r\n\r\nFastMCP automatically chooses storage based on platform:\r\n\r\n- **Mac/Windows**: Disk storage (persistent)\r\n- **Linux**: Memory storage (ephemeral)\r\n- **Override**: Set `storage` parameter explicitly\r\n\r\n```python\r\n\r\nServer lifespans provide initialization and cleanup hooks that run once per server instance (NOT per client session). This is critical for managing database connections, API clients, and other resources.\r\n\r\n**⚠️ Breaking Change in v2.13.0**: Lifespan behavior changed from per-session to per-server-instance.\r\n\r\n### Basic Pattern\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nfrom contextlib import asynccontextmanager\r\nfrom typing import AsyncIterator\r\nfrom dataclasses import dataclass\r\n\r\n@dataclass\r\nclass AppContext:\r\n    \"\"\"Shared application state.\"\"\"\r\n    db: Database\r\n    api_client: httpx.AsyncClient\r\n\r\n@asynccontextmanager\r\nasync def app_lifespan(server: FastMCP) -> AsyncIterator[AppContext]:\r\n    \"\"\"\r\n    Initialize resources on startup, cleanup on shutdown.\r\n    Runs ONCE per server instance, NOT per client session.\r\n    \"\"\"\r\n    # Startup: Initialize resources\r\n    db = await Database.connect(os.getenv(\"DATABASE_URL\"))\r\n    api_client = httpx.AsyncClient(\r\n        base_url=os.getenv(\"API_BASE_URL\"),\r\n        headers={\"Authorization\": f\"Bearer {os.getenv('API_KEY')}\"},\r\n        timeout=30.0\r\n    )\r\n\r\n    print(\"Server initialized\")\r\n\r\n    try:\r\n        # Yield context to tools\r\n        yield AppContext(db=db, api_client=api_client)\r\n    finally:\r\n        # Shutdown: Cleanup resources\r\n        await db.disconnect()\r\n        await api_client.aclose()\r\n        print(\"Server shutdown complete\")\r\n\r\nmcp = FastMCP(\"My Server\", lifespan=app_lifespan)\r\n\r\nfrom fastmcp import Context\r\n\r\n@mcp.tool()\r\nasync def query_database(sql: str, context: Context) -> list:\r\n    \"\"\"Query database using shared connection.\"\"\"\r\n    # Access lifespan context\r\n    app_context: AppContext = context.fastmcp_context.lifespan_context\r\n    return await app_context.db.query(sql)\r\n\r\n@mcp.tool()\r\nasync def api_request(endpoint: str, context: Context) -> dict:\r\n    \"\"\"Make API request using shared client.\"\"\"\r\n    app_context: AppContext = context.fastmcp_context.lifespan_context\r\n    response = await app_context.api_client.get(endpoint)\r\n    return response.json()\r\n```\r\n\r\n### ASGI Integration\r\n\r\nWhen using FastMCP with ASGI apps (FastAPI, Starlette), you **must** pass the lifespan explicitly:\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastmcp import FastMCP\r\n\r\n@asynccontextmanager\r\nasync def mcp_lifespan(server: FastMCP):\r\n    print(\"MCP server starting\")\r\n    yield\r\n    print(\"MCP server stopping\")\r\n\r\nmcp = FastMCP(\"My Server\", lifespan=mcp_lifespan)\r\n\r\napp = FastAPI(lifespan=mcp.lifespan)\r\n\r\n\r\nFastMCP provides an MCP-native middleware system for cross-cutting functionality like logging, rate limiting, caching, and error handling.\r\n\r\n### Built-in Middleware (8 Types)\r\n\r\n1. **TimingMiddleware** - Performance monitoring\r\n2. **ResponseCachingMiddleware** - TTL-based caching with pluggable storage\r\n3. **LoggingMiddleware** - Human-readable and JSON-structured logging\r\n4. **RateLimitingMiddleware** - Token bucket and sliding window algorithms\r\n5. **ErrorHandlingMiddleware** - Consistent error management\r\n6. **ToolInjectionMiddleware** - Dynamic tool injection\r\n7. **PromptToolMiddleware** - Tool-based prompt access for limited clients\r\n8. **ResourceToolMiddleware** - Tool-based resource access for limited clients\r\n\r\n### Basic Usage\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nfrom fastmcp.middleware import (\r\n    TimingMiddleware,\r\n    LoggingMiddleware,\r\n    RateLimitingMiddleware,\r\n    ResponseCachingMiddleware,\r\n    ErrorHandlingMiddleware\r\n)\r\n\r\nmcp = FastMCP(\"My Server\")\r\n\r\nmcp.add_middleware(ErrorHandlingMiddleware())\r\nmcp.add_middleware(TimingMiddleware())\r\nmcp.add_middleware(LoggingMiddleware(level=\"INFO\"))\r\nmcp.add_middleware(RateLimitingMiddleware(\r\n    max_requests=100,\r\n    window_seconds=60,\r\n    algorithm=\"token_bucket\"\r\n))\r\nmcp.add_middleware(ResponseCachingMiddleware(\r\n    ttl_seconds=300,\r\n    storage=RedisStore(host=\"localhost\")\r\n))\r\n```\r\n\r\n### Middleware Execution Order\r\n\r\nMiddleware executes in order added:\r\n\r\n```\r\nRequest Flow:\r\n  → ErrorHandlingMiddleware (catches errors)\r\n    → TimingMiddleware (starts timer)\r\n      → LoggingMiddleware (logs request)\r\n        → RateLimitingMiddleware (checks rate limit)\r\n          → ResponseCachingMiddleware (checks cache)\r\n            → Tool/Resource Handler\r\n          ← ResponseCachingMiddleware (stores in cache)\r\n        ← RateLimitingMiddleware\r\n      ← LoggingMiddleware (logs response)\r\n    ← TimingMiddleware (stops timer, logs duration)\r\n  ← ErrorHandlingMiddleware (returns error if any)\r\n```\r\n\r\n### Custom Middleware\r\n\r\nCreate custom middleware using hooks:\r\n\r\n```python\r\nfrom fastmcp.middleware import BaseMiddleware\r\nfrom fastmcp import Context\r\n\r\nclass AccessControlMiddleware(BaseMiddleware):\r\n    \"\"\"Check authorization before tool execution.\"\"\"\r\n\r\n    def __init__(self, allowed_users: list[str]):\r\n        self.allowed_users = allowed_users\r\n\r\n    async def on_call_tool(self, tool_name: str, arguments: dict, context: Context):\r\n        \"\"\"Hook runs before tool execution.\"\"\"\r\n        # Get user from context (from auth)\r\n        user = context.fastmcp_context.get_state(\"user_id\")\r\n\r\n        if user not in self.allowed_users:\r\n            raise PermissionError(f\"User '{user}' not authorized\")\r\n\r\n        # Continue to tool\r\n        return await self.next(tool_name, arguments, context)\r\n\r\nmcp.add_middleware(AccessControlMiddleware(\r\n    allowed_users=[\"alice\", \"bob\", \"charlie\"]\r\n))\r\n```\r\n\r\n### Hook Hierarchy\r\n\r\nMiddleware hooks from most general to most specific:\r\n\r\n1. **`on_message`** - All messages (requests and notifications)\r\n2. **`on_request`** / **`on_notification`** - By message type\r\n3. **`on_call_tool`**, **`on_read_resource`**, **`on_get_prompt`** - Operation-specific\r\n4. **`on_list_tools`**, **`on_list_resources`**, **`on_list_prompts`**, **`on_list_resource_templates`** - List operations\r\n\r\n```python\r\nclass ComprehensiveMiddleware(BaseMiddleware):\r\n    async def on_message(self, message: dict, context: Context):\r\n        \"\"\"Runs for ALL messages.\"\"\"\r\n        print(f\"Message: {message['method']}\")\r\n        return await self.next(message, context)\r\n\r\n    async def on_call_tool(self, tool_name: str, arguments: dict, context: Context):\r\n        \"\"\"Runs only for tool calls.\"\"\"\r\n        print(f\"Tool: {tool_name}\")\r\n        return await self.next(tool_name, arguments, context)\r\n\r\n    async def on_read_resource(self, uri: str, context: Context):\r\n        \"\"\"Runs only for resource reads.\"\"\"\r\n        print(f\"Resource: {uri}\")\r\n        return await self.next(uri, context)\r\n```\r\n\r\n### Response Caching Middleware\r\n\r\nImprove performance by caching expensive operations:\r\n\r\n```python\r\nfrom fastmcp.middleware import ResponseCachingMiddleware\r\nfrom key_value.stores import RedisStore\r\n\r\ncache_middleware = ResponseCachingMiddleware(\r\n    ttl_seconds=300,\r\n    storage=RedisStore(host=\"localhost\"),  # Shared across instances\r\n    cache_tools=True,       # Cache tool calls\r\n    cache_resources=True,   # Cache resource reads\r\n    cache_prompts=False     # Don't cache prompts\r\n)\r\n\r\nmcp.add_middleware(cache_middleware)\r\n\r\n\r\nOrganize tools, resources, and prompts into modular components using server composition.\r\n\r\n### Two Strategies\r\n\r\n**1. `import_server()` - Static Snapshot**:\r\n- One-time copy of components at import time\r\n- Changes to subserver don't propagate\r\n- Fast (no runtime delegation)\r\n- Use for: Bundling finalized components\r\n\r\n**2. `mount()` - Dynamic Link**:\r\n- Live runtime link to subserver\r\n- Changes to subserver immediately visible\r\n- Runtime delegation (slower)\r\n- Use for: Modular runtime composition\r\n\r\n### Import Server (Static)\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\n\r\napi_server = FastMCP(\"API Server\")\r\n\r\n@api_server.tool()\r\ndef api_tool():\r\n    return \"API result\"\r\n\r\n@api_server.resource(\"api://status\")\r\ndef api_status():\r\n    return {\"status\": \"ok\"}\r\n\r\nmain_server = FastMCP(\"Main Server\")\r\n\r\nmain_server.import_server(api_server)\r\n\r\n```\r\n\r\n### Mount Server (Dynamic)\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\n\r\napi_server = FastMCP(\"API Server\")\r\ndb_server = FastMCP(\"DB Server\")\r\n\r\n@api_server.tool()\r\ndef fetch_data():\r\n    return \"API data\"\r\n\r\n@db_server.tool()\r\ndef query_db():\r\n    return \"DB result\"\r\n\r\nmain_server = FastMCP(\"Main Server\")\r\n\r\nmain_server.mount(api_server, prefix=\"api\")\r\nmain_server.mount(db_server, prefix=\"db\")\r\n\r\n\r\n```\r\n\r\n### Mounting Modes\r\n\r\n**Direct Mounting (Default)**:\r\n```python\r\nmain_server.mount(subserver, prefix=\"sub\")\r\n```\r\n\r\n**Proxy Mounting**:\r\n```python\r\nmain_server.mount(\r\n    subserver,\r\n    prefix=\"sub\",\r\n    mode=\"proxy\"\r\n)\r\n```\r\n\r\n### Tag Filtering\r\n\r\nFilter components when importing/mounting:\r\n\r\n```python\r\n@api_server.tool(tags=[\"public\"])\r\ndef public_api():\r\n    return \"Public\"\r\n\r\n@api_server.tool(tags=[\"admin\"])\r\ndef admin_api():\r\n    return \"Admin only\"\r\n\r\nmain_server.import_server(\r\n    api_server,\r\n    include_tags=[\"public\"]\r\n)\r\n\r\nmain_server.import_server(\r\n    api_server,\r\n    exclude_tags=[\"admin\"]\r\n)\r\n\r\n\r\nFastMCP provides comprehensive authentication support for HTTP-based transports, including an OAuth Proxy for providers that don't support Dynamic Client Registration (DCR).\r\n\r\n### Four Authentication Patterns\r\n\r\n1. **Token Validation** (`TokenVerifier`/`JWTVerifier`) - Validate external tokens\r\n2. **External Identity Providers** (`RemoteAuthProvider`) - OAuth 2.0/OIDC with DCR\r\n3. **OAuth Proxy** (`OAuthProxy`) - Bridge to traditional OAuth providers\r\n4. **Full OAuth** (`OAuthProvider`) - Complete authorization server\r\n\r\n### Pattern 1: Token Validation\r\n\r\nValidate tokens issued by external systems:\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nfrom fastmcp.auth import JWTVerifier\r\n\r\nauth = JWTVerifier(\r\n    issuer=\"https://auth.example.com\",\r\n    audience=\"my-mcp-server\",\r\n    public_key=os.getenv(\"JWT_PUBLIC_KEY\")\r\n)\r\n\r\nmcp = FastMCP(\"Secure Server\", auth=auth)\r\n\r\n@mcp.tool()\r\nasync def secure_operation(context: Context) -> dict:\r\n    \"\"\"Only accessible with valid JWT.\"\"\"\r\n    # Token validated automatically\r\n    user = context.fastmcp_context.get_state(\"user_id\")\r\n    return {\"user\": user, \"status\": \"authorized\"}\r\n```\r\n\r\n### Pattern 2: External Identity Providers\r\n\r\nUse OAuth 2.0/OIDC providers with Dynamic Client Registration:\r\n\r\n```python\r\nfrom fastmcp.auth import RemoteAuthProvider\r\n\r\nauth = RemoteAuthProvider(\r\n    issuer=\"https://auth.example.com\",\r\n    # Provider must support DCR\r\n)\r\n\r\nmcp = FastMCP(\"OAuth Server\", auth=auth)\r\n```\r\n\r\n### Pattern 3: OAuth Proxy (Recommended for Production)\r\n\r\nBridge to OAuth providers without DCR support (GitHub, Google, Azure, AWS, Discord, Facebook, etc.):\r\n\r\n```python\r\nfrom fastmcp.auth import OAuthProxy\r\nfrom key_value.stores import RedisStore\r\nfrom key_value.encryption import FernetEncryptionWrapper\r\nfrom cryptography.fernet import Fernet\r\nimport os\r\n\r\nauth = OAuthProxy(\r\n    # JWT signing for issued tokens\r\n    jwt_signing_key=os.environ[\"JWT_SIGNING_KEY\"],\r\n\r\n    # Encrypted storage for upstream tokens\r\n    client_storage=FernetEncryptionWrapper(\r\n        key_value=RedisStore(\r\n            host=os.getenv(\"REDIS_HOST\"),\r\n            password=os.getenv(\"REDIS_PASSWORD\")\r\n        ),\r\n        fernet=Fernet(os.environ[\"STORAGE_ENCRYPTION_KEY\"])\r\n    ),\r\n\r\n    # Upstream OAuth provider\r\n    upstream_authorization_endpoint=\"https://github.com/login/oauth/authorize\",\r\n    upstream_token_endpoint=\"https://github.com/login/oauth/access_token\",\r\n    upstream_client_id=os.getenv(\"GITHUB_CLIENT_ID\"),\r\n    upstream_client_secret=os.getenv(\"GITHUB_CLIENT_SECRET\"),\r\n\r\n    # Scopes\r\n    upstream_scope=\"read:user user:email\",\r\n\r\n    # Security: Enable consent screen (prevents confused deputy attacks)\r\n    enable_consent_screen=True\r\n)\r\n\r\nmcp = FastMCP(\"GitHub Auth Server\", auth=auth)\r\n```\r\n\r\n### OAuth Proxy Features\r\n\r\n**Token Factory Pattern**:\r\n- Proxy issues its own JWTs (not forwarding upstream tokens)\r\n- Upstream tokens stored encrypted\r\n- Proxy tokens can have custom claims\r\n\r\n**Consent Screens**:\r\n- Prevents authorization bypass attacks\r\n- Shows user what permissions are being granted\r\n- Required for security compliance\r\n\r\n**PKCE Support**:\r\n- End-to-end validation from client to upstream\r\n- Protects against authorization code interception\r\n\r\n**RFC 7662 Token Introspection**:\r\n- Validate tokens with upstream provider\r\n- Check revocation status\r\n\r\n### Pattern 4: Full OAuth Provider\r\n\r\nRun complete authorization server:\r\n\r\n```python\r\nfrom fastmcp.auth import OAuthProvider\r\n\r\nauth = OAuthProvider(\r\n    issuer=\"https://my-auth-server.com\",\r\n    client_storage=RedisStore(host=\"localhost\"),\r\n    # Full OAuth 2.0 server implementation\r\n)\r\n\r\nmcp = FastMCP(\"Auth Server\", auth=auth)\r\n```\r\n\r\n### Environment-Based Configuration\r\n\r\nAuto-detect auth from environment:\r\n\r\n```bash\r\nexport FASTMCP_SERVER_AUTH='{\"type\": \"oauth_proxy\", \"upstream_authorization_endpoint\": \"...\", ...}'\r\n```\r\n\r\n```python\r\n\r\nAdd visual representations to servers, tools, resources, and prompts for better UX in MCP clients.\r\n\r\n### Server-Level Icons\r\n\r\n```python\r\nfrom fastmcp import FastMCP, Icon\r\n\r\nmcp = FastMCP(\r\n    name=\"Weather Service\",\r\n    website_url=\"https://weather.example.com\",\r\n    icons=[\r\n        Icon(\r\n            url=\"https://example.com/icon-small.png\",\r\n            size=\"small\"\r\n        ),\r\n        Icon(\r\n            url=\"https://example.com/icon-large.png\",\r\n            size=\"large\"\r\n        )\r\n    ]\r\n)\r\n```\r\n\r\n### Component-Level Icons\r\n\r\n```python\r\nfrom fastmcp import Icon\r\n\r\n@mcp.tool(icons=[\r\n    Icon(url=\"https://example.com/tool-icon.png\")\r\n])\r\nasync def analyze_data(data: str) -> dict:\r\n    \"\"\"Analyze data with visual icon.\"\"\"\r\n    return {\"result\": \"analyzed\"}\r\n\r\n@mcp.resource(\r\n    \"user://{user_id}/profile\",\r\n    icons=[Icon(url=\"https://example.com/user-icon.png\")]\r\n)\r\nasync def get_user(user_id: str) -> dict:\r\n    \"\"\"User profile with icon.\"\"\"\r\n    return {\"id\": user_id, \"name\": \"Alice\"}\r\n\r\n@mcp.prompt(\r\n    \"analyze\",\r\n    icons=[Icon(url=\"https://example.com/prompt-icon.png\")]\r\n)\r\ndef analysis_prompt(topic: str) -> str:\r\n    \"\"\"Analysis prompt with icon.\"\"\"\r\n    return f\"Analyze {topic}\"\r\n```\r\n\r\n### Data URI Support\r\n\r\nEmbed images directly (useful for self-contained deployments):\r\n\r\n```python\r\nfrom fastmcp import Icon, Image\r\n\r\nicon = Icon.from_file(\"/path/to/icon.png\", size=\"medium\")\r\n\r\nimage_data_uri = Image.to_data_uri(\"/path/to/icon.png\")\r\nicon = Icon(url=image_data_uri, size=\"medium\")\r\n\r\n\r\nFastMCP provides multiple patterns for API integration:\r\n\r\n### Pattern 1: Manual API Integration\r\n\r\n```python\r\nimport httpx\r\nimport os\r\n\r\nclient = httpx.AsyncClient(\r\n    base_url=os.getenv(\"API_BASE_URL\"),\r\n    headers={\"Authorization\": f\"Bearer {os.getenv('API_KEY')}\"},\r\n    timeout=30.0\r\n)\r\n\r\n@mcp.tool()\r\nasync def fetch_data(endpoint: str) -> dict:\r\n    \"\"\"Fetch data from API.\"\"\"\r\n    try:\r\n        response = await client.get(endpoint)\r\n        response.raise_for_status()\r\n        return {\"success\": True, \"data\": response.json()}\r\n    except httpx.HTTPStatusError as e:\r\n        return {\"error\": f\"HTTP {e.response.status_code}\"}\r\n    except Exception as e:\r\n        return {\"error\": str(e)}\r\n```\r\n\r\n### Pattern 2: OpenAPI/Swagger Auto-Generation\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nfrom fastmcp.server.openapi import RouteMap, MCPType\r\nimport httpx\r\n\r\nspec = httpx.get(\"https://api.example.com/openapi.json\").json()\r\n\r\nclient = httpx.AsyncClient(\r\n    base_url=\"https://api.example.com\",\r\n    headers={\"Authorization\": f\"Bearer {API_TOKEN}\"},\r\n    timeout=30.0\r\n)\r\n\r\nmcp = FastMCP.from_openapi(\r\n    openapi_spec=spec,\r\n    client=client,\r\n    name=\"API Server\",\r\n    route_maps=[\r\n        # GET with parameters → Resource Templates\r\n        RouteMap(\r\n            methods=[\"GET\"],\r\n            pattern=r\".*\\{.*\\}.*\",\r\n            mcp_type=MCPType.RESOURCE_TEMPLATE\r\n        ),\r\n        # GET without parameters → Resources\r\n        RouteMap(\r\n            methods=[\"GET\"],\r\n            mcp_type=MCPType.RESOURCE\r\n        ),\r\n        # POST/PUT/DELETE → Tools\r\n        RouteMap(\r\n            methods=[\"POST\", \"PUT\", \"DELETE\"],\r\n            mcp_type=MCPType.TOOL\r\n        ),\r\n    ]\r\n)\r\n\r\n@mcp.tool()\r\nasync def custom_operation(data: dict) -> dict:\r\n    \"\"\"Custom tool on top of generated ones.\"\"\"\r\n    return process_data(data)\r\n```\r\n\r\n### Pattern 3: FastAPI Conversion\r\n\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastmcp import FastMCP\r\n\r\napp = FastAPI()\r\n\r\n@app.get(\"/items/{item_id}\")\r\ndef get_item(item_id: int):\r\n    return {\"id\": item_id, \"name\": \"Item\"}\r\n\r\n\r\n### Critical Requirements\r\n\r\n**❗️ IMPORTANT:** These requirements are mandatory for FastMCP Cloud:\r\n\r\n1. **Module-level server object** named `mcp`, `server`, or `app`\r\n2. **PyPI dependencies only** in requirements.txt\r\n3. **Public GitHub repository** (or accessible to FastMCP Cloud)\r\n4. **Environment variables** for configuration\r\n\r\n### Cloud-Ready Server Pattern\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nimport os\r\n\r\nmcp = FastMCP(\r\n    name=\"production-server\"\r\n)\r\n\r\nAPI_KEY = os.getenv(\"API_KEY\")\r\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\r\n\r\n@mcp.tool()\r\nasync def production_tool(data: str) -> dict:\r\n    \"\"\"Production-ready tool.\"\"\"\r\n    if not API_KEY:\r\n        return {\"error\": \"API_KEY not configured\"}\r\n\r\n    # Your implementation\r\n    return {\"status\": \"success\", \"data\": data}\r\n\r\nif __name__ == \"__main__\":\r\n    mcp.run()\r\n```\r\n\r\n### Common Cloud Deployment Errors\r\n\r\n**❌ WRONG: Function-wrapped server**\r\n```python\r\ndef create_server():\r\n    mcp = FastMCP(\"my-server\")\r\n    return mcp\r\n\r\nif __name__ == \"__main__\":\r\n    server = create_server()  # Too late for cloud!\r\n    server.run()\r\n```\r\n\r\n**✅ CORRECT: Factory with module export**\r\n```python\r\ndef create_server() -> FastMCP:\r\n    mcp = FastMCP(\"my-server\")\r\n    # Complex setup logic\r\n    return mcp\r\n\r\n\r\n### Error 1: Missing Server Object\r\n\r\n**Error:**\r\n```\r\nRuntimeError: No server object found at module level\r\n```\r\n\r\n**Cause:** Server object not exported at module level (FastMCP Cloud requirement)\r\n\r\n**Solution:**\r\n```python\r\ndef create_server():\r\n    return FastMCP(\"server\")\r\n\r\nmcp = FastMCP(\"server\")  # At module level\r\n```\r\n\r\n**Source:** FastMCP Cloud documentation, deployment failures\r\n\r\n---\r\n\r\n### Error 2: Async/Await Confusion\r\n\r\n**Error:**\r\n```\r\nRuntimeError: no running event loop\r\nTypeError: object coroutine can't be used in 'await' expression\r\n```\r\n\r\n**Cause:** Mixing sync/async incorrectly\r\n\r\n**Solution:**\r\n```python\r\n@mcp.tool()\r\ndef bad_tool():\r\n    result = await async_function()  # Error!\r\n\r\n@mcp.tool()\r\nasync def good_tool():\r\n    result = await async_function()\r\n    return result\r\n\r\n@mcp.tool()\r\ndef sync_tool():\r\n    return \"Hello\"\r\n```\r\n\r\n**Source:** GitHub issues #156, #203\r\n\r\n---\r\n\r\n### Error 3: Context Not Injected\r\n\r\n**Error:**\r\n```\r\nTypeError: missing 1 required positional argument: 'context'\r\n```\r\n\r\n**Cause:** Missing `Context` type annotation for context parameter\r\n\r\n**Solution:**\r\n```python\r\nfrom fastmcp import Context\r\n\r\n@mcp.tool()\r\nasync def bad_tool(context):  # Missing type!\r\n    await context.report_progress(...)\r\n\r\n@mcp.tool()\r\nasync def good_tool(context: Context):\r\n    await context.report_progress(0, 100, \"Starting\")\r\n```\r\n\r\n**Source:** FastMCP v2 migration guide\r\n\r\n---\r\n\r\n### Error 4: Resource URI Syntax\r\n\r\n**Error:**\r\n```\r\nValueError: Invalid resource URI: missing scheme\r\n```\r\n\r\n**Cause:** Resource URI missing scheme prefix\r\n\r\n**Solution:**\r\n```python\r\n@mcp.resource(\"config\")\r\ndef get_config(): pass\r\n\r\n@mcp.resource(\"data://config\")\r\ndef get_config(): pass\r\n\r\n@mcp.resource(\"file://config.json\")\r\n@mcp.resource(\"api://status\")\r\n@mcp.resource(\"info://health\")\r\n```\r\n\r\n**Source:** MCP Protocol specification\r\n\r\n---\r\n\r\n### Error 5: Resource Template Parameter Mismatch\r\n\r\n**Error:**\r\n```\r\nTypeError: get_user() missing 1 required positional argument: 'user_id'\r\n```\r\n\r\n**Cause:** Function parameter names don't match URI template\r\n\r\n**Solution:**\r\n```python\r\n@mcp.resource(\"user://{user_id}/profile\")\r\ndef get_user(id: str):  # Wrong name!\r\n    pass\r\n\r\n@mcp.resource(\"user://{user_id}/profile\")\r\ndef get_user(user_id: str):  # Matches {user_id}\r\n    return {\"id\": user_id}\r\n```\r\n\r\n**Source:** FastMCP patterns documentation\r\n\r\n---\r\n\r\n### Error 6: Pydantic Validation Error\r\n\r\n**Error:**\r\n```\r\nValidationError: value is not a valid integer\r\n```\r\n\r\n**Cause:** Type hints don't match provided data\r\n\r\n**Solution:**\r\n```python\r\nfrom pydantic import BaseModel, Field\r\n\r\nclass SearchParams(BaseModel):\r\n    query: str = Field(min_length=1, max_length=100)\r\n    limit: int = Field(default=10, ge=1, le=100)\r\n\r\n@mcp.tool()\r\nasync def search(params: SearchParams) -> dict:\r\n    # Validation automatic\r\n    return await perform_search(params.query, params.limit)\r\n```\r\n\r\n**Source:** Pydantic documentation, FastMCP examples\r\n\r\n---\r\n\r\n### Error 7: Transport/Protocol Mismatch\r\n\r\n**Error:**\r\n```\r\nConnectionError: Server using different transport\r\n```\r\n\r\n**Cause:** Client and server using incompatible transports\r\n\r\n**Solution:**\r\n```python\r\nmcp.run()  # or mcp.run(transport=\"stdio\")\r\n\r\n{\r\n  \"command\": \"python\",\r\n  \"args\": [\"server.py\"]\r\n}\r\n\r\nmcp.run(transport=\"http\", port=8000)\r\n\r\n{\r\n  \"url\": \"http://localhost:8000/mcp\",\r\n  \"transport\": \"http\"\r\n}\r\n```\r\n\r\n**Source:** MCP transport specification\r\n\r\n---\r\n\r\n### Error 8: Import Errors (Editable Package)\r\n\r\n**Error:**\r\n```\r\nModuleNotFoundError: No module named 'my_package'\r\n```\r\n\r\n**Cause:** Package not properly installed in editable mode\r\n\r\n**Solution:**\r\n```bash\r\npip install -e .\r\n\r\nfrom src.tools import my_tool\r\n\r\nexport PYTHONPATH=\"${PYTHONPATH}:/path/to/project\"\r\n```\r\n\r\n**Source:** Python packaging documentation\r\n\r\n---\r\n\r\n### Error 9: Deprecation Warnings\r\n\r\n**Error:**\r\n```\r\nDeprecationWarning: 'mcp.settings' is deprecated, use global Settings instead\r\n```\r\n\r\n**Cause:** Using old FastMCP v1 API\r\n\r\n**Solution:**\r\n```python\r\nfrom fastmcp import FastMCP\r\nmcp = FastMCP()\r\napi_key = mcp.settings.get(\"API_KEY\")\r\n\r\nimport os\r\napi_key = os.getenv(\"API_KEY\")\r\n```\r\n\r\n**Source:** FastMCP v2 migration guide\r\n\r\n---\r\n\r\n### Error 10: Port Already in Use\r\n\r\n**Error:**\r\n```\r\nOSError: [Errno 48] Address already in use\r\n```\r\n\r\n**Cause:** Port 8000 already occupied\r\n\r\n**Solution:**\r\n```bash\r\npython server.py --transport http --port 8001\r\n\r\nlsof -ti:8000 | xargs kill -9\r\n```\r\n\r\n**Source:** Common networking issue\r\n\r\n---\r\n\r\n### Error 11: Schema Generation Failures\r\n\r\n**Error:**\r\n```\r\nTypeError: Object of type 'ndarray' is not JSON serializable\r\n```\r\n\r\n**Cause:** Unsupported type hints (NumPy arrays, custom classes)\r\n\r\n**Solution:**\r\n```python\r\nimport numpy as np\r\n\r\n@mcp.tool()\r\ndef bad_tool() -> np.ndarray:  # Not JSON serializable\r\n    return np.array([1, 2, 3])\r\n\r\n@mcp.tool()\r\ndef good_tool() -> list[float]:\r\n    return [1.0, 2.0, 3.0]\r\n\r\n@mcp.tool()\r\ndef array_tool() -> dict:\r\n    data = np.array([1, 2, 3])\r\n    return {\"values\": data.tolist()}\r\n```\r\n\r\n**Source:** JSON serialization requirements\r\n\r\n---\r\n\r\n### Error 12: JSON Serialization\r\n\r\n**Error:**\r\n```\r\nTypeError: Object of type 'datetime' is not JSON serializable\r\n```\r\n\r\n**Cause:** Returning non-JSON-serializable objects\r\n\r\n**Solution:**\r\n```python\r\nfrom datetime import datetime\r\n\r\n@mcp.tool()\r\ndef bad_tool() -> dict:\r\n    return {\"timestamp\": datetime.now()}  # Not serializable\r\n\r\n@mcp.tool()\r\ndef good_tool() -> dict:\r\n    return {\"timestamp\": datetime.now().isoformat()}\r\n\r\ndef make_serializable(obj):\r\n    \"\"\"Convert object to JSON-serializable format.\"\"\"\r\n    if isinstance(obj, datetime):\r\n        return obj.isoformat()\r\n    elif isinstance(obj, bytes):\r\n        return obj.decode('utf-8')\r\n    # Add more conversions as needed\r\n    return obj\r\n```\r\n\r\n**Source:** JSON specification\r\n\r\n---\r\n\r\n### Error 13: Circular Import Errors\r\n\r\n**Error:**\r\n```\r\nImportError: cannot import name 'X' from partially initialized module\r\n```\r\n\r\n**Cause:** Modules import from each other creating circular dependency (common in cloud deployment)\r\n\r\n**Solution:**\r\n```python\r\n_client = None\r\ndef get_api_client():\r\n    from .api_client import APIClient  # Circular!\r\n    return APIClient()\r\n\r\nfrom . import get_api_client  # Creates circle\r\n\r\nfrom .api_client import APIClient\r\nfrom .cache import CacheManager\r\n\r\nfrom .api_client import APIClient\r\nclient = APIClient()  # Create directly\r\n\r\ndef get_client():\r\n    from .api_client import APIClient\r\n    return APIClient()\r\n```\r\n\r\n**Source:** Production cloud deployment errors, Python import system\r\n\r\n---\r\n\r\n### Error 14: Python Version Compatibility\r\n\r\n**Error:**\r\n```\r\nDeprecationWarning: datetime.utcnow() is deprecated\r\n```\r\n\r\n**Cause:** Using deprecated Python 3.12+ methods\r\n\r\n**Solution:**\r\n```python\r\nfrom datetime import datetime\r\ntimestamp = datetime.utcnow()\r\n\r\nfrom datetime import datetime, timezone\r\ntimestamp = datetime.now(timezone.utc)\r\n```\r\n\r\n**Source:** Python 3.12 release notes\r\n\r\n---\r\n\r\n### Error 15: Import-Time Execution\r\n\r\n**Error:**\r\n```\r\nRuntimeError: Event loop is closed\r\n```\r\n\r\n**Cause:** Creating async resources at module import time\r\n\r\n**Solution:**\r\n```python\r\nimport asyncpg\r\nconnection = asyncpg.connect('postgresql://...')  # Runs at import!\r\n\r\nimport asyncpg\r\n\r\nclass Database:\r\n    connection = None\r\n\r\n    @classmethod\r\n    async def connect(cls):\r\n        if cls.connection is None:\r\n            cls.connection = await asyncpg.connect('postgresql://...')\r\n        return cls.connection\r\n\r\n@mcp.tool()\r\nasync def get_users():\r\n    conn = await Database.connect()\r\n    return await conn.fetch(\"SELECT * FROM users\")\r\n```\r\n\r\n**Source:** Async event loop management, cloud deployment requirements\r\n\r\n---\r\n\r\n### Error 16: Storage Backend Not Configured\r\n\r\n**Error:**\r\n```\r\nRuntimeError: OAuth tokens lost on restart\r\nValueError: Cache not persisting across server instances\r\n```\r\n\r\n**Cause:** Using default memory storage in production without persistence\r\n\r\n**Solution:**\r\n```python\r\nmcp = FastMCP(\"Production Server\")  # Tokens lost on restart!\r\n\r\nfrom key_value.stores import DiskStore, RedisStore\r\nfrom key_value.encryption import FernetEncryptionWrapper\r\nfrom cryptography.fernet import Fernet\r\n\r\nmcp = FastMCP(\r\n    \"Production Server\",\r\n    storage=FernetEncryptionWrapper(\r\n        key_value=DiskStore(path=\"/var/lib/mcp/storage\"),\r\n        fernet=Fernet(os.getenv(\"STORAGE_ENCRYPTION_KEY\"))\r\n    )\r\n)\r\n\r\nmcp = FastMCP(\r\n    \"Production Server\",\r\n    storage=FernetEncryptionWrapper(\r\n        key_value=RedisStore(\r\n            host=os.getenv(\"REDIS_HOST\"),\r\n            password=os.getenv(\"REDIS_PASSWORD\")\r\n        ),\r\n        fernet=Fernet(os.getenv(\"STORAGE_ENCRYPTION_KEY\"))\r\n    )\r\n)\r\n```\r\n\r\n**Source:** FastMCP v2.13.0 storage backends documentation\r\n\r\n---\r\n\r\n### Error 17: Lifespan Not Passed to ASGI App\r\n\r\n**Error:**\r\n```\r\nRuntimeError: Database connection never initialized\r\nWarning: MCP lifespan hooks not running\r\n```\r\n\r\n**Cause:** Using FastMCP with FastAPI/Starlette without passing lifespan\r\n\r\n**Solution:**\r\n```python\r\nfrom fastapi import FastAPI\r\nfrom fastmcp import FastMCP\r\n\r\nmcp = FastMCP(\"My Server\", lifespan=my_lifespan)\r\napp = FastAPI()  # MCP lifespan won't run!\r\n\r\nmcp = FastMCP(\"My Server\", lifespan=my_lifespan)\r\napp = FastAPI(lifespan=mcp.lifespan)\r\n```\r\n\r\n**Source:** FastMCP v2.13.0 breaking changes, ASGI integration guide\r\n\r\n---\r\n\r\n### Error 18: Middleware Execution Order Error\r\n\r\n**Error:**\r\n```\r\nRuntimeError: Rate limit not checked before caching\r\nAttributeError: Context state not available in middleware\r\n```\r\n\r\n**Cause:** Incorrect middleware ordering (order matters!)\r\n\r\n**Solution:**\r\n```python\r\nmcp.add_middleware(ResponseCachingMiddleware())\r\nmcp.add_middleware(RateLimitingMiddleware())  # Too late!\r\n\r\nmcp.add_middleware(ErrorHandlingMiddleware())  # First: catch errors\r\nmcp.add_middleware(TimingMiddleware())         # Second: time requests\r\nmcp.add_middleware(LoggingMiddleware())        # Third: log\r\nmcp.add_middleware(RateLimitingMiddleware())   # Fourth: check limits\r\nmcp.add_middleware(ResponseCachingMiddleware()) # Last: cache\r\n```\r\n\r\n**Source:** FastMCP middleware documentation, best practices\r\n\r\n---\r\n\r\n### Error 19: Circular Middleware Dependencies\r\n\r\n**Error:**\r\n```\r\nRecursionError: maximum recursion depth exceeded\r\nRuntimeError: Middleware loop detected\r\n```\r\n\r\n**Cause:** Middleware calling `self.next()` incorrectly or circular dependencies\r\n\r\n**Solution:**\r\n```python\r\nclass BadMiddleware(BaseMiddleware):\r\n    async def on_call_tool(self, tool_name, arguments, context):\r\n        # Forgot to call next()!\r\n        return {\"error\": \"blocked\"}\r\n\r\nclass GoodMiddleware(BaseMiddleware):\r\n    async def on_call_tool(self, tool_name, arguments, context):\r\n        # Do preprocessing\r\n        print(f\"Before: {tool_name}\")\r\n\r\n        # MUST call next() to continue\r\n        result = await self.next(tool_name, arguments, context)\r\n\r\n        # Do postprocessing\r\n        print(f\"After: {tool_name}\")\r\n        return result\r\n```\r\n\r\n**Source:** FastMCP middleware system documentation\r\n\r\n---\r\n\r\n### Error 20: Import vs Mount Confusion\r\n\r\n**Error:**\r\n```\r\nRuntimeError: Subserver changes not reflected\r\nValueError: Unexpected tool namespacing\r\n```\r\n\r\n**Cause:** Using `import_server()` when `mount()` was needed (or vice versa)\r\n\r\n**Solution:**\r\n```python\r\nmain_server.import_server(subserver)\r\n\r\nmain_server.mount(subserver, prefix=\"sub\")\r\n\r\nmain_server.mount(third_party_server, prefix=\"vendor\")\r\n\r\nmain_server.import_server(third_party_server)\r\n```\r\n\r\n**Source:** FastMCP server composition patterns\r\n\r\n---\r\n\r\n### Error 21: Resource Prefix Format Mismatch\r\n\r\n**Error:**\r\n```\r\nValueError: Resource not found: resource://api/users\r\nValueError: Unexpected resource URI format\r\n```\r\n\r\n**Cause:** Using wrong resource prefix format (path vs protocol)\r\n\r\n**Solution:**\r\n```python\r\nmain_server.mount(api_server, prefix=\"api\")\r\n\r\n\r\nuri = \"resource://api/users\"\r\n\r\nmain_server.mount(\r\n    api_server,\r\n    prefix=\"api\",\r\n    resource_prefix_format=\"protocol\"\r\n)\r\n```\r\n\r\n**Source:** FastMCP v2.4.0+ resource prefix changes\r\n\r\n---\r\n\r\n### Error 22: OAuth Proxy Without Consent Screen\r\n\r\n**Error:**\r\n```\r\nSecurityWarning: Authorization bypass possible\r\nRuntimeError: Confused deputy attack vector\r\n```\r\n\r\n**Cause:** OAuth Proxy configured without consent screen (security vulnerability)\r\n\r\n**Solution:**\r\n```python\r\nauth = OAuthProxy(\r\n    jwt_signing_key=os.getenv(\"JWT_KEY\"),\r\n    upstream_authorization_endpoint=\"...\",\r\n    upstream_token_endpoint=\"...\",\r\n    # Missing: enable_consent_screen\r\n)\r\n\r\nauth = OAuthProxy(\r\n    jwt_signing_key=os.getenv(\"JWT_KEY\"),\r\n    upstream_authorization_endpoint=\"...\",\r\n    upstream_token_endpoint=\"...\",\r\n    enable_consent_screen=True  # Prevents bypass attacks\r\n)\r\n```\r\n\r\n**Source:** FastMCP v2.13.0 OAuth security enhancements, RFC 7662\r\n\r\n---\r\n\r\n### Error 23: Missing JWT Signing Key in Production\r\n\r\n**Error:**\r\n```\r\nValueError: JWT signing key required for OAuth Proxy\r\nRuntimeError: Cannot issue tokens without signing key\r\n```\r\n\r\n**Cause:** OAuth Proxy missing `jwt_signing_key` in production\r\n\r\n**Solution:**\r\n```python\r\nauth = OAuthProxy(\r\n    upstream_authorization_endpoint=\"...\",\r\n    upstream_token_endpoint=\"...\",\r\n    # Missing: jwt_signing_key\r\n)\r\n\r\nimport secrets\r\n\r\n\r\nauth = OAuthProxy(\r\n    jwt_signing_key=os.environ[\"FASTMCP_JWT_SIGNING_KEY\"],\r\n    client_storage=encrypted_storage,\r\n    upstream_authorization_endpoint=\"...\",\r\n    upstream_token_endpoint=\"...\",\r\n    upstream_client_id=os.getenv(\"OAUTH_CLIENT_ID\"),\r\n    upstream_client_secret=os.getenv(\"OAUTH_CLIENT_SECRET\")\r\n)\r\n```\r\n\r\n**Source:** OAuth Proxy production requirements\r\n\r\n---\r\n\r\n### Error 24: Icon Data URI Format Error\r\n\r\n**Error:**\r\n```\r\nValueError: Invalid data URI format\r\nTypeError: Icon URL must be string or data URI\r\n```\r\n\r\n**Cause:** Incorrectly formatted data URI for icons\r\n\r\n**Solution:**\r\n```python\r\nfrom fastmcp import Icon, Image\r\n\r\nicon = Icon(url=\"base64,iVBORw0KG...\")  # Missing data:image/png;\r\n\r\nicon = Icon.from_file(\"/path/to/icon.png\", size=\"medium\")\r\n\r\nimport base64\r\n\r\nwith open(\"/path/to/icon.png\", \"rb\") as f:\r\n    image_data = base64.b64encode(f.read()).decode()\r\n    data_uri = f\"data:image/png;base64,{image_data}\"\r\n    icon = Icon(url=data_uri, size=\"medium\")\r\n```\r\n\r\n**Source:** FastMCP icons documentation, Data URI specification\r\n\r\n---\r\n\r\n### Error 25: Lifespan Behavior Change (v2.13.0)\r\n\r\n**Error:**\r\n```\r\nWarning: Lifespan runs per-server, not per-session\r\nRuntimeError: Resources initialized multiple times\r\n```\r\n\r\n**Cause:** Expecting v2.12 lifespan behavior (per-session) in v2.13.0+ (per-server)\r\n\r\n**Solution:**\r\n```python\r\n\r\n@asynccontextmanager\r\nasync def app_lifespan(server: FastMCP):\r\n    \"\"\"Runs ONCE when server starts, not per client session.\"\"\"\r\n    db = await Database.connect()\r\n    print(\"Server starting - runs once\")\r\n\r\n    try:\r\n        yield {\"db\": db}\r\n    finally:\r\n        await db.disconnect()\r\n        print(\"Server stopping - runs once\")\r\n\r\nmcp = FastMCP(\"My Server\", lifespan=app_lifespan)\r\n\r\n\r\n### Pattern 1: Self-Contained Utils Module\r\n\r\nBest practice for maintaining all utilities in one place:\r\n\r\n```python\r\nimport os\r\nfrom typing import Dict, Any\r\nfrom datetime import datetime\r\n\r\nclass Config:\r\n    \"\"\"Application configuration.\"\"\"\r\n    SERVER_NAME = os.getenv(\"SERVER_NAME\", \"FastMCP Server\")\r\n    SERVER_VERSION = \"1.0.0\"\r\n    API_BASE_URL = os.getenv(\"API_BASE_URL\")\r\n    API_KEY = os.getenv(\"API_KEY\")\r\n    CACHE_TTL = int(os.getenv(\"CACHE_TTL\", \"300\"))\r\n\r\ndef format_success(data: Any, message: str = \"Success\") -> Dict[str, Any]:\r\n    \"\"\"Format successful response.\"\"\"\r\n    return {\r\n        \"success\": True,\r\n        \"message\": message,\r\n        \"data\": data,\r\n        \"timestamp\": datetime.now().isoformat()\r\n    }\r\n\r\ndef format_error(error: str, code: str = \"ERROR\") -> Dict[str, Any]:\r\n    \"\"\"Format error response.\"\"\"\r\n    return {\r\n        \"success\": False,\r\n        \"error\": error,\r\n        \"code\": code,\r\n        \"timestamp\": datetime.now().isoformat()\r\n    }\r\n\r\n\r\n**Development:**\r\n```bash\r\nfastmcp dev server.py\r\n\r\nfastmcp run server.py\r\n\r\nfastmcp inspect server.py\r\n```\r\n\r\n**Installation:**\r\n```bash\r\nfastmcp install server.py\r\n\r\nfastmcp install server.py --name \"My Server\"\r\n```\r\n\r\n**Debugging:**\r\n```bash\r\nFASTMCP_LOG_LEVEL=DEBUG fastmcp dev server.py\r\n\r\n\r\n### 1. Server Structure\r\n\r\n```python\r\nfrom fastmcp import FastMCP\r\nimport os\r\n\r\ndef create_server() -> FastMCP:\r\n    \"\"\"Factory function for complex setup.\"\"\"\r\n    mcp = FastMCP(\"Server Name\")\r\n\r\n    # Configure server\r\n    setup_tools(mcp)\r\n    setup_resources(mcp)\r\n\r\n    return mcp\r\n\r\ndef setup_tools(mcp: FastMCP):\r\n    \"\"\"Register all tools.\"\"\"\r\n    @mcp.tool()\r\n    def example_tool():\r\n        pass\r\n\r\ndef setup_resources(mcp: FastMCP):\r\n    \"\"\"Register all resources.\"\"\"\r\n    @mcp.resource(\"data://config\")\r\n    def get_config():\r\n        return {\"version\": \"1.0.0\"}\r\n\r\nmcp = create_server()\r\n\r\nif __name__ == \"__main__\":\r\n    mcp.run()\r\n```\r\n\r\n### 2. Environment Configuration\r\n\r\n```python\r\nimport os\r\nfrom dotenv import load_dotenv\r\n\r\nload_dotenv()\r\n\r\nclass Config:\r\n    API_KEY = os.getenv(\"API_KEY\", \"\")\r\n    BASE_URL = os.getenv(\"BASE_URL\", \"https://api.example.com\")\r\n    DEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\r\n\r\n    @classmethod\r\n    def validate(cls):\r\n        if not cls.API_KEY:\r\n            raise ValueError(\"API_KEY is required\")\r\n        return True",
  "name": "fastmcp",
  "id": "fastmcp",
  "sections": {
    "API Integration": "mcp = FastMCP.from_fastapi(\r\n    app=app,\r\n    httpx_client_kwargs={\r\n        \"headers\": {\"Authorization\": \"Bearer token\"}\r\n    }\r\n)\r\n```",
    "CLI Commands": "fastmcp run server.py --transport http --port 8000\r\n```",
    "Storage Backends": "from key_value.stores import DiskStore\r\n\r\nmcp = FastMCP(\r\n    \"My Server\",\r\n    storage=DiskStore(path=\"/var/lib/mcp/storage\")\r\n)\r\n```",
    "References": "**Official Documentation:**\r\n- FastMCP: https://github.com/jlowin/fastmcp\r\n- FastMCP Cloud: https://fastmcp.cloud\r\n- MCP Protocol: https://modelcontextprotocol.io\r\n- Context7 Docs: `/jlowin/fastmcp`\r\n\r\n**Related Skills:**\r\n- `openai-api` - OpenAI integration\r\n- `claude-api` - Claude API\r\n- `cloudflare-worker-base` - Deploy MCP as Worker\r\n\r\n**Package Versions:**\r\n- fastmcp >= 2.13.0\r\n- Python >= 3.10\r\n- httpx (recommended for async API calls)\r\n- pydantic (for validation)\r\n- py-key-value-aio (for storage backends)\r\n- cryptography (for encrypted storage)",
    "25 Common Errors (With Solutions)": "class SessionMiddleware(BaseMiddleware):\r\n    async def on_message(self, message, context):\r\n        # Runs per client message\r\n        session_id = context.fastmcp_context.get_state(\"session_id\")\r\n        if not session_id:\r\n            session_id = str(uuid.uuid4())\r\n            context.fastmcp_context.set_state(\"session_id\", session_id)\r\n\r\n        return await self.next(message, context)\r\n```\r\n\r\n**Source:** FastMCP v2.13.0 release notes, breaking changes documentation\r\n\r\n---",
    "Server Composition": "main_server.mount(\r\n    api_server,\r\n    prefix=\"api\",\r\n    include_tags=[\"public\"]\r\n)\r\n```\r\n\r\n### Resource Prefix Formats\r\n\r\n**Path Format (Default since v2.4.0)**:\r\n```\r\nresource://prefix/path/to/resource\r\n```\r\n\r\n**Protocol Format (Legacy)**:\r\n```\r\nprefix+resource://path/to/resource\r\n```\r\n\r\nConfigure format:\r\n\r\n```python\r\nmain_server.mount(\r\n    subserver,\r\n    prefix=\"api\",\r\n    resource_prefix_format=\"path\"  # or \"protocol\"\r\n)\r\n```",
    "Testing": "### Unit Testing Tools\r\n\r\n```python\r\nimport pytest\r\nfrom fastmcp import FastMCP\r\nfrom fastmcp.testing import create_test_client\r\n\r\n@pytest.fixture\r\ndef test_server():\r\n    \"\"\"Create test server instance.\"\"\"\r\n    mcp = FastMCP(\"test-server\")\r\n\r\n    @mcp.tool()\r\n    async def test_tool(param: str) -> str:\r\n        return f\"Result: {param}\"\r\n\r\n    return mcp\r\n\r\n@pytest.mark.asyncio\r\nasync def test_tool_execution(test_server):\r\n    \"\"\"Test tool execution.\"\"\"\r\n    async with create_test_client(test_server) as client:\r\n        result = await client.call_tool(\"test_tool\", {\"param\": \"test\"})\r\n        assert result.data == \"Result: test\"\r\n```\r\n\r\n### Integration Testing\r\n\r\n```python\r\nimport asyncio\r\nfrom fastmcp import Client\r\n\r\nasync def test_server():\r\n    \"\"\"Test all server functionality.\"\"\"\r\n    async with Client(\"server.py\") as client:\r\n        # Test tools\r\n        tools = await client.list_tools()\r\n        print(f\"Tools: {len(tools)}\")\r\n\r\n        for tool in tools:\r\n            try:\r\n                result = await client.call_tool(tool.name, {})\r\n                print(f\"✓ {tool.name}: {result}\")\r\n            except Exception as e:\r\n                print(f\"✗ {tool.name}: {e}\")\r\n\r\n        # Test resources\r\n        resources = await client.list_resources()\r\n        for resource in resources:\r\n            try:\r\n                data = await client.read_resource(resource.uri)\r\n                print(f\"✓ {resource.uri}\")\r\n            except Exception as e:\r\n                print(f\"✗ {resource.uri}: {e}\")\r\n\r\nif __name__ == \"__main__\":\r\n    asyncio.run(test_server())\r\n```",
    "Core Concepts": "@mcp.resource(\"org://{org_id}/team/{team_id}/members\")\r\nasync def get_team_members(org_id: str, team_id: str) -> list:\r\n    \"\"\"Get team members with org context.\"\"\"\r\n    return await db.query(\r\n        \"SELECT * FROM members WHERE org_id = ? AND team_id = ?\",\r\n        [org_id, team_id]\r\n    )\r\n```\r\n\r\n**Critical:** Parameter names must match exactly between URI template and function signature.\r\n\r\n### 4. Prompts\r\n\r\nPre-configured prompts for LLMs:\r\n\r\n```python\r\n@mcp.prompt(\"analyze\")\r\ndef analyze_prompt(topic: str) -> str:\r\n    \"\"\"Generate analysis prompt.\"\"\"\r\n    return f\"\"\"\r\n    Analyze {topic} considering:\r\n    1. Current state\r\n    2. Challenges\r\n    3. Opportunities\r\n    4. Recommendations\r\n\r\n    Use available tools to gather data.\r\n    \"\"\"\r\n\r\n@mcp.prompt(\"help\")\r\ndef help_prompt() -> str:\r\n    \"\"\"Generate help text for server.\"\"\"\r\n    return \"\"\"\r\n    Welcome to My Server!\r\n\r\n    Available tools:\r\n    - search: Search for items\r\n    - process: Process data\r\n\r\n    Available resources:\r\n    - info://status: Server status\r\n    \"\"\"\r\n```",
    "Quick Start": "python server.py --transport http --port 8000\r\n```",
    "Cloud Deployment (FastMCP Cloud)": "mcp = create_server()\r\n\r\nif __name__ == \"__main__\":\r\n    mcp.run()\r\n```\r\n\r\n### Deployment Steps\r\n\r\n1. **Prepare Repository:**\r\n```bash\r\ngit init\r\ngit add .\r\ngit commit -m \"Initial MCP server\"\r\ngh repo create my-mcp-server --public\r\ngit push -u origin main\r\n```\r\n\r\n2. **Deploy on FastMCP Cloud:**\r\n   - Visit https://fastmcp.cloud\r\n   - Sign in with GitHub\r\n   - Click \"Create Project\"\r\n   - Select your repository\r\n   - Configure:\r\n     - **Server Name**: Your project name\r\n     - **Entrypoint**: `server.py`\r\n     - **Environment Variables**: Add any needed\r\n\r\n3. **Access Your Server:**\r\n   - URL: `https://your-project.fastmcp.app/mcp`\r\n   - Automatic deployment on push to main\r\n   - PR preview deployments",
    "OAuth Proxy & Authentication": "mcp = FastMCP(\"Auto Auth Server\")\r\n```\r\n\r\n### Supported OAuth Providers\r\n\r\n- **GitHub**: `https://github.com/login/oauth/authorize`\r\n- **Google**: `https://accounts.google.com/o/oauth2/v2/auth`\r\n- **Azure**: `https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize`\r\n- **AWS Cognito**: `https://{domain}.auth.{region}.amazoncognito.com/oauth2/authorize`\r\n- **Discord**: `https://discord.com/api/oauth2/authorize`\r\n- **Facebook**: `https://www.facebook.com/v12.0/dialog/oauth`\r\n- **WorkOS**: Enterprise identity\r\n- **AuthKit**: Authentication toolkit\r\n- **Descope**: Auth platform\r\n- **Scalekit**: Enterprise SSO",
    "Client Configuration": "### Claude Desktop\r\n\r\nAdd to `claude_desktop_config.json`:\r\n\r\n```json\r\n{\r\n  \"mcpServers\": {\r\n    \"my-server\": {\r\n      \"url\": \"https://your-project.fastmcp.app/mcp\",\r\n      \"transport\": \"http\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Local Development\r\n\r\n```json\r\n{\r\n  \"mcpServers\": {\r\n    \"my-server\": {\r\n      \"command\": \"python\",\r\n      \"args\": [\"/absolute/path/to/server.py\"],\r\n      \"env\": {\r\n        \"API_KEY\": \"your-key\",\r\n        \"DATABASE_URL\": \"your-db-url\"\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Claude Code CLI\r\n\r\n```json\r\n{\r\n  \"mcpServers\": {\r\n    \"my-server\": {\r\n      \"command\": \"uv\",\r\n      \"args\": [\"run\", \"python\", \"/absolute/path/to/server.py\"]\r\n    }\r\n  }\r\n}\r\n```",
    "Icons Support": "mcp = FastMCP(\r\n    \"My Server\",\r\n    icons=[icon]\r\n)\r\n```\r\n\r\n### Multiple Sizes\r\n\r\nProvide different sizes for different contexts:\r\n\r\n```python\r\nmcp = FastMCP(\r\n    \"Responsive Server\",\r\n    icons=[\r\n        Icon(url=\"icon-16.png\", size=\"small\"),    # 16x16\r\n        Icon(url=\"icon-32.png\", size=\"medium\"),   # 32x32\r\n        Icon(url=\"icon-64.png\", size=\"large\"),    # 64x64\r\n    ]\r\n)\r\n```",
    "Best Practices": "Config.validate()\r\n```\r\n\r\n### 3. Documentation\r\n\r\n```python\r\n@mcp.tool()\r\ndef complex_tool(\r\n    query: str,\r\n    filters: dict = None,\r\n    limit: int = 10\r\n) -> dict:\r\n    \"\"\"\r\n    Search with advanced filtering.\r\n\r\n    Args:\r\n        query: Search query string\r\n        filters: Optional filters dict with keys:\r\n            - category: Filter by category\r\n            - date_from: Start date (ISO format)\r\n            - date_to: End date (ISO format)\r\n        limit: Maximum results (1-100)\r\n\r\n    Returns:\r\n        Dict with 'results' list and 'total' count\r\n\r\n    Examples:\r\n        >>> complex_tool(\"python\", {\"category\": \"tutorial\"}, 5)\r\n        {'results': [...], 'total': 5}\r\n    \"\"\"\r\n    pass\r\n```\r\n\r\n### 4. Health Checks\r\n\r\n```python\r\n@mcp.resource(\"health://status\")\r\nasync def health_check() -> dict:\r\n    \"\"\"Comprehensive health check.\"\"\"\r\n    checks = {}\r\n\r\n    # Check API connectivity\r\n    try:\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.get(f\"{BASE_URL}/health\", timeout=5)\r\n            checks[\"api\"] = response.status_code == 200\r\n    except:\r\n        checks[\"api\"] = False\r\n\r\n    # Check database\r\n    try:\r\n        checks[\"database\"] = await check_db_connection()\r\n    except:\r\n        checks[\"database\"] = False\r\n\r\n    all_healthy = all(checks.values())\r\n\r\n    return {\r\n        \"status\": \"healthy\" if all_healthy else \"degraded\",\r\n        \"timestamp\": datetime.now().isoformat(),\r\n        \"checks\": checks\r\n    }\r\n```",
    "Summary": "FastMCP enables rapid development of production-ready MCP servers with advanced features for storage, authentication, middleware, and composition. Key takeaways:\r\n\r\n1. **Always export server at module level** for FastMCP Cloud compatibility\r\n2. **Use persistent storage backends** (Disk/Redis) in production for OAuth tokens and caching\r\n3. **Configure server lifespans** for proper resource management (DB connections, API clients)\r\n4. **Add middleware strategically** - order matters! (errors → timing → logging → rate limiting → caching)\r\n5. **Choose composition wisely** - `import_server()` for static bundles, `mount()` for dynamic composition\r\n6. **Secure OAuth properly** - Enable consent screens, encrypt token storage, use JWT signing keys\r\n7. **Use async/await properly** - don't block the event loop\r\n8. **Handle errors gracefully** with structured responses and ErrorHandlingMiddleware\r\n9. **Avoid circular imports** especially with factory functions\r\n10. **Test locally before deploying** using `fastmcp dev`\r\n11. **Use environment variables** for all configuration (never hardcode secrets)\r\n12. **Document thoroughly** - LLMs read your docstrings\r\n13. **Follow production patterns** for self-contained, maintainable code\r\n14. **Leverage OpenAPI** for instant API integration\r\n15. **Monitor with health checks** and middleware for production reliability\r\n\r\n**Production Readiness:**\r\n- **Storage**: Encrypted persistence for OAuth tokens and response caching\r\n- **Authentication**: 4 auth patterns (Token Validation, Remote OAuth, OAuth Proxy, Full OAuth)\r\n- **Middleware**: 8 built-in types for logging, rate limiting, caching, error handling\r\n- **Composition**: Modular server architecture with import/mount strategies\r\n- **Security**: Consent screens, PKCE, RFC 7662 token introspection, encrypted storage\r\n- **Performance**: Response caching, connection pooling, timing middleware\r\n\r\nThis skill prevents 25+ common errors and provides 90-95% token savings compared to manual implementation.",
    "Project Structure": "### Simple Server\r\n\r\n```\r\nmy-mcp-server/\r\n├── server.py          # Main server file\r\n├── requirements.txt   # Dependencies\r\n├── .env              # Environment variables (git-ignored)\r\n├── .gitignore        # Git ignore file\r\n└── README.md         # Documentation\r\n```\r\n\r\n### Production Server\r\n\r\n```\r\nmy-mcp-server/\r\n├── src/\r\n│   ├── server.py         # Main entry point\r\n│   ├── utils.py          # Shared utilities\r\n│   ├── tools/           # Tool modules\r\n│   │   ├── __init__.py\r\n│   │   ├── api_tools.py\r\n│   │   └── data_tools.py\r\n│   ├── resources/       # Resource definitions\r\n│   │   ├── __init__.py\r\n│   │   └── static.py\r\n│   └── prompts/         # Prompt templates\r\n│       ├── __init__.py\r\n│       └── templates.py\r\n├── tests/\r\n│   ├── test_tools.py\r\n│   └── test_resources.py\r\n├── requirements.txt\r\n├── pyproject.toml\r\n├── .env\r\n├── .gitignore\r\n└── README.md\r\n```",
    "Server Lifespans": "@app.get(\"/\")\r\ndef root():\r\n    return {\"message\": \"Hello World\"}\r\n```\r\n\r\n**❌ WRONG**: Not passing lifespan to parent app\r\n```python\r\napp = FastAPI()  # MCP lifespan won't run!\r\n```\r\n\r\n**✅ CORRECT**: Pass MCP lifespan to parent app\r\n```python\r\napp = FastAPI(lifespan=mcp.lifespan)\r\n```\r\n\r\n### State Management\r\n\r\nStore and retrieve state during server lifetime:\r\n\r\n```python\r\nfrom fastmcp import Context\r\n\r\n@mcp.tool()\r\nasync def set_config(key: str, value: str, context: Context) -> dict:\r\n    \"\"\"Store configuration value.\"\"\"\r\n    context.fastmcp_context.set_state(key, value)\r\n    return {\"status\": \"saved\", \"key\": key}\r\n\r\n@mcp.tool()\r\nasync def get_config(key: str, context: Context) -> dict:\r\n    \"\"\"Retrieve configuration value.\"\"\"\r\n    value = context.fastmcp_context.get_state(key, default=None)\r\n    if value is None:\r\n        return {\"error\": f\"Key '{key}' not found\"}\r\n    return {\"key\": key, \"value\": value}\r\n```",
    "Middleware System": "@mcp.tool()\r\nasync def expensive_computation(data: str) -> dict:\r\n    \"\"\"This will be cached for 5 minutes.\"\"\"\r\n    import time\r\n    time.sleep(5)  # Expensive operation\r\n    return {\"result\": process(data)}\r\n```",
    "Context Features": "FastMCP provides advanced features through context injection:\r\n\r\n### 1. Elicitation (User Input)\r\n\r\nRequest user input during tool execution:\r\n\r\n```python\r\nfrom fastmcp import Context\r\n\r\n@mcp.tool()\r\nasync def confirm_action(action: str, context: Context) -> dict:\r\n    \"\"\"Perform action with user confirmation.\"\"\"\r\n    # Request confirmation from user\r\n    confirmed = await context.request_elicitation(\r\n        prompt=f\"Confirm {action}? (yes/no)\",\r\n        response_type=str\r\n    )\r\n\r\n    if confirmed.lower() == \"yes\":\r\n        result = await perform_action(action)\r\n        return {\"status\": \"completed\", \"action\": action}\r\n    else:\r\n        return {\"status\": \"cancelled\", \"action\": action}\r\n```\r\n\r\n### 2. Progress Tracking\r\n\r\nReport progress for long-running operations:\r\n\r\n```python\r\n@mcp.tool()\r\nasync def batch_import(file_path: str, context: Context) -> dict:\r\n    \"\"\"Import data with progress updates.\"\"\"\r\n    data = await read_file(file_path)\r\n    total = len(data)\r\n\r\n    imported = []\r\n    for i, item in enumerate(data):\r\n        # Report progress\r\n        await context.report_progress(\r\n            progress=i + 1,\r\n            total=total,\r\n            message=f\"Importing item {i + 1}/{total}\"\r\n        )\r\n\r\n        result = await import_item(item)\r\n        imported.append(result)\r\n\r\n    return {\"imported\": len(imported), \"total\": total}\r\n```\r\n\r\n### 3. Sampling (LLM Integration)\r\n\r\nRequest LLM completions from within tools:\r\n\r\n```python\r\n@mcp.tool()\r\nasync def enhance_text(text: str, context: Context) -> str:\r\n    \"\"\"Enhance text using LLM.\"\"\"\r\n    response = await context.request_sampling(\r\n        messages=[{\r\n            \"role\": \"system\",\r\n            \"content\": \"You are a professional copywriter.\"\r\n        }, {\r\n            \"role\": \"user\",\r\n            \"content\": f\"Enhance this text: {text}\"\r\n        }],\r\n        temperature=0.7,\r\n        max_tokens=500\r\n    )\r\n\r\n    return response[\"content\"]\r\n```",
    "Production Patterns": "from .utils import format_success, format_error, Config\r\n\r\n@mcp.tool()\r\nasync def process_data(data: dict) -> dict:\r\n    try:\r\n        result = await process(data)\r\n        return format_success(result)\r\n    except Exception as e:\r\n        return format_error(str(e))\r\n```\r\n\r\n### Pattern 2: Connection Pooling\r\n\r\nEfficient resource management:\r\n\r\n```python\r\nimport httpx\r\nfrom typing import Optional\r\n\r\nclass APIClient:\r\n    _instance: Optional[httpx.AsyncClient] = None\r\n\r\n    @classmethod\r\n    async def get_client(cls) -> httpx.AsyncClient:\r\n        if cls._instance is None:\r\n            cls._instance = httpx.AsyncClient(\r\n                base_url=os.getenv(\"API_BASE_URL\"),\r\n                headers={\"Authorization\": f\"Bearer {os.getenv('API_KEY')}\"},\r\n                timeout=httpx.Timeout(30.0),\r\n                limits=httpx.Limits(max_keepalive_connections=5)\r\n            )\r\n        return cls._instance\r\n\r\n    @classmethod\r\n    async def cleanup(cls):\r\n        if cls._instance:\r\n            await cls._instance.aclose()\r\n            cls._instance = None\r\n\r\n@mcp.tool()\r\nasync def api_request(endpoint: str) -> dict:\r\n    \"\"\"Make API request with managed client.\"\"\"\r\n    client = await APIClient.get_client()\r\n    response = await client.get(endpoint)\r\n    return response.json()\r\n```\r\n\r\n### Pattern 3: Error Handling with Retry\r\n\r\nResilient API calls:\r\n\r\n```python\r\nimport asyncio\r\nfrom typing import Callable, TypeVar\r\n\r\nT = TypeVar('T')\r\n\r\nasync def retry_with_backoff(\r\n    func: Callable[[], T],\r\n    max_retries: int = 3,\r\n    initial_delay: float = 1.0,\r\n    exponential_base: float = 2.0\r\n) -> T:\r\n    \"\"\"Retry function with exponential backoff.\"\"\"\r\n    delay = initial_delay\r\n    last_exception = None\r\n\r\n    for attempt in range(max_retries):\r\n        try:\r\n            return await func()\r\n        except Exception as e:\r\n            last_exception = e\r\n            if attempt < max_retries - 1:\r\n                await asyncio.sleep(delay)\r\n                delay *= exponential_base\r\n\r\n    raise last_exception\r\n\r\n@mcp.tool()\r\nasync def resilient_api_call(endpoint: str) -> dict:\r\n    \"\"\"API call with automatic retry.\"\"\"\r\n    async def make_call():\r\n        async with httpx.AsyncClient() as client:\r\n            response = await client.get(endpoint)\r\n            response.raise_for_status()\r\n            return response.json()\r\n\r\n    try:\r\n        data = await retry_with_backoff(make_call)\r\n        return {\"success\": True, \"data\": data}\r\n    except Exception as e:\r\n        return {\"error\": f\"Failed after retries: {e}\"}\r\n```\r\n\r\n### Pattern 4: Time-Based Caching\r\n\r\nReduce API load:\r\n\r\n```python\r\nimport time\r\nfrom typing import Any, Optional\r\n\r\nclass TimeBasedCache:\r\n    def __init__(self, ttl: int = 300):\r\n        self.ttl = ttl\r\n        self.cache = {}\r\n        self.timestamps = {}\r\n\r\n    def get(self, key: str) -> Optional[Any]:\r\n        if key in self.cache:\r\n            if time.time() - self.timestamps[key] < self.ttl:\r\n                return self.cache[key]\r\n            else:\r\n                del self.cache[key]\r\n                del self.timestamps[key]\r\n        return None\r\n\r\n    def set(self, key: str, value: Any):\r\n        self.cache[key] = value\r\n        self.timestamps[key] = time.time()\r\n\r\ncache = TimeBasedCache(ttl=300)\r\n\r\n@mcp.tool()\r\nasync def cached_fetch(resource_id: str) -> dict:\r\n    \"\"\"Fetch with caching.\"\"\"\r\n    cache_key = f\"resource:{resource_id}\"\r\n\r\n    cached_data = cache.get(cache_key)\r\n    if cached_data:\r\n        return {\"data\": cached_data, \"from_cache\": True}\r\n\r\n    data = await fetch_from_api(resource_id)\r\n    cache.set(cache_key, data)\r\n\r\n    return {\"data\": data, \"from_cache\": False}\r\n```"
  }
}