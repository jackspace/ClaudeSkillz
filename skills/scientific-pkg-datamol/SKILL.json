{
  "description": "\"Pythonic wrapper around RDKit with simplified interface and sensible defaults. Preferred for standard drug discovery: SMILES parsing, standardization, descriptors, fingerprints, clustering, 3D conformers, parallel processing. Returns native rdkit.Chem.Mol objects. For advanced control or custom parameters, use rdkit directly.\"",
  "references": {
    "files": [
      "references/conformers_module.md",
      "references/core_api.md",
      "references/descriptors_viz.md",
      "references/fragments_scaffolds.md",
      "references/io_module.md",
      "references/reactions_data.md"
    ]
  },
  "content": "Guide users to install datamol:\r\n\r\n```bash\r\nconda install -c conda-forge datamol\r\n\r\n\r\n### 1. Basic Molecule Handling\r\n\r\n**Creating molecules from SMILES**:\r\n```python\r\nimport datamol as dm\r\n\r\nmol = dm.to_mol(\"CCO\")  # Ethanol\r\n\r\nsmiles_list = [\"CCO\", \"c1ccccc1\", \"CC(=O)O\"]\r\nmols = [dm.to_mol(smi) for smi in smiles_list]\r\n\r\nmol = dm.to_mol(\"invalid_smiles\")  # Returns None\r\nif mol is None:\r\n    print(\"Failed to parse SMILES\")\r\n```\r\n\r\n**Converting molecules to SMILES**:\r\n```python\r\nsmiles = dm.to_smiles(mol)\r\n\r\nsmiles = dm.to_smiles(mol, isomeric=True)\r\n\r\ninchi = dm.to_inchi(mol)\r\ninchikey = dm.to_inchikey(mol)\r\nselfies = dm.to_selfies(mol)\r\n```\r\n\r\n**Standardization and sanitization** (always recommend for user-provided molecules):\r\n```python\r\nmol = dm.sanitize_mol(mol)\r\n\r\nmol = dm.standardize_mol(\r\n    mol,\r\n    disconnect_metals=True,\r\n    normalize=True,\r\n    reionize=True\r\n)\r\n\r\nclean_smiles = dm.standardize_smiles(smiles)\r\n```\r\n\r\n### 2. Reading and Writing Molecular Files\r\n\r\nRefer to `references/io_module.md` for comprehensive I/O documentation.\r\n\r\n**Reading files**:\r\n```python\r\ndf = dm.read_sdf(\"compounds.sdf\", mol_column='mol')\r\n\r\ndf = dm.read_smi(\"molecules.smi\", smiles_column='smiles', mol_column='mol')\r\n\r\ndf = dm.read_csv(\"data.csv\", smiles_column=\"SMILES\", mol_column=\"mol\")\r\n\r\ndf = dm.read_excel(\"compounds.xlsx\", sheet_name=0, mol_column=\"mol\")\r\n\r\ndf = dm.open_df(\"file.sdf\")  # Works with .sdf, .csv, .xlsx, .parquet, .json\r\n```\r\n\r\n**Writing files**:\r\n```python\r\ndm.to_sdf(mols, \"output.sdf\")\r\ndm.to_sdf(df, \"output.sdf\", mol_column=\"mol\")\r\n\r\ndm.to_smi(mols, \"output.smi\")\r\n\r\ndm.to_xlsx(df, \"output.xlsx\", mol_columns=[\"mol\"])\r\n```\r\n\r\n**Remote file support** (S3, GCS, HTTP):\r\n```python\r\ndf = dm.read_sdf(\"s3://bucket/compounds.sdf\")\r\ndf = dm.read_csv(\"https://example.com/data.csv\")\r\n\r\ndm.to_sdf(mols, \"s3://bucket/output.sdf\")\r\n```\r\n\r\n### 3. Molecular Descriptors and Properties\r\n\r\nRefer to `references/descriptors_viz.md` for detailed descriptor documentation.\r\n\r\n**Computing descriptors for a single molecule**:\r\n```python\r\ndescriptors = dm.descriptors.compute_many_descriptors(mol)\r\n```\r\n\r\n**Batch descriptor computation** (recommended for datasets):\r\n```python\r\ndesc_df = dm.descriptors.batch_compute_many_descriptors(\r\n    mols,\r\n    n_jobs=-1,      # Use all CPU cores\r\n    progress=True   # Show progress bar\r\n)\r\n```\r\n\r\n**Specific descriptors**:\r\n```python\r\nn_aromatic = dm.descriptors.n_aromatic_atoms(mol)\r\naromatic_ratio = dm.descriptors.n_aromatic_atoms_proportion(mol)\r\n\r\nn_stereo = dm.descriptors.n_stereo_centers(mol)\r\nn_unspec = dm.descriptors.n_stereo_centers_unspecified(mol)\r\n\r\nn_rigid = dm.descriptors.n_rigid_bonds(mol)\r\n```\r\n\r\n**Drug-likeness filtering (Lipinski's Rule of Five)**:\r\n```python\r\ndef is_druglike(mol):\r\n    desc = dm.descriptors.compute_many_descriptors(mol)\r\n    return (\r\n        desc['mw'] <= 500 and\r\n        desc['logp'] <= 5 and\r\n        desc['hbd'] <= 5 and\r\n        desc['hba'] <= 10\r\n    )\r\n\r\ndruglike_mols = [mol for mol in mols if is_druglike(mol)]\r\n```\r\n\r\n### 4. Molecular Fingerprints and Similarity\r\n\r\n**Generating fingerprints**:\r\n```python\r\nfp = dm.to_fp(mol, fp_type='ecfp', radius=2, n_bits=2048)\r\n\r\nfp_maccs = dm.to_fp(mol, fp_type='maccs')\r\nfp_topological = dm.to_fp(mol, fp_type='topological')\r\nfp_atompair = dm.to_fp(mol, fp_type='atompair')\r\n```\r\n\r\n**Similarity calculations**:\r\n```python\r\ndistance_matrix = dm.pdist(mols, n_jobs=-1)\r\n\r\ndistances = dm.cdist(query_mols, library_mols, n_jobs=-1)\r\n\r\nfrom scipy.spatial.distance import squareform\r\ndist_matrix = squareform(dm.pdist(mols))\r\n```\r\n\r\n### 5. Clustering and Diversity Selection\r\n\r\nRefer to `references/core_api.md` for clustering details.\r\n\r\n**Butina clustering**:\r\n```python\r\nclusters = dm.cluster_mols(\r\n    mols,\r\n    cutoff=0.2,    # Tanimoto distance threshold (0=identical, 1=completely different)\r\n    n_jobs=-1      # Parallel processing\r\n)\r\n\r\nfor i, cluster in enumerate(clusters):\r\n    print(f\"Cluster {i}: {len(cluster)} molecules\")\r\n    cluster_mols = [mols[idx] for idx in cluster]\r\n```\r\n\r\n**Important**: Butina clustering builds a full distance matrix - suitable for ~1000 molecules, not for 10,000+.\r\n\r\n**Diversity selection**:\r\n```python\r\ndiverse_mols = dm.pick_diverse(\r\n    mols,\r\n    npick=100  # Select 100 diverse molecules\r\n)\r\n\r\ncentroids = dm.pick_centroids(\r\n    mols,\r\n    npick=50   # Select 50 representative molecules\r\n)\r\n```\r\n\r\n### 6. Scaffold Analysis\r\n\r\nRefer to `references/fragments_scaffolds.md` for complete scaffold documentation.\r\n\r\n**Extracting Murcko scaffolds**:\r\n```python\r\nscaffold = dm.to_scaffold_murcko(mol)\r\nscaffold_smiles = dm.to_smiles(scaffold)\r\n```\r\n\r\n**Scaffold-based analysis**:\r\n```python\r\nfrom collections import Counter\r\n\r\nscaffolds = [dm.to_scaffold_murcko(mol) for mol in mols]\r\nscaffold_smiles = [dm.to_smiles(s) for s in scaffolds]\r\n\r\nscaffold_counts = Counter(scaffold_smiles)\r\nmost_common = scaffold_counts.most_common(10)\r\n\r\nscaffold_groups = {}\r\nfor mol, scaf_smi in zip(mols, scaffold_smiles):\r\n    if scaf_smi not in scaffold_groups:\r\n        scaffold_groups[scaf_smi] = []\r\n    scaffold_groups[scaf_smi].append(mol)\r\n```\r\n\r\n**Scaffold-based train/test splitting** (for ML):\r\n```python\r\nscaffold_to_mols = {}\r\nfor mol, scaf in zip(mols, scaffold_smiles):\r\n    if scaf not in scaffold_to_mols:\r\n        scaffold_to_mols[scaf] = []\r\n    scaffold_to_mols[scaf].append(mol)\r\n\r\nimport random\r\nscaffolds = list(scaffold_to_mols.keys())\r\nrandom.shuffle(scaffolds)\r\nsplit_idx = int(0.8 * len(scaffolds))\r\ntrain_scaffolds = scaffolds[:split_idx]\r\ntest_scaffolds = scaffolds[split_idx:]\r\n\r\ntrain_mols = [mol for scaf in train_scaffolds for mol in scaffold_to_mols[scaf]]\r\ntest_mols = [mol for scaf in test_scaffolds for mol in scaffold_to_mols[scaf]]\r\n```\r\n\r\n### 7. Molecular Fragmentation\r\n\r\nRefer to `references/fragments_scaffolds.md` for fragmentation details.\r\n\r\n**BRICS fragmentation** (16 bond types):\r\n```python\r\nfragments = dm.fragment.brics(mol)\r\n```\r\n\r\n**RECAP fragmentation** (11 bond types):\r\n```python\r\nfragments = dm.fragment.recap(mol)\r\n```\r\n\r\n**Fragment analysis**:\r\n```python\r\nfrom collections import Counter\r\n\r\nall_fragments = []\r\nfor mol in mols:\r\n    frags = dm.fragment.brics(mol)\r\n    all_fragments.extend(frags)\r\n\r\nfragment_counts = Counter(all_fragments)\r\ncommon_frags = fragment_counts.most_common(20)\r\n\r\ndef fragment_score(mol, reference_fragments):\r\n    mol_frags = dm.fragment.brics(mol)\r\n    overlap = mol_frags.intersection(reference_fragments)\r\n    return len(overlap) / len(mol_frags) if mol_frags else 0\r\n```\r\n\r\n### 8. 3D Conformer Generation\r\n\r\nRefer to `references/conformers_module.md` for detailed conformer documentation.\r\n\r\n**Generating conformers**:\r\n```python\r\nmol_3d = dm.conformers.generate(\r\n    mol,\r\n    n_confs=50,           # Number to generate (auto if None)\r\n    rms_cutoff=0.5,       # Filter similar conformers (Ångströms)\r\n    minimize_energy=True,  # Minimize with UFF force field\r\n    method='ETKDGv3'      # Embedding method (recommended)\r\n)\r\n\r\nn_conformers = mol_3d.GetNumConformers()\r\nconf = mol_3d.GetConformer(0)  # Get first conformer\r\npositions = conf.GetPositions()  # Nx3 array of atom coordinates\r\n```\r\n\r\n**Conformer clustering**:\r\n```python\r\nclusters = dm.conformers.cluster(\r\n    mol_3d,\r\n    rms_cutoff=1.0,\r\n    centroids=False\r\n)\r\n\r\ncentroids = dm.conformers.return_centroids(mol_3d, clusters)\r\n```\r\n\r\n**SASA calculation**:\r\n```python\r\nsasa_values = dm.conformers.sasa(mol_3d, n_jobs=-1)\r\n\r\nconf = mol_3d.GetConformer(0)\r\nsasa = conf.GetDoubleProp('rdkit_free_sasa')\r\n```\r\n\r\n### 9. Visualization\r\n\r\nRefer to `references/descriptors_viz.md` for visualization documentation.\r\n\r\n**Basic molecule grid**:\r\n```python\r\ndm.viz.to_image(\r\n    mols[:20],\r\n    legends=[dm.to_smiles(m) for m in mols[:20]],\r\n    n_cols=5,\r\n    mol_size=(300, 300)\r\n)\r\n\r\ndm.viz.to_image(mols, outfile=\"molecules.png\")\r\n\r\ndm.viz.to_image(mols, outfile=\"molecules.svg\", use_svg=True)\r\n```\r\n\r\n**Aligned visualization** (for SAR analysis):\r\n```python\r\ndm.viz.to_image(\r\n    similar_mols,\r\n    align=True,  # Enable MCS alignment\r\n    legends=activity_labels,\r\n    n_cols=4\r\n)\r\n```\r\n\r\n**Highlighting substructures**:\r\n```python\r\ndm.viz.to_image(\r\n    mol,\r\n    highlight_atom=[0, 1, 2, 3],  # Atom indices\r\n    highlight_bond=[0, 1, 2]      # Bond indices\r\n)\r\n```\r\n\r\n**Conformer visualization**:\r\n```python\r\ndm.viz.conformers(\r\n    mol_3d,\r\n    n_confs=10,\r\n    align_conf=True,\r\n    n_cols=3\r\n)\r\n```\r\n\r\n### 10. Chemical Reactions\r\n\r\nRefer to `references/reactions_data.md` for reactions documentation.\r\n\r\n**Applying reactions**:\r\n```python\r\nfrom rdkit.Chem import rdChemReactions\r\n\r\nrxn_smarts = '[C:1](=[O:2])[OH:3]>>[C:1](=[O:2])[Cl:3]'\r\nrxn = rdChemReactions.ReactionFromSmarts(rxn_smarts)\r\n\r\nreactant = dm.to_mol(\"CC(=O)O\")  # Acetic acid\r\nproduct = dm.reactions.apply_reaction(\r\n    rxn,\r\n    (reactant,),\r\n    sanitize=True\r\n)\r\n\r\nproduct_smiles = dm.to_smiles(product)\r\n```\r\n\r\n**Batch reaction application**:\r\n```python\r\n\r\n### Complete Pipeline: Data Loading → Filtering → Analysis\r\n\r\n```python\r\nimport datamol as dm\r\nimport pandas as pd\r\n\r\ndf = dm.read_sdf(\"compounds.sdf\")\r\n\r\ndf['mol'] = df['mol'].apply(lambda m: dm.standardize_mol(m) if m else None)\r\ndf = df[df['mol'].notna()]  # Remove failed molecules\r\n\r\ndesc_df = dm.descriptors.batch_compute_many_descriptors(\r\n    df['mol'].tolist(),\r\n    n_jobs=-1,\r\n    progress=True\r\n)\r\n\r\ndruglike = (\r\n    (desc_df['mw'] <= 500) &\r\n    (desc_df['logp'] <= 5) &\r\n    (desc_df['hbd'] <= 5) &\r\n    (desc_df['hba'] <= 10)\r\n)\r\nfiltered_df = df[druglike]\r\n\r\ndiverse_mols = dm.pick_diverse(\r\n    filtered_df['mol'].tolist(),\r\n    npick=100\r\n)\r\n\r\ndm.viz.to_image(\r\n    diverse_mols,\r\n    legends=[dm.to_smiles(m) for m in diverse_mols],\r\n    outfile=\"diverse_compounds.png\",\r\n    n_cols=10\r\n)\r\n```\r\n\r\n### Structure-Activity Relationship (SAR) Analysis\r\n\r\n```python\r\nscaffolds = [dm.to_scaffold_murcko(mol) for mol in mols]\r\nscaffold_smiles = [dm.to_smiles(s) for s in scaffolds]\r\n\r\nsar_df = pd.DataFrame({\r\n    'mol': mols,\r\n    'scaffold': scaffold_smiles,\r\n    'activity': activities  # User-provided activity data\r\n})\r\n\r\nfor scaffold, group in sar_df.groupby('scaffold'):\r\n    if len(group) >= 3:  # Need multiple examples\r\n        print(f\"\\nScaffold: {scaffold}\")\r\n        print(f\"Count: {len(group)}\")\r\n        print(f\"Activity range: {group['activity'].min():.2f} - {group['activity'].max():.2f}\")\r\n\r\n        # Visualize with activities as legends\r\n        dm.viz.to_image(\r\n            group['mol'].tolist(),\r\n            legends=[f\"Activity: {act:.2f}\" for act in group['activity']],\r\n            align=True  # Align by common substructure\r\n        )\r\n```\r\n\r\n### Virtual Screening Pipeline\r\n\r\n```python\r\nquery_fps = [dm.to_fp(mol) for mol in query_actives]\r\nlibrary_fps = [dm.to_fp(mol) for mol in library_mols]\r\n\r\nfrom scipy.spatial.distance import cdist\r\nimport numpy as np\r\n\r\ndistances = dm.cdist(query_actives, library_mols, n_jobs=-1)\r\n\r\nmin_distances = distances.min(axis=0)\r\nsimilarities = 1 - min_distances  # Convert distance to similarity\r\n\r\ntop_indices = np.argsort(similarities)[::-1][:100]  # Top 100\r\ntop_hits = [library_mols[i] for i in top_indices]\r\ntop_scores = [similarities[i] for i in top_indices]\r\n\r\n\r\n```python\r\ndef safe_to_mol(smiles):\r\n    try:\r\n        mol = dm.to_mol(smiles)\r\n        if mol is not None:\r\n            mol = dm.standardize_mol(mol)\r\n        return mol\r\n    except Exception as e:\r\n        print(f\"Failed to process {smiles}: {e}\")\r\n        return None\r\n\r\n\r\n```python\r\nX = np.array([dm.to_fp(mol) for mol in mols])\r\n\r\ndesc_df = dm.descriptors.batch_compute_many_descriptors(mols, n_jobs=-1)\r\nX = desc_df.values\r\n\r\nfrom sklearn.ensemble import RandomForestRegressor\r\nmodel = RandomForestRegressor()\r\nmodel.fit(X, y_target)",
  "name": "datamol",
  "id": "scientific-pkg-datamol",
  "sections": {
    "Reference Documentation": "For detailed API documentation, consult these reference files:\r\n\r\n- **`references/core_api.md`**: Core namespace functions (conversions, standardization, fingerprints, clustering)\r\n- **`references/io_module.md`**: File I/O operations (read/write SDF, CSV, Excel, remote files)\r\n- **`references/conformers_module.md`**: 3D conformer generation, clustering, SASA calculations\r\n- **`references/descriptors_viz.md`**: Molecular descriptors and visualization functions\r\n- **`references/fragments_scaffolds.md`**: Scaffold extraction, BRICS/RECAP fragmentation\r\n- **`references/reactions_data.md`**: Chemical reactions and toy datasets",
    "Additional Resources": "- **Datamol Documentation**: https://docs.datamol.io/\r\n- **RDKit Documentation**: https://www.rdkit.org/docs/\r\n- **GitHub Repository**: https://github.com/datamol-io/datamol",
    "Overview": "Datamol is a Python library that provides a lightweight, Pythonic abstraction layer over RDKit for molecular cheminformatics. Simplify complex molecular operations with sensible defaults, efficient parallelization, and modern I/O capabilities. All molecular objects are native `rdkit.Chem.Mol` instances, ensuring full compatibility with the RDKit ecosystem.\r\n\r\n**Key capabilities**:\r\n- Molecular format conversion (SMILES, SELFIES, InChI)\r\n- Structure standardization and sanitization\r\n- Molecular descriptors and fingerprints\r\n- 3D conformer generation and analysis\r\n- Clustering and diversity selection\r\n- Scaffold and fragment analysis\r\n- Chemical reaction application\r\n- Visualization and alignment\r\n- Batch processing with parallelization\r\n- Cloud storage support via fsspec",
    "Troubleshooting": "**Issue**: Molecule parsing fails\r\n- **Solution**: Use `dm.standardize_smiles()` first or try `dm.fix_mol()`\r\n\r\n**Issue**: Memory errors with clustering\r\n- **Solution**: Use `dm.pick_diverse()` instead of full clustering for large sets\r\n\r\n**Issue**: Slow conformer generation\r\n- **Solution**: Reduce `n_confs` or increase `rms_cutoff` to generate fewer conformers\r\n\r\n**Issue**: Remote file access fails\r\n- **Solution**: Ensure fsspec and appropriate cloud provider libraries are installed (s3fs, gcsfs, etc.)",
    "Common Workflows and Patterns": "dm.viz.to_image(\r\n    top_hits[:20],\r\n    legends=[f\"Sim: {score:.3f}\" for score in top_scores[:20]],\r\n    outfile=\"screening_hits.png\"\r\n)\r\n```",
    "Installation and Setup": "pip install datamol\r\n```\r\n\r\n**Import convention**:\r\n```python\r\nimport datamol as dm\r\n```",
    "Parallelization": "Datamol includes built-in parallelization for many operations. Use `n_jobs` parameter:\r\n- `n_jobs=1`: Sequential (no parallelization)\r\n- `n_jobs=-1`: Use all available CPU cores\r\n- `n_jobs=4`: Use 4 cores\r\n\r\n**Functions supporting parallelization**:\r\n- `dm.read_sdf(..., n_jobs=-1)`\r\n- `dm.descriptors.batch_compute_many_descriptors(..., n_jobs=-1)`\r\n- `dm.cluster_mols(..., n_jobs=-1)`\r\n- `dm.pdist(..., n_jobs=-1)`\r\n- `dm.conformers.sasa(..., n_jobs=-1)`\r\n\r\n**Progress bars**: Many batch operations support `progress=True` parameter.",
    "Core Workflows": "products = []\r\nfor mol in reactant_mols:\r\n    try:\r\n        prod = dm.reactions.apply_reaction(rxn, (mol,))\r\n        if prod is not None:\r\n            products.append(prod)\r\n    except Exception as e:\r\n        print(f\"Reaction failed: {e}\")\r\n```",
    "Integration with Machine Learning": "predictions = model.predict(X_test)\r\n```",
    "Error Handling": "valid_mols = []\r\nfor smiles in smiles_list:\r\n    mol = safe_to_mol(smiles)\r\n    if mol is not None:\r\n        valid_mols.append(mol)\r\n```",
    "Best Practices": "1. **Always standardize molecules** from external sources:\r\n   ```python\r\n   mol = dm.standardize_mol(mol, disconnect_metals=True, normalize=True, reionize=True)\r\n   ```\r\n\r\n2. **Check for None values** after molecule parsing:\r\n   ```python\r\n   mol = dm.to_mol(smiles)\r\n   if mol is None:\r\n       # Handle invalid SMILES\r\n   ```\r\n\r\n3. **Use parallel processing** for large datasets:\r\n   ```python\r\n   result = dm.operation(..., n_jobs=-1, progress=True)\r\n   ```\r\n\r\n4. **Leverage fsspec** for cloud storage:\r\n   ```python\r\n   df = dm.read_sdf(\"s3://bucket/compounds.sdf\")\r\n   ```\r\n\r\n5. **Use appropriate fingerprints** for similarity:\r\n   - ECFP (Morgan): General purpose, structural similarity\r\n   - MACCS: Fast, smaller feature space\r\n   - Atom pairs: Considers atom pairs and distances\r\n\r\n6. **Consider scale limitations**:\r\n   - Butina clustering: ~1,000 molecules (full distance matrix)\r\n   - For larger datasets: Use diversity selection or hierarchical methods\r\n\r\n7. **Scaffold splitting for ML**: Ensure proper train/test separation by scaffold\r\n\r\n8. **Align molecules** when visualizing SAR series"
  }
}