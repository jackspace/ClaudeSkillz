{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/cli-tool-integration.md",
      "references/git-workflows.md",
      "references/hooks-examples.md",
      "references/security-best-practices.md",
      "references/troubleshooting-guide.md"
    ]
  },
  "content": "**Status**: Production Ready ‚úÖ\r\n**Last Updated**: 2025-11-07\r\n**Dependencies**: Claude Code CLI (latest version)\r\n**Official Docs**: https://docs.claude.com/en/docs/claude-code/tools\r\n\r\n---\r\n\r\n\r\n### 1. Understanding the Bash Tool\r\n\r\nThe Bash tool is Claude Code's primary interface for executing command-line operations. Unlike specialized tools (Read, Grep, Glob), the Bash tool provides direct shell access for complex workflows.\r\n\r\n**Key Characteristics**:\r\n- **Session Persistence**: Commands run in a persistent bash session within a conversation\r\n- **Environment Inheritance**: Inherits environment variables and working directory\r\n- **Output Limit**: Truncates output at 30,000 characters\r\n- **Default Timeout**: 2 minutes (configurable up to 10 minutes)\r\n\r\n**When to Use Bash Tool**:\r\n- ‚úÖ Running CLI tools (git, npm, wrangler, gh, etc.)\r\n- ‚úÖ Command chaining (sequential operations)\r\n- ‚úÖ Process orchestration (build, test, deploy)\r\n- ‚úÖ Environment setup and management\r\n\r\n**When NOT to Use Bash Tool**:\r\n- ‚ùå Reading files ‚Üí Use **Read** tool instead\r\n- ‚ùå Searching file patterns ‚Üí Use **Glob** tool instead\r\n- ‚ùå Searching content ‚Üí Use **Grep** tool instead\r\n- ‚ùå Editing files ‚Üí Use **Edit** tool instead\r\n\r\n### 2. Basic Command Patterns\r\n\r\n```bash\r\nnpm install\r\n\r\nnpm install && npm run build\r\n\r\nnpm install ; npm run build\r\n\r\n\r\n### Pattern 1: Command Chaining\r\n\r\n**When to Use**: Sequential operations where each depends on previous success\r\n\r\n**Syntax**: `command1 && command2 && command3`\r\n\r\n**Example**: Build and deploy workflow\r\n```bash\r\nnpm install && npm run build && npx wrangler deploy\r\n```\r\n\r\n**Why It Matters**:\r\n- Stops on first failure (prevents cascading errors)\r\n- Maintains clean error messages (know exactly what failed)\r\n- Saves tokens (no need to check status between commands)\r\n\r\n**Anti-Pattern**: Using `;` when you care about failures\r\n```bash\r\nnpm install ; npm run build\r\n\r\nnpm install && npm run build\r\n```\r\n\r\n**Advanced**: Conditional execution with `||`\r\n```bash\r\nnpm test || echo \"Tests failed, not deploying\"\r\n\r\nnpm ci || npm install\r\n```\r\n\r\n### Pattern 2: Parallel Execution\r\n\r\n**When to Use**: Independent operations that can run simultaneously\r\n\r\n**How**: Make multiple Bash tool calls in a single message\r\n\r\n**Example**: Git workflow pre-commit analysis\r\n```\r\nCall 1: git status\r\nCall 2: git diff --staged\r\nCall 3: git log -5 --oneline\r\n```\r\n\r\n**Benefits**:\r\n- ~40% faster than sequential (no waiting between calls)\r\n- Reduces context usage (all results arrive together)\r\n- Better user experience (appears instant)\r\n\r\n**Important**: Only parallelize truly independent operations. If Call 2 depends on Call 1's output, run sequentially.\r\n\r\n### Pattern 3: HEREDOC for Multi-Line Content\r\n\r\n**When to Use**: Git commits, file creation, complex strings with newlines\r\n\r\n**Syntax**: `cat <<'EOF' ... EOF`\r\n\r\n**Example**: Git commit with detailed message\r\n```bash\r\ngit commit -m \"$(cat <<'EOF'\r\nfeat(auth): Add JWT verification middleware\r\n\r\nImplement custom JWT template support for Clerk auth.\r\nExtracts email and metadata claims for user context.\r\n\r\nü§ñ Generated with Claude Code\r\n\r\nCo-Authored-By: Claude <noreply@anthropic.com>\r\nEOF\r\n)\"\r\n```\r\n\r\n**Why Single Quotes**: `<<'EOF'` prevents variable expansion in the content. Use `<<\"EOF\"` if you want variables to expand.\r\n\r\n**Common Mistake**: Forgetting quotes around `$()` wrapper\r\n```bash\r\ngit commit -m $(cat <<'EOF'\r\nLine 1\r\nLine 2\r\nEOF\r\n)\r\n\r\ngit commit -m \"$(cat <<'EOF'\r\nLine 1\r\nLine 2\r\nEOF\r\n)\"\r\n```\r\n\r\n### Pattern 4: Output Capture and Processing\r\n\r\n**When to Use**: Need to process command output before using it\r\n\r\n**Pattern**: Command substitution with `$()`\r\n\r\n**Example**: Get current branch name\r\n```bash\r\nBRANCH=$(git rev-parse --abbrev-ref HEAD)\r\necho \"Current branch: $BRANCH\"\r\n```\r\n\r\n**Example**: Conditional logic based on output\r\n```bash\r\nif git diff --quiet; then\r\n  echo \"No changes detected\"\r\nelse\r\n  echo \"Changes detected, running tests...\"\r\n  npm test\r\nfi\r\n```\r\n\r\n**Limitation**: Output truncated at 30,000 characters. For large outputs:\r\n```bash\r\nnpm test 2>&1 | head -100\r\n\r\n\r\nHooks are shell commands or Claude prompts that run before/after tool execution. They're your security guards, cleanup crew, and automation helpers.\r\n\r\n### PreToolUse: The Security Guard\r\n\r\n**Purpose**: Runs before tool execution, can block or modify behavior\r\n\r\n**Exit Codes**:\r\n- `0` = Allow execution\r\n- `1` = Block with generic error\r\n- `2` = Block with custom error message (from stderr)\r\n\r\n#### Use Case 1: Block Dangerous Commands\r\n\r\n**File**: `~/.claude/hooks/dangerous-command-guard.py`\r\n```python\r\n#!/usr/bin/env python3\r\nimport json\r\nimport sys\r\nimport re\r\n\r\ndata = json.load(sys.stdin)\r\ncommand = data.get('tool_input', {}).get('command', '')\r\n\r\nDANGEROUS = [\r\n    r'rm\\s+-rf\\s+/',           # Delete root\r\n    r'dd\\s+if=',                # Disk operations\r\n    r'mkfs\\.',                  # Format filesystem\r\n    r':()\\{.*\\}:',              # Fork bomb\r\n    r'sudo\\s+rm',               # Sudo delete\r\n    r'git\\s+push.*--force.*main',  # Force push to main\r\n]\r\n\r\nfor pattern in DANGEROUS:\r\n    if re.search(pattern, command):\r\n        print(f\"BLOCKED: Dangerous command pattern '{pattern}'\", file=sys.stderr)\r\n        sys.exit(2)\r\n\r\nsys.exit(0)\r\n```\r\n\r\n**Settings Configuration**:\r\n```json\r\n{\r\n  \"hooks\": {\r\n    \"PreToolUse\": [\r\n      {\r\n        \"matcher\": \"Bash\",\r\n        \"hooks\": [\r\n          {\r\n            \"type\": \"command\",\r\n            \"command\": \"python3 ~/.claude/hooks/dangerous-command-guard.py\"\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n#### Use Case 2: Log All Bash Commands\r\n\r\n```json\r\n{\r\n  \"matcher\": \"Bash\",\r\n  \"hooks\": [\r\n    {\r\n      \"type\": \"command\",\r\n      \"command\": \"echo \\\"[$(date -Iseconds)] $(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.command')\\\" >> ~/.claude/bash-audit.log\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Result**: Every bash command logged with timestamp to `~/.claude/bash-audit.log`\r\n\r\n#### Use Case 3: Enforce Package Manager\r\n\r\nCheck for lockfile and block wrong package manager:\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\nThese patterns are used by Anthropic's engineering team for 90%+ of git interactions.\r\n\r\n### Pattern: Intelligent Git Commits\r\n\r\n**Step 1**: Gather context (parallel calls)\r\n```bash\r\ngit status\r\n\r\ngit diff --staged\r\n\r\ngit log -5 --oneline\r\n```\r\n\r\n**Why Parallel**: Independent operations, faster response, better UX\r\n\r\n**Step 2**: Analyze changes\r\n- Review **actual code changes** (not just file names!)\r\n- Match commit message style from git log\r\n- Focus on \"why\" not \"what\"\r\n- Keep message concise (1-2 sentences)\r\n\r\n**Step 3**: Commit with HEREDOC\r\n```bash\r\ngit add [files] && git commit -m \"$(cat <<'EOF'\r\nfeat(auth): Add JWT verification middleware\r\n\r\nImplement custom JWT template support for Clerk auth.\r\nExtracts email and metadata claims for user context.\r\n\r\nü§ñ Generated with Claude Code\r\n\r\nCo-Authored-By: Claude <noreply@anthropic.com>\r\nEOF\r\n)\"\r\n```\r\n\r\n**Step 4**: Verify\r\n```bash\r\ngit status\r\n```\r\n\r\n**Important**: If pre-commit hook modifies files:\r\n1. Check authorship: `git log -1 --format='%an %ae'`\r\n2. Check not pushed: `git status` (should show \"ahead of origin\")\r\n3. If both safe: `git add . && git commit --amend --no-edit`\r\n4. If not safe: `git add . && git commit -m \"Apply pre-commit hook changes\"`\r\n\r\n### Pattern: Pull Request Creation\r\n\r\n**Step 1**: Understand branch state (parallel)\r\n```bash\r\ngit status\r\n\r\ngit diff main...HEAD\r\n\r\n\r\n### GitHub CLI (gh)\r\n\r\nClaude knows gh CLI by default. Common patterns:\r\n\r\n```bash\r\ngh api repos/owner/repo/pulls/123/comments\r\n\r\ngh run list --limit 5\r\n\r\ngh issue create --title \"Bug: Description\" --body \"Details here\"\r\n\r\ngh pr comment 123 --body \"LGTM! üöÄ\"\r\n```\r\n\r\n### Wrangler (Cloudflare)\r\n\r\nPrefix with `npx` for local install:\r\n\r\n```bash\r\nnpx wrangler deploy\r\n\r\nnpx wrangler d1 migrations apply my-db --remote\r\n\r\nnpx wrangler tail\r\n\r\n\r\n### 1. Dangerous Command Guard (PreToolUse Hook)\r\n\r\nSee bundled script: `scripts/dangerous-command-guard.py`\r\n\r\n**Blocks**:\r\n- `rm -rf /` (delete root)\r\n- `dd if=` (disk operations)\r\n- `mkfs.*` (format filesystem)\r\n- `:(){ :|:& };:` (fork bomb)\r\n- `sudo rm` (dangerous sudo deletions)\r\n- `git push --force main` (force push to main branch)\r\n\r\n**Installation**:\r\n```bash\r\ncp scripts/dangerous-command-guard.py ~/.claude/hooks/\r\nchmod +x ~/.claude/hooks/dangerous-command-guard.py\r\n\r\n\r\n### Always Do ‚úÖ\r\n\r\n**1. Use Specialized Tools First**\r\n\r\nBash is powerful but inefficient for tasks with dedicated tools:\r\n\r\n```bash\r\ncat file.txt\r\n\r\nRead(file_path=\"file.txt\")\r\n```\r\n\r\n```bash\r\nfind . -name \"*.ts\"\r\n\r\nGlob(pattern=\"**/*.ts\")\r\n```\r\n\r\n```bash\r\ngrep \"pattern\" file.txt\r\n\r\nGrep(pattern=\"pattern\", path=\"file.txt\")\r\n```\r\n\r\n**Why**: Specialized tools are faster, use fewer tokens, and provide better formatting.\r\n\r\n**2. Quote Paths with Spaces**\r\n\r\n```bash\r\ncd /Users/name/My Documents\r\n\r\ncd \"/Users/name/My Documents\"\r\n```\r\n\r\n**3. Use && for Dependencies**\r\n\r\n```bash\r\nnpm install ; npm run build\r\n\r\nnpm install && npm run build\r\n```\r\n\r\n**4. Parallel for Independent Operations**\r\n\r\n```bash\r\ngit status && git diff && git log\r\n\r\n```\r\n\r\n**5. HEREDOC for Multi-line Strings**\r\n\r\n```bash\r\ngit commit -m \"line1\\nline2\\nline3\"\r\n\r\ngit commit -m \"$(cat <<'EOF'\r\nline1\r\nline2\r\nline3\r\nEOF\r\n)\"\r\n```\r\n\r\n**6. Always Provide Description**\r\n\r\n```bash\r\nBash(command=\"complex-script.sh\")\r\n\r\nBash(\r\n  command=\"complex-script.sh\",\r\n  description=\"Run integration tests on staging database\"\r\n)\r\n```\r\n\r\n### Never Do ‚ùå\r\n\r\n**1. Don't Use Interactive Commands**\r\n\r\nCommands that require user input will hang:\r\n\r\n```bash\r\nvim file.txt\r\nnano file.txt\r\nless output.txt\r\nnpm install  # If package.json has prompts\r\n\r\nnpm install --yes\r\n```\r\n\r\n**2. Don't Chain with Newlines**\r\n\r\n```bash\r\ncommand1\r\ncommand2\r\n\r\ncommand1 && command2\r\n```\r\n\r\n**3. Don't Ignore Exit Codes**\r\n\r\n```bash\r\nrisky-command ; echo \"Success!\"\r\n\r\nrisky-command && echo \"Success!\" || echo \"Failed!\"\r\n```\r\n\r\n**4. Don't Use cd Excessively**\r\n\r\nIn agent mode, working directory doesn't persist between calls:\r\n\r\n```bash\r\n\r\nnpm test --prefix /path/to/project\r\n\r\ncd /path/to/project && npm test\r\n```\r\n\r\n**5. Don't Skip Error Handling**\r\n\r\n```bash\r\n./script.sh\r\n./cleanup.sh\r\n\r\n\r\nThis skill prevents **12** documented issues with sources:\r\n\r\n### Issue #1: Git Bash cygpath Command Not Found (Windows)\r\n\r\n**Error**: `bash: line 1: cygpath: command not found`\r\n**Source**: https://github.com/anthropics/claude-code/issues/9883\r\n**Why It Happens**: Bash tool attempts to use cygpath (Cygwin-only) on MSYS/Git Bash\r\n\r\n**Prevention**:\r\n- Use WSL instead of Git Bash on Windows\r\n- Configure `CLAUDE_CODE_GIT_BASH_PATH` if using Git Bash\r\n- Install Cygwin if cygpath is required\r\n\r\n### Issue #2: Pipe Command Failures\r\n\r\n**Error**: `echo test|grep test` returns error instead of \"test\"\r\n**Source**: https://github.com/anthropics/claude-code/issues/774\r\n**Why It Happens**: Pipe parsing issues in certain configurations\r\n\r\n**Prevention**:\r\n```bash\r\necho test|grep test\r\n\r\nbash -c 'echo test | grep test'\r\n\r\n```\r\n\r\n### Issue #3: Command Timeout (Hanging Promises)\r\n\r\n**Error**: `A hanging Promise was canceled`\r\n**Source**: Bash tool default timeout is 2 minutes\r\n**Why It Happens**: Long-running commands without timeout configuration\r\n\r\n**Prevention**:\r\n```bash\r\nBash(\r\n  command=\"npm run build\",\r\n  timeout=600000,  # 10 minutes\r\n  description=\"Build production bundle (may take several minutes)\"\r\n)\r\n\r\nBash(\r\n  command=\"npm run build > build.log 2>&1 &\",\r\n  description=\"Start build in background\"\r\n)\r\n```\r\n\r\n### Issue #4: Output Truncation Loss\r\n\r\n**Error**: Important output missing from response\r\n**Source**: Bash tool truncates output at 30,000 characters\r\n**Why It Happens**: Large command outputs exceed limit\r\n\r\n**Prevention**:\r\n```bash\r\nnpm test\r\n\r\nnpm test 2>&1 | head -100\r\n\r\nnpm test > test-results.txt && tail -50 test-results.txt\r\n```\r\n\r\n### Issue #5: \"No Suitable Shell Found\" (Windows)\r\n\r\n**Error**: CLI fails with \"No suitable shell found\"\r\n**Source**: https://github.com/anthropics/claude-code/issues/3461\r\n**Why It Happens**: Shell detection issues in Git Bash environment\r\n\r\n**Prevention**:\r\n- Set SHELL environment variable explicitly\r\n- Use WSL for better compatibility\r\n- Install latest Claude Code CLI version\r\n\r\n### Issue #6: Bash Tool Access Loss\r\n\r\n**Error**: Claude loses ability to run Bash() tool\r\n**Source**: https://github.com/anthropics/claude-code/issues/1888\r\n**Why It Happens**: Session state corruption, often after overnight idle\r\n\r\n**Prevention**:\r\n- Restart Claude Code session if Bash becomes unavailable\r\n- Check permissions with `/permissions` command\r\n- Use `restart: true` parameter to reset bash session\r\n\r\n### Issue #7: Interactive Prompt Hangs\r\n\r\n**Error**: Command hangs indefinitely, no output\r\n**Why It Happens**: Command expects interactive input (password, confirmation)\r\n\r\n**Prevention**:\r\n```bash\r\nnpm install  # If package.json has interactive prompts\r\n\r\nnpm install --yes\r\n\r\necho \"yes\" | command-that-needs-confirmation\r\n```\r\n\r\n### Issue #8: Permission Denied Errors\r\n\r\n**Error**: `permission denied` or `command not found`\r\n**Why It Happens**: Script not executable or not in PATH\r\n\r\n**Prevention**:\r\n```bash\r\nchmod +x script.sh && ./script.sh\r\n\r\n/usr/local/bin/mycli deploy\r\n\r\npython3 script.py\r\nnode script.js\r\n```\r\n\r\n### Issue #9: Environment Variables Not Persisting\r\n\r\n**Error**: Variable set in one command not available in next\r\n**Why It Happens**: Agent threads reset environment between calls\r\n\r\n**Prevention**:\r\n```bash\r\n\r\nexport API_KEY=abc123 && curl -H \"Authorization: $API_KEY\" ...\r\n\r\n```\r\n\r\n### Issue #10: Git Commit Hook Modifications Not Detected\r\n\r\n**Error**: Pre-commit hook changes files, but commit fails\r\n**Why It Happens**: Hook modifies files after staging\r\n\r\n**Prevention**:\r\n```bash\r\ngit log -1 --format='%an %ae'\r\n\r\ngit add . && git commit --amend --no-edit",
  "name": "claude-code-bash-patterns",
  "id": "claude-code-bash-patterns",
  "sections": {
    "Custom Commands (.claude/commands/)": "Custom commands are markdown files that expand into prompts when invoked.\r\n\r\n### Creating Custom Commands\r\n\r\n**File**: `.claude/commands/deploy-staging.md`\r\n```markdown\r\nDeploy the current branch to staging environment:\r\n\r\n1. Verify branch is not main (exit if main)\r\n2. Run full test suite (npm test)\r\n3. Build production bundle (npm run build)\r\n4. Deploy with wrangler to staging (npx wrangler deploy --env staging)\r\n5. Run smoke tests against staging URL\r\n6. Share deployment URL with user\r\n```\r\n\r\n**Usage**:\r\n```\r\nUser: /deploy-staging\r\nClaude: [Executes the workflow from the markdown file]\r\n```\r\n\r\n### Best Practices for Custom Commands\r\n\r\n‚úÖ **Do**:\r\n- Make them atomic (one clear workflow)\r\n- Include verification steps\r\n- Document expected state\r\n- Add rollback instructions\r\n- Use imperative language\r\n\r\n‚ùå **Don't**:\r\n- Make them too complex (split into multiple commands)\r\n- Include interactive prompts\r\n- Assume state (always verify)\r\n\r\n**Example Command Library**:\r\n- `/deploy-staging` - Deploy to staging\r\n- `/deploy-production` - Deploy to production (with safety checks)\r\n- `/run-tests` - Run full test suite\r\n- `/check-types` - TypeScript type checking\r\n- `/format-code` - Format all code files\r\n- `/create-migration` - Create database migration\r\n\r\n---",
    "Complete Setup Checklist": "- [ ] Claude Code CLI installed and updated\r\n- [ ] Bash 4.0+ available (`bash --version`)\r\n- [ ] jq installed (for hooks): `brew install jq` or `apt install jq`\r\n- [ ] gh CLI installed (for git workflows): `brew install gh` or `apt install gh`\r\n- [ ] Settings directory created: `mkdir -p ~/.claude/hooks`\r\n- [ ] Copied hook scripts to `~/.claude/hooks/`\r\n- [ ] Made scripts executable: `chmod +x ~/.claude/hooks/*.sh`\r\n- [ ] Configured `~/.claude/settings.json` with desired hooks\r\n- [ ] Tested dangerous command guard\r\n- [ ] Verified bash audit logging\r\n- [ ] Created first custom command in `.claude/commands/`\r\n- [ ] Tested git workflow patterns\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/troubleshooting-guide.md` for detailed solutions\r\n2. Review `references/hooks-examples.md` for configuration examples\r\n3. Consult official docs: https://docs.claude.com/en/docs/claude-code/hooks\r\n4. Verify all steps in setup checklist above",
    "Known Issues Prevention": "git add . && git commit -m \"Apply pre-commit hook changes\"\r\n```\r\n\r\n### Issue #11: Wildcard Permission Matching Not Working\r\n\r\n**Error**: `Bash(*)` or `Bash(*:*)` doesn't grant access\r\n**Source**: https://github.com/anthropics/claude-code/issues/462\r\n**Why It Happens**: Syntax mismatch in allowlisting\r\n\r\n**Prevention**:\r\n```json\r\n// ‚ùå Wrong\r\n{\"allowedTools\": [\"Bash(*)\"]}\r\n\r\n// ‚úÖ Correct\r\n{\"allowedTools\": [\"Bash\"]}\r\n\r\n// Or specific patterns\r\n{\"allowedTools\": [\"Bash(git *)\", \"Bash(npm *)\"]}\r\n```\r\n\r\n### Issue #12: Dangerous Command Execution\r\n\r\n**Error**: Accidental `rm -rf /` or force push to main\r\n**Why It Happens**: No guardrails on destructive operations\r\n\r\n**Prevention**: Use PreToolUse hook with dangerous command guard (see Security section)\r\n\r\n---",
    "Summary": "- Implement JWT verification with Clerk\r\n- Add login/logout endpoints\r\n- Update database schema for users table",
    "The Five Core Patterns": "npm test > test-results.txt && tail -50 test-results.txt\r\n```\r\n\r\n### Pattern 5: Conditional Execution\r\n\r\n**When to Use**: Different actions based on conditions\r\n\r\n**Pattern**: Test commands with `&&` / `||`\r\n\r\n**Example**: Run tests only if files changed\r\n```bash\r\ngit diff --quiet || npm test\r\n```\r\n\r\n**Example**: Different commands based on file existence\r\n```bash\r\n[ -f package-lock.json ] && npm ci || npm install\r\n```\r\n\r\n**Example**: Multi-condition logic\r\n```bash\r\nif [ -f pnpm-lock.yaml ]; then\r\n  pnpm install\r\nelif [ -f yarn.lock ]; then\r\n  yarn install\r\nelse\r\n  npm install\r\nfi\r\n```\r\n\r\n---",
    "Test Plan": "- [ ] Verify JWT token validation\r\n- [ ] Test login flow\r\n- [ ] Test logout flow\r\n- [ ] Confirm database migrations work\r\n\r\nü§ñ Generated with Claude Code\r\nEOF\r\n)\"\r\n```\r\n\r\n**Result**: Professional PR with clear summary and test plan\r\n\r\n---",
    "CLI Tool Integration": "npx wrangler d1 execute my-db --command \"SELECT * FROM users LIMIT 5\"\r\n```\r\n\r\n### Custom CLI Tools\r\n\r\n**How to teach Claude about your CLI**:\r\n\r\n**Option 1**: Document in CLAUDE.md\r\n```markdown",
    "Security Configurations": "{\r\n  \"hooks\": {\r\n    \"PreToolUse\": [\r\n      {\r\n        \"matcher\": \"Bash\",\r\n        \"hooks\": [\r\n          {\r\n            \"type\": \"command\",\r\n            \"command\": \"python3 ~/.claude/hooks/dangerous-command-guard.py\"\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### 2. Production File Protection\r\n\r\nPrevent modification of production config files:\r\n\r\n```json\r\n{\r\n  \"matcher\": \"Write|Edit\",\r\n  \"hooks\": [\r\n    {\r\n      \"type\": \"command\",\r\n      \"command\": \"FILE=$(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.file_path // empty'); if echo \\\"$FILE\\\" | grep -qE '(^|\\\\/)(production\\\\.env|\\\\.env\\\\.production|prod\\\\.config)$'; then echo 'ERROR: Cannot modify production config files' >&2; exit 2; fi\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### 3. Audit Logging\r\n\r\nLog all bash commands for compliance:\r\n\r\n```json\r\n{\r\n  \"matcher\": \"Bash\",\r\n  \"hooks\": [\r\n    {\r\n      \"type\": \"command\",\r\n      \"command\": \"echo \\\"[$(date -Iseconds)] User: $USER | Command: $(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.command')\\\" >> ~/.claude/audit.log\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**View audit log**:\r\n```bash\r\ntail -50 ~/.claude/audit.log\r\n```\r\n\r\n---",
    "Critical Rules": "./script.sh || { echo \"Script failed\" >&2; exit 1; }\r\n./cleanup.sh\r\n```\r\n\r\n---",
    "Hooks: Advanced Automation": "COMMAND=$(echo \"$CLAUDE_TOOL_INPUT\" | jq -r '.tool_input.command')\r\n\r\nif [ -f pnpm-lock.yaml ] && echo \"$COMMAND\" | grep -qE '^(npm|yarn) '; then\r\n  echo \"ERROR: This repo uses pnpm. Please use 'pnpm' instead of 'npm' or 'yarn'.\" >&2\r\n  exit 2\r\nfi\r\n\r\nif [ -f yarn.lock ] && echo \"$COMMAND\" | grep -qE '^(npm|pnpm) '; then\r\n  echo \"ERROR: This repo uses yarn. Please use 'yarn' instead of 'npm' or 'pnpm'.\" >&2\r\n  exit 2\r\nfi\r\n\r\nexit 0\r\n```\r\n\r\n### PostToolUse: The Cleanup Crew\r\n\r\n**Purpose**: Runs after successful tool execution (exit code 0 only)\r\n\r\n**Example**: Auto-format after file edits\r\n```json\r\n{\r\n  \"matcher\": \"Write|Edit\",\r\n  \"hooks\": [\r\n    {\r\n      \"type\": \"command\",\r\n      \"command\": \"FILE=$(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.file_path'); [ -f \\\"$FILE\\\" ] && prettier --write \\\"$FILE\\\" || true\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Example**: Run tests after code changes\r\n```json\r\n{\r\n  \"matcher\": \"Write|Edit\",\r\n  \"hooks\": [\r\n    {\r\n      \"type\": \"command\",\r\n      \"command\": \"FILE=$(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.file_path'); if echo \\\"$FILE\\\" | grep -qE '\\\\.(ts|tsx|js|jsx)$'; then npm test -- \\\"$FILE\\\"; fi\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### SessionStart: Environment Setup\r\n\r\n**Purpose**: Runs once at session start, sets up environment\r\n\r\n**Example**: Load project-specific environment\r\n```json\r\n{\r\n  \"hooks\": {\r\n    \"SessionStart\": [\r\n      {\r\n        \"matcher\": \"*\",\r\n        \"hooks\": [\r\n          {\r\n            \"type\": \"command\",\r\n            \"command\": \"[ -f .envrc ] && source .envrc || true; env > $CLAUDE_ENV_FILE\"\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**Environment Variables Available in Hooks**:\r\n- `$CLAUDE_TOOL_INPUT` - JSON string of tool call\r\n- `$CLAUDE_ENV_FILE` - Path to environment file\r\n- Standard env vars (`$HOME`, `$USER`, `$PWD`, etc.)\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- Claude Code CLI (latest version)\r\n- bash 4.0+ (persistent session support)\r\n\r\n**Optional (for specific features)**:\r\n- `jq` (JSON processing in hooks) - `brew install jq` / `apt install jq`\r\n- `gh` (GitHub CLI integration) - `brew install gh` / `apt install gh`\r\n- Python 3.7+ (for Python-based hooks)\r\n- direnv (environment management) - `brew install direnv`\r\n\r\n---",
    "Production Example": "This skill is based on real-world usage across:\r\n- **WordPress Auditor**: Git workflows, PR automation\r\n- **claude-skills repo**: Custom commands, hooks configuration\r\n- **Multiple client projects**: CLI tool orchestration\r\n\r\n**Measured Impact**:\r\n- Token savings: ~55% (vs manual trial-and-error)\r\n- Error prevention: 12 documented issues ‚Üí 0 occurrences\r\n- Time savings: ~40% faster workflows with parallel execution\r\n- Security: 100% dangerous command prevention with hooks\r\n\r\n---",
    "Official Documentation": "- **Bash Tool Reference**: https://docs.claude.com/en/docs/claude-code/tools\r\n- **Claude Code Hooks**: https://docs.claude.com/en/docs/claude-code/hooks\r\n- **Claude Code Best Practices**: https://www.anthropic.com/engineering/claude-code-best-practices\r\n- **Code Execution with MCP**: https://www.anthropic.com/engineering/code-execution-with-mcp\r\n- **Cloudflare Code Mode**: https://blog.cloudflare.com/code-mode/\r\n\r\n---",
    "Quick Start (10 Minutes)": "```\r\n\r\n**Golden Rule**: Use `&&` when you care about failures, `;` when you don't, and parallel calls when operations are independent.\r\n\r\n### 3. Configure Your First Hook\r\n\r\nHooks let you run code before/after tool execution. Here's a simple audit logger:\r\n\r\n```json\r\n{\r\n  \"hooks\": {\r\n    \"PreToolUse\": [\r\n      {\r\n        \"matcher\": \"Bash\",\r\n        \"hooks\": [\r\n          {\r\n            \"type\": \"command\",\r\n            \"command\": \"echo \\\"[$(date -Iseconds)] $(echo \\\"$CLAUDE_TOOL_INPUT\\\" | jq -r '.tool_input.command')\\\" >> ~/.claude/bash-audit.log\"\r\n          }\r\n        ]\r\n      }\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\nSave this to `~/.claude/settings.json` to log every bash command with timestamp.\r\n\r\n---",
    "Using Bundled Resources": "### Scripts (scripts/)\r\n\r\n**1. dangerous-command-guard.py**\r\nPurpose: PreToolUse hook to block dangerous bash patterns\r\nUsage: Configure in settings.json (see Security section)\r\n\r\n**2. bash-audit-logger.sh**\r\nPurpose: Log all bash commands with timestamps\r\nUsage: Configure as PreToolUse hook\r\n\r\n**3. package-manager-enforcer.sh**\r\nPurpose: Enforce pnpm/yarn/npm based on lockfile\r\nUsage: Configure as PreToolUse hook\r\n\r\n### References (references/)\r\n\r\n**1. git-workflows.md**\r\nDeep dive into git automation patterns, commit message formats, PR creation\r\n\r\n**2. hooks-examples.md**\r\nComplete hooks configuration examples for common scenarios\r\n\r\n**3. cli-tool-integration.md**\r\nHow to integrate custom CLI tools with Claude Code\r\n\r\n**4. security-best-practices.md**\r\nComprehensive security guide for bash automation\r\n\r\n**5. troubleshooting-guide.md**\r\nDetailed solutions for all 12 known issues\r\n\r\n### Templates (templates/)\r\n\r\n**1. settings.json**\r\nComplete settings.json with hooks examples\r\n\r\n**2. dangerous-commands.json**\r\nList of dangerous patterns to block\r\n\r\n**3. custom-command-template.md**\r\nTemplate for creating .claude/commands/ files\r\n\r\n**4. github-workflow.yml**\r\nGitHub Actions integration with Claude Code\r\n\r\n**5. .envrc.example**\r\ndirenv integration for environment management\r\n\r\n---",
    "Git Workflows (Production-Tested)": "git log main..HEAD --oneline\r\n```\r\n\r\n**Step 2**: Analyze ALL commits (not just latest!)\r\n- What changed since branch diverged from main?\r\n- What's the overall goal of this branch?\r\n- What needs testing?\r\n\r\n**Step 3**: Create PR with gh CLI\r\n```bash\r\ngh pr create --title \"feat: User Authentication\" --body \"$(cat <<'EOF'",
    "Custom Tools": "**mycli**: Internal deployment tool\r\nUsage: `mycli deploy --env production --service api`\r\nHelp: `mycli --help` for full options\r\nConfig: `.mycli.json` in project root\r\n```\r\n\r\n**Option 2**: Let Claude discover\r\n```markdown\r\nWhen encountering mycli commands, run `mycli --help` first to discover available options.\r\n```\r\n\r\n**Option 3**: Create custom command (`.claude/commands/deploy.md`)\r\n```markdown\r\nDeploy using our internal mycli tool:\r\n\r\n1. Run `mycli --version` to verify installation\r\n2. Check current environment: `mycli env current`\r\n3. Deploy to staging: `mycli deploy --env staging --service api`\r\n4. Run smoke tests: `mycli test smoke --env staging`\r\n5. If tests pass, deploy to production: `mycli deploy --env production --service api`\r\n```\r\n\r\n---"
  }
}