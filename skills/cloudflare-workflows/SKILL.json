{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/common-issues.md",
      "references/workflow-patterns.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-22\r\n**Dependencies**: cloudflare-worker-base (for Worker setup)\r\n**Latest Versions**: wrangler@4.44.0, @cloudflare/workers-types@4.20251014.0\r\n\r\n---\r\n\r\n\r\n### 1. Create a Workflow\r\n\r\nUse the Cloudflare Workflows starter template:\r\n\r\n```bash\r\nnpm create cloudflare@latest my-workflow -- --template cloudflare/workflows-starter --git --deploy false\r\ncd my-workflow\r\n```\r\n\r\n**What you get:**\r\n- WorkflowEntrypoint class template\r\n- Worker to trigger workflows\r\n- Complete wrangler.jsonc configuration\r\n\r\n### 2. Understand the Basic Structure\r\n\r\n**src/index.ts:**\r\n\r\n```typescript\r\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\r\n\r\ntype Env = {\r\n  MY_WORKFLOW: Workflow;\r\n};\r\n\r\ntype Params = {\r\n  userId: string;\r\n  email: string;\r\n};\r\n\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    // Access params from event.payload\r\n    const { userId, email } = event.payload;\r\n\r\n    // Step 1: Do some work\r\n    const result = await step.do('process user', async () => {\r\n      return { processed: true, userId };\r\n    });\r\n\r\n    // Step 2: Wait before next action\r\n    await step.sleep('wait 1 hour', '1 hour');\r\n\r\n    // Step 3: Continue workflow\r\n    await step.do('send email', async () => {\r\n      // Send email logic\r\n      return { sent: true, email };\r\n    });\r\n\r\n    // Optional: return final state\r\n    return { completed: true, userId };\r\n  }\r\n}\r\n\r\n// Worker to trigger workflow\r\nexport default {\r\n  async fetch(req: Request, env: Env): Promise<Response> {\r\n    // Create new workflow instance\r\n    const instance = await env.MY_WORKFLOW.create({\r\n      params: { userId: '123', email: 'user@example.com' }\r\n    });\r\n\r\n    return Response.json({\r\n      id: instance.id,\r\n      status: await instance.status()\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 3. Configure Wrangler\r\n\r\n**wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-workflow\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-22\",\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"my-workflow\",\r\n      \"binding\": \"MY_WORKFLOW\",\r\n      \"class_name\": \"MyWorkflow\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n### 4. Deploy and Test\r\n\r\n```bash\r\nnpm run deploy\r\n\r\ncurl https://my-workflow.<subdomain>.workers.dev/\r\n\r\nnpx wrangler workflows instances list my-workflow\r\n\r\n\r\n### List Workflow Instances\r\n\r\n```bash\r\nnpx wrangler workflows instances list my-workflow\r\n\r\nnpx wrangler workflows instances list my-workflow --status running\r\nnpx wrangler workflows instances list my-workflow --status complete\r\nnpx wrangler workflows instances list my-workflow --status errored\r\n```\r\n\r\n### Describe Instance\r\n\r\n```bash\r\nnpx wrangler workflows instances describe my-workflow <instance-id>\r\n\r\n```\r\n\r\n### Trigger Workflow (Development)\r\n\r\n```bash\r\nnpx wrangler deploy\r\n\r\n\r\n### Issue: \"Cannot perform I/O on behalf of a different request\"\r\n\r\n**Cause:** Trying to use I/O objects created in one request context from another request handler\r\n\r\n**Solution:** Always perform I/O within `step.do()` callbacks\r\n\r\n```typescript\r\n// ❌ Bad - I/O outside step\r\nconst response = await fetch('https://api.example.com/data');\r\nconst data = await response.json();\r\n\r\nawait step.do('use data', async () => {\r\n  // Using data from outside step's I/O context\r\n  return data;  // This will fail!\r\n});\r\n\r\n// ✅ Good - I/O inside step\r\nconst data = await step.do('fetch data', async () => {\r\n  const response = await fetch('https://api.example.com/data');\r\n  return await response.json();  // ✅ Correct\r\n});\r\n```\r\n\r\n---\r\n\r\n### Issue: NonRetryableError behaves differently in dev vs production\r\n\r\n**Known Issue:** Throwing NonRetryableError with empty message in dev mode causes retries, but works correctly in production\r\n\r\n**Workaround:** Always provide a message to NonRetryableError\r\n\r\n```typescript\r\n// ❌ May retry in dev\r\nthrow new NonRetryableError();\r\n\r\n// ✅ Works consistently\r\nthrow new NonRetryableError('User not found');\r\n```\r\n\r\n**Source:** [workers-sdk#10113](https://github.com/cloudflare/workers-sdk/issues/10113)\r\n\r\n---\r\n\r\n### Issue: \"The requested module 'cloudflare:workers' does not provide an export named 'WorkflowEvent'\"\r\n\r\n**Cause:** Incorrect import or outdated @cloudflare/workers-types\r\n\r\n**Solution:**\r\n\r\n```bash\r\nnpm install -D @cloudflare/workers-types@latest\r\n\r\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\r\nimport { NonRetryableError } from 'cloudflare:workflows';\r\n```\r\n\r\n---\r\n\r\n### Issue: Step returns undefined instead of expected value\r\n\r\n**Cause:** Step callback doesn't return a value\r\n\r\n**Solution:** Always return from step callbacks\r\n\r\n```typescript\r\n// ❌ Bad - no return\r\nconst result = await step.do('get data', async () => {\r\n  const data = await fetchData();\r\n  // Missing return!\r\n});\r\nconsole.log(result);  // undefined\r\n\r\n// ✅ Good - explicit return\r\nconst result = await step.do('get data', async () => {\r\n  const data = await fetchData();\r\n  return data;  // ✅\r\n});\r\n```\r\n\r\n---\r\n\r\n### Issue: Workflow instance stuck in \"running\" state\r\n\r\n**Possible causes:**\r\n1. Step is sleeping for long duration\r\n2. Step is waiting for event that never arrives\r\n3. Step is retrying with long backoff\r\n\r\n**Solution:**\r\n\r\n```bash\r\nnpx wrangler workflows instances describe my-workflow <instance-id>",
  "name": "cloudflare-workflows",
  "id": "cloudflare-workflows",
  "sections": {
    "Related Documentation": "- [Cloudflare Workflows Docs](https://developers.cloudflare.com/workflows/)\r\n- [Get Started Guide](https://developers.cloudflare.com/workflows/get-started/guide/)\r\n- [Workers API](https://developers.cloudflare.com/workflows/build/workers-api/)\r\n- [Sleeping and Retrying](https://developers.cloudflare.com/workflows/build/sleeping-and-retrying/)\r\n- [Events and Parameters](https://developers.cloudflare.com/workflows/build/events-and-parameters/)\r\n- [Limits](https://developers.cloudflare.com/workflows/reference/limits/)\r\n- [Pricing](https://developers.cloudflare.com/workflows/platform/pricing/)\r\n- [Changelog](https://developers.cloudflare.com/workflows/reference/changelog/)\r\n\r\n---\r\n\r\n**Last Updated**: 2025-10-22\r\n**Version**: 1.0.0\r\n**Maintainer**: Jeremy Dawes | jeremy@jezweb.net",
    "Never Do ❌": "1. **Never return functions from steps** - will throw serialization error\r\n2. **Never create circular references** - will fail to serialize\r\n3. **Never assume steps execute immediately** - they may retry or sleep\r\n4. **Never use blocking operations** - use step.do() for async work\r\n5. **Never exceed 128 KB payload/output** - will fail\r\n6. **Never retry non-idempotent operations infinitely** - use retry limits\r\n7. **Never ignore serialization errors** - fix the data structure\r\n8. **Never use workflows for real-time operations** - use Durable Objects instead\r\n9. **Never skip error handling for critical steps** - wrap in try-catch or use NonRetryableError\r\n10. **Never assume step order is guaranteed across retries** - each step is independent\r\n\r\n---",
    "Workflow Patterns": "### Pattern 1: Long-Running Process\r\n\r\n```typescript\r\nexport class VideoProcessingWorkflow extends WorkflowEntrypoint<Env, VideoParams> {\r\n  async run(event: WorkflowEvent<VideoParams>, step: WorkflowStep) {\r\n    const { videoId } = event.payload;\r\n\r\n    // Step 1: Upload to processing service\r\n    const uploadResult = await step.do('upload video', async () => {\r\n      const video = await this.env.MY_BUCKET.get(`videos/${videoId}`);\r\n      const response = await fetch('https://processor.example.com/upload', {\r\n        method: 'POST',\r\n        body: video?.body\r\n      });\r\n      return await response.json();\r\n    });\r\n\r\n    // Step 2: Wait for processing (could take hours)\r\n    await step.sleep('wait for initial processing', '10 minutes');\r\n\r\n    // Step 3: Poll for completion\r\n    let processed = false;\r\n    let attempts = 0;\r\n\r\n    while (!processed && attempts < 20) {\r\n      const status = await step.do(`check status attempt ${attempts}`, async () => {\r\n        const response = await fetch(\r\n          `https://processor.example.com/status/${uploadResult.jobId}`\r\n        );\r\n        return await response.json();\r\n      });\r\n\r\n      if (status.complete) {\r\n        processed = true;\r\n      } else {\r\n        attempts++;\r\n        await step.sleep(`wait before retry ${attempts}`, '5 minutes');\r\n      }\r\n    }\r\n\r\n    // Step 4: Download processed video\r\n    await step.do('download processed video', async () => {\r\n      const response = await fetch(uploadResult.downloadUrl);\r\n      const processed = await response.blob();\r\n      await this.env.MY_BUCKET.put(`processed/${videoId}`, processed);\r\n    });\r\n\r\n    return { videoId, status: 'complete' };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: Event-Driven Approval Flow\r\n\r\n```typescript\r\nexport class ApprovalWorkflow extends WorkflowEntrypoint<Env, ApprovalParams> {\r\n  async run(event: WorkflowEvent<ApprovalParams>, step: WorkflowStep) {\r\n    const { requestId, requesterId } = event.payload;\r\n\r\n    // Step 1: Create approval request\r\n    await step.do('create approval request', async () => {\r\n      await this.env.DB.prepare(\r\n        'INSERT INTO approvals (id, requester_id, status) VALUES (?, ?, ?)'\r\n      ).bind(requestId, requesterId, 'pending').run();\r\n    });\r\n\r\n    // Step 2: Send notification to approvers\r\n    await step.do('notify approvers', async () => {\r\n      await sendNotification(requestId);\r\n    });\r\n\r\n    // Step 3: Wait for approval (max 7 days)\r\n    let approvalEvent;\r\n\r\n    try {\r\n      approvalEvent = await step.waitForEvent<ApprovalEvent>(\r\n        'wait for approval decision',\r\n        { type: 'approval-decision', timeout: '7 days' }\r\n      );\r\n    } catch (error) {\r\n      // Timeout - auto-reject\r\n      await step.do('auto-reject due to timeout', async () => {\r\n        await this.env.DB.prepare(\r\n          'UPDATE approvals SET status = ? WHERE id = ?'\r\n        ).bind('rejected', requestId).run();\r\n      });\r\n\r\n      return { requestId, status: 'rejected', reason: 'timeout' };\r\n    }\r\n\r\n    // Step 4: Process decision\r\n    await step.do('process approval decision', async () => {\r\n      await this.env.DB.prepare(\r\n        'UPDATE approvals SET status = ?, approver_id = ? WHERE id = ?'\r\n      ).bind(approvalEvent.approved ? 'approved' : 'rejected', approvalEvent.approverId, requestId).run();\r\n    });\r\n\r\n    // Step 5: Execute approved action (if approved)\r\n    if (approvalEvent.approved) {\r\n      await step.do('execute approved action', async () => {\r\n        // Execute the action\r\n      });\r\n    }\r\n\r\n    return { requestId, status: approvalEvent.approved ? 'approved' : 'rejected' };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 3: Scheduled Workflow\r\n\r\n```typescript\r\nexport class DailyReportWorkflow extends WorkflowEntrypoint<Env, ReportParams> {\r\n  async run(event: WorkflowEvent<ReportParams>, step: WorkflowStep) {\r\n    // Calculate next 9am UTC\r\n    const now = new Date();\r\n    const tomorrow9am = new Date();\r\n    tomorrow9am.setUTCDate(tomorrow9am.getUTCDate() + 1);\r\n    tomorrow9am.setUTCHours(9, 0, 0, 0);\r\n\r\n    // Sleep until tomorrow 9am\r\n    await step.sleepUntil('wait until 9am tomorrow', tomorrow9am);\r\n\r\n    // Generate report\r\n    const report = await step.do('generate daily report', async () => {\r\n      const results = await this.env.DB.prepare(\r\n        'SELECT * FROM metrics WHERE date = ?'\r\n      ).bind(now.toISOString().split('T')[0]).all();\r\n\r\n      return {\r\n        date: now.toISOString().split('T')[0],\r\n        metrics: results.results\r\n      };\r\n    });\r\n\r\n    // Send report\r\n    await step.do('send report', async () => {\r\n      await sendEmail({\r\n        to: event.payload.recipients,\r\n        subject: `Daily Report - ${report.date}`,\r\n        body: formatReport(report.metrics)\r\n      });\r\n    });\r\n\r\n    return { sent: true, date: report.date };\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Pattern 4: Workflow Chaining\r\n\r\n```typescript\r\nexport class OrderWorkflow extends WorkflowEntrypoint<Env, OrderParams> {\r\n  async run(event: WorkflowEvent<OrderParams>, step: WorkflowStep) {\r\n    const { orderId } = event.payload;\r\n\r\n    // Step 1: Process payment\r\n    const paymentResult = await step.do('process payment', async () => {\r\n      return await processPayment(orderId);\r\n    });\r\n\r\n    // Step 2: Trigger fulfillment workflow\r\n    const fulfillmentInstance = await step.do('start fulfillment', async () => {\r\n      return await this.env.FULFILLMENT_WORKFLOW.create({\r\n        params: {\r\n          orderId,\r\n          paymentId: paymentResult.id\r\n        }\r\n      });\r\n    });\r\n\r\n    // Step 3: Wait for fulfillment to complete\r\n    await step.sleep('wait for fulfillment', '5 minutes');\r\n\r\n    // Step 4: Check fulfillment status\r\n    const fulfillmentStatus = await step.do('check fulfillment', async () => {\r\n      const instance = await this.env.FULFILLMENT_WORKFLOW.get(fulfillmentInstance.id);\r\n      return await instance.status();\r\n    });\r\n\r\n    if (fulfillmentStatus.status === 'complete') {\r\n      // Step 5: Send confirmation\r\n      await step.do('send order confirmation', async () => {\r\n        await sendConfirmation(orderId);\r\n      });\r\n    }\r\n\r\n    return { orderId, status: 'complete' };\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Always Do ✅": "1. **Use descriptive step names** - \"fetch user data\", not \"step 1\"\r\n2. **Return serializable values only** - primitives, arrays, plain objects\r\n3. **Use NonRetryableError for terminal errors** - auth failures, invalid input\r\n4. **Configure retry limits** - avoid infinite retries unless necessary\r\n5. **Catch errors for optional steps** - use try-catch if step can fail gracefully\r\n6. **Use exponential backoff for retries** - default backoff for most cases\r\n7. **Validate inputs early** - fail fast with NonRetryableError if invalid\r\n8. **Store workflow instance IDs** - save to DB/KV to query status later\r\n9. **Use waitForEvent for human-in-loop** - approvals, external confirmations\r\n10. **Monitor workflow metrics** - track success rates and errors\r\n\r\n---",
    "Pricing": "**Requires Workers Paid plan** ($5/month)\r\n\r\n**Workflow Executions:**\r\n- First 10,000,000 step executions/month: **FREE**\r\n- After that: **$0.30 per million step executions**\r\n\r\n**What counts as a step execution:**\r\n- Each `step.do()` call\r\n- Each retry of a step\r\n- `step.sleep()`, `step.sleepUntil()`, `step.waitForEvent()` do NOT count\r\n\r\n**Cost examples:**\r\n- Workflow with 5 steps, no retries: **5 step executions**\r\n- Workflow with 3 steps, 1 step retries 2 times: **5 step executions** (3 + 2)\r\n- 10M simple workflows/month (5 steps each): ((50M - 10M) / 1M) × $0.30 = **$12/month**\r\n\r\n---",
    "Step Methods": "### step.do() - Execute Work\r\n\r\n```typescript\r\nstep.do<T>(\r\n  name: string,\r\n  config?: WorkflowStepConfig,\r\n  callback: () => Promise<T>\r\n): Promise<T>\r\n```\r\n\r\n**OR** (config is optional):\r\n\r\n```typescript\r\nstep.do<T>(\r\n  name: string,\r\n  callback: () => Promise<T>\r\n): Promise<T>\r\n```\r\n\r\n**Parameters:**\r\n- `name` - Step name (for observability)\r\n- `config` (optional) - Retry configuration\r\n- `callback` - Async function that does the work\r\n\r\n**Returns:**\r\n- The value returned from callback (must be serializable)\r\n\r\n**Example:**\r\n\r\n```typescript\r\n// Simple step\r\nconst files = await step.do('fetch files', async () => {\r\n  const response = await fetch('https://api.example.com/files');\r\n  return await response.json();\r\n});\r\n\r\n// Step with retry config\r\nconst result = await step.do(\r\n  'call payment API',\r\n  {\r\n    retries: {\r\n      limit: 10,\r\n      delay: '10 seconds',\r\n      backoff: 'exponential'\r\n    },\r\n    timeout: '5 minutes'\r\n  },\r\n  async () => {\r\n    const response = await fetch('https://payment-api.example.com/charge', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ amount: 100 })\r\n    });\r\n    return await response.json();\r\n  }\r\n);\r\n```\r\n\r\n**CRITICAL - Serialization:**\r\n- Return value must be JSON serializable\r\n- ✅ Allowed: string, number, boolean, Array, Object, null\r\n- ❌ Forbidden: Function, Symbol, circular references, undefined\r\n- Step will throw error if return value isn't serializable\r\n\r\n---\r\n\r\n### step.sleep() - Relative Sleep\r\n\r\n```typescript\r\nstep.sleep(name: string, duration: WorkflowDuration): Promise<void>\r\n```\r\n\r\n**Parameters:**\r\n- `name` - Step name\r\n- `duration` - Number (milliseconds) or human-readable string\r\n\r\n**Accepted units:**\r\n- `\"second\"` / `\"seconds\"`\r\n- `\"minute\"` / `\"minutes\"`\r\n- `\"hour\"` / `\"hours\"`\r\n- `\"day\"` / `\"days\"`\r\n- `\"week\"` / `\"weeks\"`\r\n- `\"month\"` / `\"months\"`\r\n- `\"year\"` / `\"years\"`\r\n\r\n**Examples:**\r\n\r\n```typescript\r\n// Sleep for 5 minutes\r\nawait step.sleep('wait 5 minutes', '5 minutes');\r\n\r\n// Sleep for 1 hour\r\nawait step.sleep('hourly delay', '1 hour');\r\n\r\n// Sleep for 2 days\r\nawait step.sleep('wait 2 days', '2 days');\r\n\r\n// Sleep using milliseconds\r\nawait step.sleep('wait 30 seconds', 30000);\r\n\r\n// Common pattern: schedule daily task\r\nawait step.do('send daily report', async () => {\r\n  // Send report\r\n});\r\nawait step.sleep('wait until tomorrow', '1 day');\r\n// Workflow continues next day\r\n```\r\n\r\n**Priority:**\r\n- Workflows resuming from sleep take priority over new instances\r\n- Ensures older workflows complete before new ones start\r\n\r\n---\r\n\r\n### step.sleepUntil() - Sleep to Specific Date\r\n\r\n```typescript\r\nstep.sleepUntil(\r\n  name: string,\r\n  timestamp: Date | number\r\n): Promise<void>\r\n```\r\n\r\n**Parameters:**\r\n- `name` - Step name\r\n- `timestamp` - Date object or UNIX timestamp (milliseconds)\r\n\r\n**Examples:**\r\n\r\n```typescript\r\n// Sleep until specific date\r\nconst launchDate = new Date('2025-12-25T00:00:00Z');\r\nawait step.sleepUntil('wait for launch', launchDate);\r\n\r\n// Sleep until UNIX timestamp\r\nconst timestamp = Date.parse('24 Oct 2024 13:00:00 UTC');\r\nawait step.sleepUntil('wait until time', timestamp);\r\n\r\n// Sleep until next Monday 9am UTC\r\nconst nextMonday = new Date();\r\nnextMonday.setDate(nextMonday.getDate() + ((1 + 7 - nextMonday.getDay()) % 7 || 7));\r\nnextMonday.setUTCHours(9, 0, 0, 0);\r\nawait step.sleepUntil('wait until Monday 9am', nextMonday);\r\n\r\n// Schedule work at specific time\r\nawait step.do('prepare campaign', async () => {\r\n  // Prepare marketing campaign\r\n});\r\n\r\nconst campaignLaunch = new Date('2025-11-01T12:00:00Z');\r\nawait step.sleepUntil('wait for campaign launch', campaignLaunch);\r\n\r\nawait step.do('launch campaign', async () => {\r\n  // Launch campaign\r\n});\r\n```\r\n\r\n---\r\n\r\n### step.waitForEvent() - Wait for External Event\r\n\r\n```typescript\r\nstep.waitForEvent<T>(\r\n  name: string,\r\n  options: { type: string; timeout?: string | number }\r\n): Promise<T>\r\n```\r\n\r\n**Parameters:**\r\n- `name` - Step name\r\n- `options.type` - Event type to match\r\n- `options.timeout` (optional) - Max wait time (default: 24 hours)\r\n\r\n**Returns:**\r\n- The event payload sent via `instance.sendEvent()`\r\n\r\n**Example:**\r\n\r\n```typescript\r\nexport class PaymentWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    // Create payment intent\r\n    await step.do('create payment intent', async () => {\r\n      // Call Stripe API\r\n    });\r\n\r\n    // Wait for webhook from Stripe (max 1 hour)\r\n    const webhookData = await step.waitForEvent<StripeWebhook>(\r\n      'wait for payment confirmation',\r\n      { type: 'stripe-webhook', timeout: '1 hour' }\r\n    );\r\n\r\n    // Continue based on webhook\r\n    if (webhookData.status === 'succeeded') {\r\n      await step.do('fulfill order', async () => {\r\n        // Fulfill order\r\n      });\r\n    } else {\r\n      await step.do('handle failed payment', async () => {\r\n        // Handle failure\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\n// Worker receives webhook and sends event to workflow\r\nexport default {\r\n  async fetch(req: Request, env: Env): Promise<Response> {\r\n    if (req.url.includes('/webhook/stripe')) {\r\n      const webhookData = await req.json();\r\n\r\n      // Get workflow instance by ID (stored when created)\r\n      const instance = await env.PAYMENT_WORKFLOW.get(instanceId);\r\n\r\n      // Send event to waiting workflow\r\n      await instance.sendEvent({\r\n        type: 'stripe-webhook',\r\n        payload: webhookData\r\n      });\r\n\r\n      return new Response('OK');\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**Timeout behavior:**\r\n- If timeout expires, throws error and workflow can retry or fail\r\n- Wrap in try-catch if timeout should not fail workflow\r\n\r\n```typescript\r\ntry {\r\n  const event = await step.waitForEvent('wait for user input', {\r\n    type: 'user-submitted',\r\n    timeout: '10 minutes'\r\n  });\r\n} catch (error) {\r\n  // Timeout occurred - handle gracefully\r\n  await step.do('send reminder', async () => {\r\n    // Send reminder to user\r\n  });\r\n}\r\n```\r\n\r\n---",
    "WorkflowEntrypoint Class": "### Extend WorkflowEntrypoint\r\n\r\nEvery Workflow must extend `WorkflowEntrypoint` and implement a `run()` method:\r\n\r\n```typescript\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    // Workflow steps here\r\n  }\r\n}\r\n```\r\n\r\n**Type Parameters:**\r\n- `Env` - Environment bindings (KV, D1, R2, etc.)\r\n- `Params` - Type of workflow parameters passed via `event.payload`\r\n\r\n### run() Method\r\n\r\n```typescript\r\nasync run(\r\n  event: WorkflowEvent<Params>,\r\n  step: WorkflowStep\r\n): Promise<T | void>\r\n```\r\n\r\n**Parameters:**\r\n- `event` - Contains workflow metadata and payload\r\n- `step` - Provides step methods (do, sleep, sleepUntil, waitForEvent)\r\n\r\n**Returns:**\r\n- Optional return value (must be serializable)\r\n- Return value available via instance.status()\r\n\r\n**Example:**\r\n\r\n```typescript\r\nexport class OrderWorkflow extends WorkflowEntrypoint<Env, OrderParams> {\r\n  async run(event: WorkflowEvent<OrderParams>, step: WorkflowStep) {\r\n    const { orderId, customerId } = event.payload;\r\n\r\n    // Access bindings via this.env\r\n    const order = await this.env.DB.prepare(\r\n      'SELECT * FROM orders WHERE id = ?'\r\n    ).bind(orderId).first();\r\n\r\n    const result = await step.do('process payment', async () => {\r\n      // Payment processing\r\n      return { paid: true, amount: order.total };\r\n    });\r\n\r\n    // Return final state\r\n    return {\r\n      orderId,\r\n      status: 'completed',\r\n      paidAmount: result.amount\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n---",
    "State Persistence": "### What Can Be Persisted\r\n\r\nWorkflows automatically persist state returned from `step.do()`:\r\n\r\n**✅ Serializable Types:**\r\n- Primitives: `string`, `number`, `boolean`, `null`\r\n- Arrays: `[1, 2, 3]`, `['a', 'b', 'c']`\r\n- Objects: `{ key: 'value' }`, `{ nested: { data: true } }`\r\n- Nested structures: `{ users: [{ id: 1, name: 'Alice' }] }`\r\n\r\n**❌ Non-Serializable Types:**\r\n- Functions: `() => {}`\r\n- Symbols: `Symbol('key')`\r\n- Circular references: `const obj = {}; obj.self = obj;`\r\n- undefined (use null instead)\r\n- Class instances (serialize to plain objects)\r\n\r\n**Example - Correct Serialization:**\r\n\r\n```typescript\r\n// ✅ Good - all values serializable\r\nconst result = await step.do('fetch data', async () => {\r\n  return {\r\n    users: [\r\n      { id: 1, name: 'Alice', active: true },\r\n      { id: 2, name: 'Bob', active: false }\r\n    ],\r\n    timestamp: Date.now(),\r\n    metadata: null\r\n  };\r\n});\r\n\r\n// ❌ Bad - contains function\r\nconst bad = await step.do('bad example', async () => {\r\n  return {\r\n    data: [1, 2, 3],\r\n    transform: (x) => x * 2  // ❌ Function not serializable\r\n  };\r\n});\r\n// This will throw an error!\r\n```\r\n\r\n### Access State Across Steps\r\n\r\n```typescript\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    // Step 1: Get data\r\n    const userData = await step.do('fetch user', async () => {\r\n      return { id: 123, email: 'user@example.com' };\r\n    });\r\n\r\n    // Step 2: Use data from step 1\r\n    const orderData = await step.do('create order', async () => {\r\n      return {\r\n        userId: userData.id,      // ✅ Access previous step's data\r\n        userEmail: userData.email,\r\n        orderId: 'ORD-456'\r\n      };\r\n    });\r\n\r\n    // Step 3: Use data from step 1 and 2\r\n    await step.do('send confirmation', async () => {\r\n      await sendEmail({\r\n        to: userData.email,       // ✅ Still accessible\r\n        subject: `Order ${orderData.orderId} confirmed`\r\n      });\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Triggering Workflows": "### From Workers\r\n\r\n**Configure binding in wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"trigger-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-22\",\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"my-workflow\",\r\n      \"binding\": \"MY_WORKFLOW\",\r\n      \"class_name\": \"MyWorkflow\",\r\n      \"script_name\": \"workflow-worker\"  // If workflow is in different Worker\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Trigger from Worker:**\r\n\r\n```typescript\r\ntype Env = {\r\n  MY_WORKFLOW: Workflow;\r\n};\r\n\r\nexport default {\r\n  async fetch(req: Request, env: Env): Promise<Response> {\r\n    // Create new workflow instance\r\n    const instance = await env.MY_WORKFLOW.create({\r\n      params: {\r\n        userId: '123',\r\n        email: 'user@example.com'\r\n      }\r\n    });\r\n\r\n    // Return instance ID\r\n    return Response.json({\r\n      id: instance.id,\r\n      status: await instance.status()\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### Get Instance Status\r\n\r\n```typescript\r\n// Get instance by ID\r\nconst instance = await env.MY_WORKFLOW.get(instanceId);\r\n\r\n// Get status\r\nconst status = await instance.status();\r\n\r\nconsole.log(status);\r\n// {\r\n//   status: 'running' | 'complete' | 'errored' | 'queued' | 'unknown',\r\n//   error: string | null,\r\n//   output: any  // Return value from run() if complete\r\n// }\r\n```\r\n\r\n### Send Events to Running Instance\r\n\r\n```typescript\r\n// Get instance\r\nconst instance = await env.MY_WORKFLOW.get(instanceId);\r\n\r\n// Send event (will be received by step.waitForEvent)\r\nawait instance.sendEvent({\r\n  type: 'user-action',\r\n  payload: { action: 'approved' }\r\n});\r\n```\r\n\r\n### Pause and Resume\r\n\r\n```typescript\r\n// Pause instance\r\nawait instance.pause();\r\n\r\n// Resume instance\r\nawait instance.resume();\r\n\r\n// Terminate instance\r\nawait instance.terminate();\r\n```\r\n\r\n---",
    "Production Checklist": "Before deploying workflows to production:\r\n\r\n- [ ] All steps have descriptive names\r\n- [ ] Retry limits configured for all steps\r\n- [ ] NonRetryableError used for terminal errors\r\n- [ ] Critical steps have error handling\r\n- [ ] Optional steps wrapped in try-catch\r\n- [ ] No non-serializable values returned\r\n- [ ] Payload sizes under 128 KB\r\n- [ ] Workflow duration under 30 days\r\n- [ ] Instance IDs stored for status queries\r\n- [ ] Monitoring and alerting configured\r\n- [ ] waitForEvent timeouts configured\r\n- [ ] Tested in development environment\r\n- [ ] Tested retry behavior\r\n- [ ] Tested error scenarios\r\n\r\n---",
    "WorkflowStepConfig": "Configure retry behavior for individual steps:\r\n\r\n```typescript\r\ninterface WorkflowStepConfig {\r\n  retries?: {\r\n    limit: number;          // Max retry attempts (Infinity allowed)\r\n    delay: string | number; // Delay between retries\r\n    backoff?: 'constant' | 'linear' | 'exponential';\r\n  };\r\n  timeout?: string | number; // Max time per attempt\r\n}\r\n```\r\n\r\n### Default Configuration\r\n\r\nIf no config provided, Workflows uses:\r\n\r\n```typescript\r\n{\r\n  retries: {\r\n    limit: 5,\r\n    delay: 10000,      // 10 seconds\r\n    backoff: 'exponential'\r\n  },\r\n  timeout: '10 minutes'\r\n}\r\n```\r\n\r\n### Retry Examples\r\n\r\n**Constant Backoff (same delay each time):**\r\n\r\n```typescript\r\nawait step.do(\r\n  'send email',\r\n  {\r\n    retries: {\r\n      limit: 3,\r\n      delay: '30 seconds',\r\n      backoff: 'constant'  // Always wait 30 seconds\r\n    }\r\n  },\r\n  async () => {\r\n    // Send email\r\n  }\r\n);\r\n```\r\n\r\n**Linear Backoff (increasing delay):**\r\n\r\n```typescript\r\nawait step.do(\r\n  'poll API',\r\n  {\r\n    retries: {\r\n      limit: 5,\r\n      delay: '1 minute',\r\n      backoff: 'linear'  // 1m, 2m, 3m, 4m, 5m\r\n    }\r\n  },\r\n  async () => {\r\n    // Poll API\r\n  }\r\n);\r\n```\r\n\r\n**Exponential Backoff (recommended for most cases):**\r\n\r\n```typescript\r\nawait step.do(\r\n  'call rate-limited API',\r\n  {\r\n    retries: {\r\n      limit: 10,\r\n      delay: '10 seconds',\r\n      backoff: 'exponential'  // 10s, 20s, 40s, 80s, 160s, ...\r\n    },\r\n    timeout: '5 minutes'\r\n  },\r\n  async () => {\r\n    // API call\r\n  }\r\n);\r\n```\r\n\r\n**Unlimited Retries:**\r\n\r\n```typescript\r\nawait step.do(\r\n  'critical operation',\r\n  {\r\n    retries: {\r\n      limit: Infinity,  // Retry forever\r\n      delay: '1 minute',\r\n      backoff: 'exponential'\r\n    }\r\n  },\r\n  async () => {\r\n    // Operation that must succeed eventually\r\n  }\r\n);\r\n```\r\n\r\n**No Retries:**\r\n\r\n```typescript\r\nawait step.do(\r\n  'non-idempotent operation',\r\n  {\r\n    retries: {\r\n      limit: 0  // Fail immediately on error\r\n    }\r\n  },\r\n  async () => {\r\n    // One-time operation\r\n  }\r\n);\r\n```\r\n\r\n---",
    "Limits": "| Feature | Limit |\r\n|---------|-------|\r\n| **Max workflow duration** | 30 days |\r\n| **Max steps per workflow** | 10,000 |\r\n| **Max sleep/sleepUntil duration** | 30 days |\r\n| **Max step timeout** | 15 minutes |\r\n| **Max concurrent instances** | Unlimited (autoscales) |\r\n| **Max payload size** | 128 KB |\r\n| **Max step output size** | 128 KB |\r\n| **Max waitForEvent timeout** | 30 days |\r\n| **Max retry limit** | Infinity (configurable) |\r\n\r\n**Notes:**\r\n- `step.sleep()` and `step.sleepUntil()` do NOT count toward 10,000 step limit\r\n- Workflows can run for up to 30 days total\r\n- Each step execution limited to 15 minutes max\r\n- Retries count as separate attempts, not separate steps\r\n\r\n---",
    "Troubleshooting": "```\r\n\r\n---",
    "Wrangler Commands": "curl https://my-workflow.<subdomain>.workers.dev/\r\n```\r\n\r\n---",
    "Quick Start (10 Minutes)": "npx wrangler workflows instances describe my-workflow <instance-id>\r\n```\r\n\r\n---",
    "Error Handling": "### NonRetryableError\r\n\r\nForce workflow to fail immediately without retrying:\r\n\r\n```typescript\r\nimport { WorkflowEntrypoint, WorkflowStep, WorkflowEvent } from 'cloudflare:workers';\r\nimport { NonRetryableError } from 'cloudflare:workflows';\r\n\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    await step.do('validate input', async () => {\r\n      if (!event.payload.userId) {\r\n        throw new NonRetryableError('userId is required');\r\n      }\r\n\r\n      // Validate user exists\r\n      const user = await this.env.DB.prepare(\r\n        'SELECT * FROM users WHERE id = ?'\r\n      ).bind(event.payload.userId).first();\r\n\r\n      if (!user) {\r\n        // Terminal error - retrying won't help\r\n        throw new NonRetryableError('User not found');\r\n      }\r\n\r\n      return user;\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n**When to use NonRetryableError:**\r\n- ✅ Authentication/authorization failures\r\n- ✅ Invalid input that won't change\r\n- ✅ Resource doesn't exist (404)\r\n- ✅ Validation errors\r\n- ❌ Network failures (should retry)\r\n- ❌ Rate limits (should retry with backoff)\r\n- ❌ Temporary service outages (should retry)\r\n\r\n---\r\n\r\n### Catch Errors to Continue Workflow\r\n\r\nPrevent entire workflow from failing by catching step errors:\r\n\r\n```typescript\r\nexport class MyWorkflow extends WorkflowEntrypoint<Env, Params> {\r\n  async run(event: WorkflowEvent<Params>, step: WorkflowStep) {\r\n    // Critical step - workflow fails if this fails\r\n    await step.do('process payment', async () => {\r\n      // Payment processing\r\n    });\r\n\r\n    // Optional step - workflow continues even if it fails\r\n    try {\r\n      await step.do('send confirmation email', async () => {\r\n        // Email sending\r\n      });\r\n    } catch (error) {\r\n      console.log(`Email failed: ${error.message}`);\r\n\r\n      // Do cleanup or alternative action\r\n      await step.do('log email failure', async () => {\r\n        await this.env.DB.prepare(\r\n          'INSERT INTO failed_emails (user_id, error) VALUES (?, ?)'\r\n        ).bind(event.payload.userId, error.message).run();\r\n      });\r\n    }\r\n\r\n    // Workflow continues\r\n    await step.do('update order status', async () => {\r\n      // Update status\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n**Pattern: Graceful degradation:**\r\n\r\n```typescript\r\n// Try primary service, fall back to secondary\r\nlet result;\r\n\r\ntry {\r\n  result = await step.do('call primary API', async () => {\r\n    return await callPrimaryAPI();\r\n  });\r\n} catch (error) {\r\n  console.log('Primary API failed, trying backup');\r\n\r\n  result = await step.do('call backup API', async () => {\r\n    return await callBackupAPI();\r\n  });\r\n}\r\n```\r\n\r\n---",
    "Observability": "### Built-in Metrics\r\n\r\nWorkflows automatically track:\r\n- **Instance status**: queued, running, complete, errored, paused\r\n- **Step execution**: start/end times, duration, success/failure\r\n- **Retry history**: attempts, errors, delays\r\n- **Sleep state**: when workflow will wake up\r\n- **Output**: return values from steps and run()\r\n\r\n### View Metrics in Dashboard\r\n\r\nAccess via Cloudflare dashboard:\r\n1. Workers & Pages\r\n2. Select your workflow\r\n3. View instances and metrics\r\n\r\n**Metrics include:**\r\n- Total instances created\r\n- Success/error rates\r\n- Average execution time\r\n- Step-level performance\r\n\r\n### Programmatic Access\r\n\r\n```typescript\r\n// Get instance status\r\nconst instance = await env.MY_WORKFLOW.get(instanceId);\r\nconst status = await instance.status();\r\n\r\nconsole.log(status);\r\n// {\r\n//   status: 'complete',\r\n//   error: null,\r\n//   output: { userId: '123', status: 'processed' }\r\n// }\r\n```\r\n\r\n---"
  }
}