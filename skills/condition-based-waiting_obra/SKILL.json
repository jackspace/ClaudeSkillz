{
  "sections": {
    "When Arbitrary Timeout IS Correct": "```typescript\r\n// Tool ticks every 100ms - need 2 ticks to verify partial output\r\nawait waitForEvent(manager, 'TOOL_STARTED'); // First: wait for condition\r\nawait new Promise(r => setTimeout(r, 200));   // Then: wait for timed behavior\r\n// 200ms = 2 ticks at 100ms intervals - documented and justified\r\n```\r\n\r\n**Requirements:**\r\n1. First wait for triggering condition\r\n2. Based on known timing (not guessing)\r\n3. Comment explaining WHY",
    "When to Use": "```dot\r\ndigraph when_to_use {\r\n    \"Test uses setTimeout/sleep?\" [shape=diamond];\r\n    \"Testing timing behavior?\" [shape=diamond];\r\n    \"Document WHY timeout needed\" [shape=box];\r\n    \"Use condition-based waiting\" [shape=box];\r\n\r\n    \"Test uses setTimeout/sleep?\" -> \"Testing timing behavior?\" [label=\"yes\"];\r\n    \"Testing timing behavior?\" -> \"Document WHY timeout needed\" [label=\"yes\"];\r\n    \"Testing timing behavior?\" -> \"Use condition-based waiting\" [label=\"no\"];\r\n}\r\n```\r\n\r\n**Use when:**\r\n- Tests have arbitrary delays (`setTimeout`, `sleep`, `time.sleep()`)\r\n- Tests are flaky (pass sometimes, fail under load)\r\n- Tests timeout when run in parallel\r\n- Waiting for async operations to complete\r\n\r\n**Don't use when:**\r\n- Testing actual timing behavior (debounce, throttle intervals)\r\n- Always document WHY if using arbitrary timeout",
    "Common Mistakes": "**❌ Polling too fast:** `setTimeout(check, 1)` - wastes CPU\r\n**✅ Fix:** Poll every 10ms\r\n\r\n**❌ No timeout:** Loop forever if condition never met\r\n**✅ Fix:** Always include timeout with clear error\r\n\r\n**❌ Stale data:** Cache state before loop\r\n**✅ Fix:** Call getter inside loop for fresh data",
    "Overview": "Flaky tests often guess at timing with arbitrary delays. This creates race conditions where tests pass on fast machines but fail under load or in CI.\r\n\r\n**Core principle:** Wait for the actual condition you care about, not a guess about how long it takes.",
    "Implementation": "Generic polling function:\r\n```typescript\r\nasync function waitFor<T>(\r\n  condition: () => T | undefined | null | false,\r\n  description: string,\r\n  timeoutMs = 5000\r\n): Promise<T> {\r\n  const startTime = Date.now();\r\n\r\n  while (true) {\r\n    const result = condition();\r\n    if (result) return result;\r\n\r\n    if (Date.now() - startTime > timeoutMs) {\r\n      throw new Error(`Timeout waiting for ${description} after ${timeoutMs}ms`);\r\n    }\r\n\r\n    await new Promise(r => setTimeout(r, 10)); // Poll every 10ms\r\n  }\r\n}\r\n```\r\n\r\nSee @example.ts for complete implementation with domain-specific helpers (`waitForEvent`, `waitForEventCount`, `waitForEventMatch`) from actual debugging session.",
    "Quick Patterns": "| Scenario | Pattern |\r\n|----------|---------|\r\n| Wait for event | `waitFor(() => events.find(e => e.type === 'DONE'))` |\r\n| Wait for state | `waitFor(() => machine.state === 'ready')` |\r\n| Wait for count | `waitFor(() => items.length >= 5)` |\r\n| Wait for file | `waitFor(() => fs.existsSync(path))` |\r\n| Complex condition | `waitFor(() => obj.ready && obj.value > 10)` |",
    "Core Pattern": "```typescript\r\n// ❌ BEFORE: Guessing at timing\r\nawait new Promise(r => setTimeout(r, 50));\r\nconst result = getResult();\r\nexpect(result).toBeDefined();\r\n\r\n// ✅ AFTER: Waiting for condition\r\nawait waitFor(() => getResult() !== undefined);\r\nconst result = getResult();\r\nexpect(result).toBeDefined();\r\n```",
    "Real-World Impact": "From debugging session (2025-10-03):\r\n- Fixed 15 flaky tests across 3 files\r\n- Pass rate: 60% → 100%\r\n- Execution time: 40% faster\r\n- No more race conditions"
  },
  "id": "condition-based-waiting_obra",
  "name": "condition-based-waiting",
  "description": "Use when tests have race conditions, timing dependencies, or inconsistent pass/fail behavior - replaces arbitrary timeouts with condition polling to wait for actual state changes, eliminating flaky tests from timing guesses"
}