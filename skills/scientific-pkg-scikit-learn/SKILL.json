{
  "description": "Machine learning in Python with scikit-learn. Use when working with supervised learning (classification, regression), unsupervised learning (clustering, dimensionality reduction), model evaluation, hyperparameter tuning, preprocessing, or building ML pipelines. Provides comprehensive reference documentation for algorithms, preprocessing techniques, pipelines, and best practices.",
  "references": {
    "files": [
      "references/model_evaluation.md",
      "references/pipelines_and_composition.md",
      "references/preprocessing.md",
      "references/quick_reference.md",
      "references/supervised_learning.md",
      "references/unsupervised_learning.md"
    ]
  },
  "content": "```bash\r\nuv pip install scikit-learn\r\n\r\nuv pip install matplotlib seaborn\r\n\r\n\r\n### Classification Example\r\n\r\n```python\r\nfrom sklearn.model_selection import train_test_split\r\nfrom sklearn.preprocessing import StandardScaler\r\nfrom sklearn.ensemble import RandomForestClassifier\r\nfrom sklearn.metrics import classification_report\r\n\r\nX_train, X_test, y_train, y_test = train_test_split(\r\n    X, y, test_size=0.2, stratify=y, random_state=42\r\n)\r\n\r\nscaler = StandardScaler()\r\nX_train_scaled = scaler.fit_transform(X_train)\r\nX_test_scaled = scaler.transform(X_test)\r\n\r\nmodel = RandomForestClassifier(n_estimators=100, random_state=42)\r\nmodel.fit(X_train_scaled, y_train)\r\n\r\ny_pred = model.predict(X_test_scaled)\r\nprint(classification_report(y_test, y_pred))\r\n```\r\n\r\n### Complete Pipeline with Mixed Data\r\n\r\n```python\r\nfrom sklearn.pipeline import Pipeline\r\nfrom sklearn.compose import ColumnTransformer\r\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\r\nfrom sklearn.impute import SimpleImputer\r\nfrom sklearn.ensemble import GradientBoostingClassifier\r\n\r\nnumeric_features = ['age', 'income']\r\ncategorical_features = ['gender', 'occupation']\r\n\r\nnumeric_transformer = Pipeline([\r\n    ('imputer', SimpleImputer(strategy='median')),\r\n    ('scaler', StandardScaler())\r\n])\r\n\r\ncategorical_transformer = Pipeline([\r\n    ('imputer', SimpleImputer(strategy='most_frequent')),\r\n    ('onehot', OneHotEncoder(handle_unknown='ignore'))\r\n])\r\n\r\npreprocessor = ColumnTransformer([\r\n    ('num', numeric_transformer, numeric_features),\r\n    ('cat', categorical_transformer, categorical_features)\r\n])\r\n\r\nmodel = Pipeline([\r\n    ('preprocessor', preprocessor),\r\n    ('classifier', GradientBoostingClassifier(random_state=42))\r\n])\r\n\r\n\r\n### Always Use Pipelines\r\nPipelines prevent data leakage and ensure consistency:\r\n```python\r\npipeline = Pipeline([\r\n    ('scaler', StandardScaler()),\r\n    ('model', LogisticRegression())\r\n])\r\n\r\nX_scaled = StandardScaler().fit_transform(X)\r\n```\r\n\r\n### Fit on Training Data Only\r\nNever fit on test data:\r\n```python\r\nscaler = StandardScaler()\r\nX_train_scaled = scaler.fit_transform(X_train)\r\nX_test_scaled = scaler.transform(X_test)  # Only transform\r\n\r\n\r\n### ConvergenceWarning\r\n**Issue:** Model didn't converge\r\n**Solution:** Increase `max_iter` or scale features\r\n```python\r\nmodel = LogisticRegression(max_iter=1000)\r\n```\r\n\r\n### Poor Performance on Test Set\r\n**Issue:** Overfitting\r\n**Solution:** Use regularization, cross-validation, or simpler model\r\n```python\r\nmodel = Ridge(alpha=1.0)\r\n\r\nscores = cross_val_score(model, X, y, cv=5)\r\n```\r\n\r\n### Memory Error with Large Datasets\r\n**Solution:** Use algorithms designed for large data\r\n```python\r\nfrom sklearn.linear_model import SGDClassifier\r\nmodel = SGDClassifier()",
  "name": "scikit-learn",
  "id": "scientific-pkg-scikit-learn",
  "sections": {
    "Quick Start": "model.fit(X_train, y_train)\r\ny_pred = model.predict(X_test)\r\n```",
    "Reference Documentation": "This skill includes comprehensive reference files for deep dives into specific topics:\r\n\r\n### Quick Reference\r\n**File:** `references/quick_reference.md`\r\n- Common import patterns and installation instructions\r\n- Quick workflow templates for common tasks\r\n- Algorithm selection cheat sheets\r\n- Common patterns and gotchas\r\n- Performance optimization tips\r\n\r\n### Supervised Learning\r\n**File:** `references/supervised_learning.md`\r\n- Linear models (regression and classification)\r\n- Support Vector Machines\r\n- Decision Trees and ensemble methods\r\n- K-Nearest Neighbors, Naive Bayes, Neural Networks\r\n- Algorithm selection guide\r\n\r\n### Unsupervised Learning\r\n**File:** `references/unsupervised_learning.md`\r\n- All clustering algorithms with parameters and use cases\r\n- Dimensionality reduction techniques\r\n- Outlier and novelty detection\r\n- Gaussian Mixture Models\r\n- Method selection guide\r\n\r\n### Model Evaluation\r\n**File:** `references/model_evaluation.md`\r\n- Cross-validation strategies\r\n- Hyperparameter tuning methods\r\n- Classification, regression, and clustering metrics\r\n- Learning and validation curves\r\n- Best practices for model selection\r\n\r\n### Preprocessing\r\n**File:** `references/preprocessing.md`\r\n- Feature scaling and normalization\r\n- Encoding categorical variables\r\n- Missing value imputation\r\n- Feature engineering techniques\r\n- Custom transformers\r\n\r\n### Pipelines and Composition\r\n**File:** `references/pipelines_and_composition.md`\r\n- Pipeline construction and usage\r\n- ColumnTransformer for mixed data types\r\n- FeatureUnion for parallel transformations\r\n- Complete end-to-end examples\r\n- Best practices",
    "Example Scripts": "### Classification Pipeline\r\n\r\nRun a complete classification workflow with preprocessing, model comparison, hyperparameter tuning, and evaluation:\r\n\r\n```bash\r\npython scripts/classification_pipeline.py\r\n```\r\n\r\nThis script demonstrates:\r\n- Handling mixed data types (numeric and categorical)\r\n- Model comparison using cross-validation\r\n- Hyperparameter tuning with GridSearchCV\r\n- Comprehensive evaluation with multiple metrics\r\n- Feature importance analysis\r\n\r\n### Clustering Analysis\r\n\r\nPerform clustering analysis with algorithm comparison and visualization:\r\n\r\n```bash\r\npython scripts/clustering_analysis.py\r\n```\r\n\r\nThis script demonstrates:\r\n- Finding optimal number of clusters (elbow method, silhouette analysis)\r\n- Comparing multiple clustering algorithms (K-Means, DBSCAN, Agglomerative, Gaussian Mixture)\r\n- Evaluating clustering quality without ground truth\r\n- Visualizing results with PCA projection",
    "Additional Resources": "- Official Documentation: https://scikit-learn.org/stable/\r\n- User Guide: https://scikit-learn.org/stable/user_guide.html\r\n- API Reference: https://scikit-learn.org/stable/api/index.html\r\n- Examples Gallery: https://scikit-learn.org/stable/auto_examples/index.html",
    "Installation": "uv pip install pandas numpy\r\n```",
    "Overview": "This skill provides comprehensive guidance for machine learning tasks using scikit-learn, the industry-standard Python library for classical machine learning. Use this skill for classification, regression, clustering, dimensionality reduction, preprocessing, model evaluation, and building production-ready ML pipelines.",
    "Troubleshooting Common Issues": "from sklearn.cluster import MiniBatchKMeans\r\nmodel = MiniBatchKMeans(n_clusters=8, batch_size=100)\r\n```",
    "Best Practices": "scaler = StandardScaler()\r\nX_all_scaled = scaler.fit_transform(np.vstack([X_train, X_test]))\r\n```\r\n\r\n### Use Stratified Splitting for Classification\r\nPreserve class distribution:\r\n```python\r\nX_train, X_test, y_train, y_test = train_test_split(\r\n    X, y, test_size=0.2, stratify=y, random_state=42\r\n)\r\n```\r\n\r\n### Set Random State for Reproducibility\r\n```python\r\nmodel = RandomForestClassifier(n_estimators=100, random_state=42)\r\n```\r\n\r\n### Choose Appropriate Metrics\r\n- Balanced data: Accuracy, F1-score\r\n- Imbalanced data: Precision, Recall, ROC AUC, Balanced Accuracy\r\n- Cost-sensitive: Define custom scorer\r\n\r\n### Scale Features When Required\r\nAlgorithms requiring feature scaling:\r\n- SVM, KNN, Neural Networks\r\n- PCA, Linear/Logistic Regression with regularization\r\n- K-Means clustering\r\n\r\nAlgorithms not requiring scaling:\r\n- Tree-based models (Decision Trees, Random Forest, Gradient Boosting)\r\n- Naive Bayes",
    "When to Use This Skill": "Use the scikit-learn skill when:\r\n\r\n- Building classification or regression models\r\n- Performing clustering or dimensionality reduction\r\n- Preprocessing and transforming data for machine learning\r\n- Evaluating model performance with cross-validation\r\n- Tuning hyperparameters with grid or random search\r\n- Creating ML pipelines for production workflows\r\n- Comparing different algorithms for a task\r\n- Working with both structured (tabular) and text data\r\n- Need interpretable, classical machine learning approaches",
    "Core Capabilities": "### 1. Supervised Learning\r\n\r\nComprehensive algorithms for classification and regression tasks.\r\n\r\n**Key algorithms:**\r\n- **Linear models**: Logistic Regression, Linear Regression, Ridge, Lasso, ElasticNet\r\n- **Tree-based**: Decision Trees, Random Forest, Gradient Boosting\r\n- **Support Vector Machines**: SVC, SVR with various kernels\r\n- **Ensemble methods**: AdaBoost, Voting, Stacking\r\n- **Neural Networks**: MLPClassifier, MLPRegressor\r\n- **Others**: Naive Bayes, K-Nearest Neighbors\r\n\r\n**When to use:**\r\n- Classification: Predicting discrete categories (spam detection, image classification, fraud detection)\r\n- Regression: Predicting continuous values (price prediction, demand forecasting)\r\n\r\n**See:** `references/supervised_learning.md` for detailed algorithm documentation, parameters, and usage examples.\r\n\r\n### 2. Unsupervised Learning\r\n\r\nDiscover patterns in unlabeled data through clustering and dimensionality reduction.\r\n\r\n**Clustering algorithms:**\r\n- **Partition-based**: K-Means, MiniBatchKMeans\r\n- **Density-based**: DBSCAN, HDBSCAN, OPTICS\r\n- **Hierarchical**: AgglomerativeClustering\r\n- **Probabilistic**: Gaussian Mixture Models\r\n- **Others**: MeanShift, SpectralClustering, BIRCH\r\n\r\n**Dimensionality reduction:**\r\n- **Linear**: PCA, TruncatedSVD, NMF\r\n- **Manifold learning**: t-SNE, UMAP, Isomap, LLE\r\n- **Feature extraction**: FastICA, LatentDirichletAllocation\r\n\r\n**When to use:**\r\n- Customer segmentation, anomaly detection, data visualization\r\n- Reducing feature dimensions, exploratory data analysis\r\n- Topic modeling, image compression\r\n\r\n**See:** `references/unsupervised_learning.md` for detailed documentation.\r\n\r\n### 3. Model Evaluation and Selection\r\n\r\nTools for robust model evaluation, cross-validation, and hyperparameter tuning.\r\n\r\n**Cross-validation strategies:**\r\n- KFold, StratifiedKFold (classification)\r\n- TimeSeriesSplit (temporal data)\r\n- GroupKFold (grouped samples)\r\n\r\n**Hyperparameter tuning:**\r\n- GridSearchCV (exhaustive search)\r\n- RandomizedSearchCV (random sampling)\r\n- HalvingGridSearchCV (successive halving)\r\n\r\n**Metrics:**\r\n- **Classification**: accuracy, precision, recall, F1-score, ROC AUC, confusion matrix\r\n- **Regression**: MSE, RMSE, MAE, RÂ², MAPE\r\n- **Clustering**: silhouette score, Calinski-Harabasz, Davies-Bouldin\r\n\r\n**When to use:**\r\n- Comparing model performance objectively\r\n- Finding optimal hyperparameters\r\n- Preventing overfitting through cross-validation\r\n- Understanding model behavior with learning curves\r\n\r\n**See:** `references/model_evaluation.md` for comprehensive metrics and tuning strategies.\r\n\r\n### 4. Data Preprocessing\r\n\r\nTransform raw data into formats suitable for machine learning.\r\n\r\n**Scaling and normalization:**\r\n- StandardScaler (zero mean, unit variance)\r\n- MinMaxScaler (bounded range)\r\n- RobustScaler (robust to outliers)\r\n- Normalizer (sample-wise normalization)\r\n\r\n**Encoding categorical variables:**\r\n- OneHotEncoder (nominal categories)\r\n- OrdinalEncoder (ordered categories)\r\n- LabelEncoder (target encoding)\r\n\r\n**Handling missing values:**\r\n- SimpleImputer (mean, median, most frequent)\r\n- KNNImputer (k-nearest neighbors)\r\n- IterativeImputer (multivariate imputation)\r\n\r\n**Feature engineering:**\r\n- PolynomialFeatures (interaction terms)\r\n- KBinsDiscretizer (binning)\r\n- Feature selection (RFE, SelectKBest, SelectFromModel)\r\n\r\n**When to use:**\r\n- Before training any algorithm that requires scaled features (SVM, KNN, Neural Networks)\r\n- Converting categorical variables to numeric format\r\n- Handling missing data systematically\r\n- Creating non-linear features for linear models\r\n\r\n**See:** `references/preprocessing.md` for detailed preprocessing techniques.\r\n\r\n### 5. Pipelines and Composition\r\n\r\nBuild reproducible, production-ready ML workflows.\r\n\r\n**Key components:**\r\n- **Pipeline**: Chain transformers and estimators sequentially\r\n- **ColumnTransformer**: Apply different preprocessing to different columns\r\n- **FeatureUnion**: Combine multiple transformers in parallel\r\n- **TransformedTargetRegressor**: Transform target variable\r\n\r\n**Benefits:**\r\n- Prevents data leakage in cross-validation\r\n- Simplifies code and improves maintainability\r\n- Enables joint hyperparameter tuning\r\n- Ensures consistency between training and prediction\r\n\r\n**When to use:**\r\n- Always use Pipelines for production workflows\r\n- When mixing numerical and categorical features (use ColumnTransformer)\r\n- When performing cross-validation with preprocessing steps\r\n- When hyperparameter tuning includes preprocessing parameters\r\n\r\n**See:** `references/pipelines_and_composition.md` for comprehensive pipeline patterns.",
    "Common Workflows": "### Building a Classification Model\r\n\r\n1. **Load and explore data**\r\n   ```python\r\n   import pandas as pd\r\n   df = pd.read_csv('data.csv')\r\n   X = df.drop('target', axis=1)\r\n   y = df['target']\r\n   ```\r\n\r\n2. **Split data with stratification**\r\n   ```python\r\n   from sklearn.model_selection import train_test_split\r\n   X_train, X_test, y_train, y_test = train_test_split(\r\n       X, y, test_size=0.2, stratify=y, random_state=42\r\n   )\r\n   ```\r\n\r\n3. **Create preprocessing pipeline**\r\n   ```python\r\n   from sklearn.pipeline import Pipeline\r\n   from sklearn.preprocessing import StandardScaler\r\n   from sklearn.compose import ColumnTransformer\r\n\r\n   # Handle numeric and categorical features separately\r\n   preprocessor = ColumnTransformer([\r\n       ('num', StandardScaler(), numeric_features),\r\n       ('cat', OneHotEncoder(), categorical_features)\r\n   ])\r\n   ```\r\n\r\n4. **Build complete pipeline**\r\n   ```python\r\n   model = Pipeline([\r\n       ('preprocessor', preprocessor),\r\n       ('classifier', RandomForestClassifier(random_state=42))\r\n   ])\r\n   ```\r\n\r\n5. **Tune hyperparameters**\r\n   ```python\r\n   from sklearn.model_selection import GridSearchCV\r\n\r\n   param_grid = {\r\n       'classifier__n_estimators': [100, 200],\r\n       'classifier__max_depth': [10, 20, None]\r\n   }\r\n\r\n   grid_search = GridSearchCV(model, param_grid, cv=5)\r\n   grid_search.fit(X_train, y_train)\r\n   ```\r\n\r\n6. **Evaluate on test set**\r\n   ```python\r\n   from sklearn.metrics import classification_report\r\n\r\n   best_model = grid_search.best_estimator_\r\n   y_pred = best_model.predict(X_test)\r\n   print(classification_report(y_test, y_pred))\r\n   ```\r\n\r\n### Performing Clustering Analysis\r\n\r\n1. **Preprocess data**\r\n   ```python\r\n   from sklearn.preprocessing import StandardScaler\r\n\r\n   scaler = StandardScaler()\r\n   X_scaled = scaler.fit_transform(X)\r\n   ```\r\n\r\n2. **Find optimal number of clusters**\r\n   ```python\r\n   from sklearn.cluster import KMeans\r\n   from sklearn.metrics import silhouette_score\r\n\r\n   scores = []\r\n   for k in range(2, 11):\r\n       kmeans = KMeans(n_clusters=k, random_state=42)\r\n       labels = kmeans.fit_predict(X_scaled)\r\n       scores.append(silhouette_score(X_scaled, labels))\r\n\r\n   optimal_k = range(2, 11)[np.argmax(scores)]\r\n   ```\r\n\r\n3. **Apply clustering**\r\n   ```python\r\n   model = KMeans(n_clusters=optimal_k, random_state=42)\r\n   labels = model.fit_predict(X_scaled)\r\n   ```\r\n\r\n4. **Visualize with dimensionality reduction**\r\n   ```python\r\n   from sklearn.decomposition import PCA\r\n\r\n   pca = PCA(n_components=2)\r\n   X_2d = pca.fit_transform(X_scaled)\r\n\r\n   plt.scatter(X_2d[:, 0], X_2d[:, 1], c=labels, cmap='viridis')\r\n   ```"
  }
}