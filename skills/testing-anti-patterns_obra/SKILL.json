{
  "sections": {
    "Anti-Pattern 5: Integration Tests as Afterthought": "**The violation:**\r\n```\r\n✅ Implementation complete\r\n❌ No tests written\r\n\"Ready for testing\"\r\n```\r\n\r\n**Why this is wrong:**\r\n- Testing is part of implementation, not optional follow-up\r\n- TDD would have caught this\r\n- Can't claim complete without tests\r\n\r\n**The fix:**\r\n```\r\nTDD cycle:\r\n1. Write failing test\r\n2. Implement to pass\r\n3. Refactor\r\n4. THEN claim complete\r\n```",
    "Anti-Pattern 2: Test-Only Methods in Production": "**The violation:**\r\n```typescript\r\n// ❌ BAD: destroy() only used in tests\r\nclass Session {\r\n  async destroy() {  // Looks like production API!\r\n    await this._workspaceManager?.destroyWorkspace(this.id);\r\n    // ... cleanup\r\n  }\r\n}\r\n\r\n// In tests\r\nafterEach(() => session.destroy());\r\n```\r\n\r\n**Why this is wrong:**\r\n- Production class polluted with test-only code\r\n- Dangerous if accidentally called in production\r\n- Violates YAGNI and separation of concerns\r\n- Confuses object lifecycle with entity lifecycle\r\n\r\n**The fix:**\r\n```typescript\r\n// ✅ GOOD: Test utilities handle test cleanup\r\n// Session has no destroy() - it's stateless in production\r\n\r\n// In test-utils/\r\nexport async function cleanupSession(session: Session) {\r\n  const workspace = session.getWorkspaceInfo();\r\n  if (workspace) {\r\n    await workspaceManager.destroyWorkspace(workspace.id);\r\n  }\r\n}\r\n\r\n// In tests\r\nafterEach(() => cleanupSession(session));\r\n```\r\n\r\n### Gate Function\r\n\r\n```\r\nBEFORE adding any method to production class:\r\n  Ask: \"Is this only used by tests?\"\r\n\r\n  IF yes:\r\n    STOP - Don't add it\r\n    Put it in test utilities instead\r\n\r\n  Ask: \"Does this class own this resource's lifecycle?\"\r\n\r\n  IF no:\r\n    STOP - Wrong class for this method\r\n```",
    "TDD Prevents These Anti-Patterns": "**Why TDD helps:**\r\n1. **Write test first** → Forces you to think about what you're actually testing\r\n2. **Watch it fail** → Confirms test tests real behavior, not mocks\r\n3. **Minimal implementation** → No test-only methods creep in\r\n4. **Real dependencies** → You see what the test actually needs before mocking\r\n\r\n**If you're testing mock behavior, you violated TDD** - you added mocks without watching test fail against real code first.",
    "Anti-Pattern 4: Incomplete Mocks": "**The violation:**\r\n```typescript\r\n// ❌ BAD: Partial mock - only fields you think you need\r\nconst mockResponse = {\r\n  status: 'success',\r\n  data: { userId: '123', name: 'Alice' }\r\n  // Missing: metadata that downstream code uses\r\n};\r\n\r\n// Later: breaks when code accesses response.metadata.requestId\r\n```\r\n\r\n**Why this is wrong:**\r\n- **Partial mocks hide structural assumptions** - You only mocked fields you know about\r\n- **Downstream code may depend on fields you didn't include** - Silent failures\r\n- **Tests pass but integration fails** - Mock incomplete, real API complete\r\n- **False confidence** - Test proves nothing about real behavior\r\n\r\n**The Iron Rule:** Mock the COMPLETE data structure as it exists in reality, not just fields your immediate test uses.\r\n\r\n**The fix:**\r\n```typescript\r\n// ✅ GOOD: Mirror real API completeness\r\nconst mockResponse = {\r\n  status: 'success',\r\n  data: { userId: '123', name: 'Alice' },\r\n  metadata: { requestId: 'req-789', timestamp: 1234567890 }\r\n  // All fields real API returns\r\n};\r\n```\r\n\r\n### Gate Function\r\n\r\n```\r\nBEFORE creating mock responses:\r\n  Check: \"What fields does the real API response contain?\"\r\n\r\n  Actions:\r\n    1. Examine actual API response from docs/examples\r\n    2. Include ALL fields system might consume downstream\r\n    3. Verify mock matches real response schema completely\r\n\r\n  Critical:\r\n    If you're creating a mock, you must understand the ENTIRE structure\r\n    Partial mocks fail silently when code depends on omitted fields\r\n\r\n  If uncertain: Include all documented fields\r\n```",
    "Overview": "Tests must verify real behavior, not mock behavior. Mocks are a means to isolate, not the thing being tested.\r\n\r\n**Core principle:** Test what the code does, not what the mocks do.\r\n\r\n**Following strict TDD prevents these anti-patterns.**",
    "Anti-Pattern 3: Mocking Without Understanding": "**The violation:**\r\n```typescript\r\n// ❌ BAD: Mock breaks test logic\r\ntest('detects duplicate server', () => {\r\n  // Mock prevents config write that test depends on!\r\n  vi.mock('ToolCatalog', () => ({\r\n    discoverAndCacheTools: vi.fn().mockResolvedValue(undefined)\r\n  }));\r\n\r\n  await addServer(config);\r\n  await addServer(config);  // Should throw - but won't!\r\n});\r\n```\r\n\r\n**Why this is wrong:**\r\n- Mocked method had side effect test depended on (writing config)\r\n- Over-mocking to \"be safe\" breaks actual behavior\r\n- Test passes for wrong reason or fails mysteriously\r\n\r\n**The fix:**\r\n```typescript\r\n// ✅ GOOD: Mock at correct level\r\ntest('detects duplicate server', () => {\r\n  // Mock the slow part, preserve behavior test needs\r\n  vi.mock('MCPServerManager'); // Just mock slow server startup\r\n\r\n  await addServer(config);  // Config written\r\n  await addServer(config);  // Duplicate detected ✓\r\n});\r\n```\r\n\r\n### Gate Function\r\n\r\n```\r\nBEFORE mocking any method:\r\n  STOP - Don't mock yet\r\n\r\n  1. Ask: \"What side effects does the real method have?\"\r\n  2. Ask: \"Does this test depend on any of those side effects?\"\r\n  3. Ask: \"Do I fully understand what this test needs?\"\r\n\r\n  IF depends on side effects:\r\n    Mock at lower level (the actual slow/external operation)\r\n    OR use test doubles that preserve necessary behavior\r\n    NOT the high-level method the test depends on\r\n\r\n  IF unsure what test depends on:\r\n    Run test with real implementation FIRST\r\n    Observe what actually needs to happen\r\n    THEN add minimal mocking at the right level\r\n\r\n  Red flags:\r\n    - \"I'll mock this to be safe\"\r\n    - \"This might be slow, better mock it\"\r\n    - Mocking without understanding the dependency chain\r\n```",
    "Quick Reference": "| Anti-Pattern | Fix |\r\n|--------------|-----|\r\n| Assert on mock elements | Test real component or unmock it |\r\n| Test-only methods in production | Move to test utilities |\r\n| Mock without understanding | Understand dependencies first, mock minimally |\r\n| Incomplete mocks | Mirror real API completely |\r\n| Tests as afterthought | TDD - tests first |\r\n| Over-complex mocks | Consider integration tests |",
    "When Mocks Become Too Complex": "**Warning signs:**\r\n- Mock setup longer than test logic\r\n- Mocking everything to make test pass\r\n- Mocks missing methods real components have\r\n- Test breaks when mock changes\r\n\r\n**your human partner's question:** \"Do we need to be using a mock here?\"\r\n\r\n**Consider:** Integration tests with real components often simpler than complex mocks",
    "Anti-Pattern 1: Testing Mock Behavior": "**The violation:**\r\n```typescript\r\n// ❌ BAD: Testing that the mock exists\r\ntest('renders sidebar', () => {\r\n  render(<Page />);\r\n  expect(screen.getByTestId('sidebar-mock')).toBeInTheDocument();\r\n});\r\n```\r\n\r\n**Why this is wrong:**\r\n- You're verifying the mock works, not that the component works\r\n- Test passes when mock is present, fails when it's not\r\n- Tells you nothing about real behavior\r\n\r\n**your human partner's correction:** \"Are we testing the behavior of a mock?\"\r\n\r\n**The fix:**\r\n```typescript\r\n// ✅ GOOD: Test real component or don't mock it\r\ntest('renders sidebar', () => {\r\n  render(<Page />);  // Don't mock sidebar\r\n  expect(screen.getByRole('navigation')).toBeInTheDocument();\r\n});\r\n\r\n// OR if sidebar must be mocked for isolation:\r\n// Don't assert on the mock - test Page's behavior with sidebar present\r\n```\r\n\r\n### Gate Function\r\n\r\n```\r\nBEFORE asserting on any mock element:\r\n  Ask: \"Am I testing real component behavior or just mock existence?\"\r\n\r\n  IF testing mock existence:\r\n    STOP - Delete the assertion or unmock the component\r\n\r\n  Test real behavior instead\r\n```",
    "Red Flags": "- Assertion checks for `*-mock` test IDs\r\n- Methods only called in test files\r\n- Mock setup is >50% of test\r\n- Test fails when you remove mock\r\n- Can't explain why mock is needed\r\n- Mocking \"just to be safe\"",
    "The Bottom Line": "**Mocks are tools to isolate, not things to test.**\r\n\r\nIf TDD reveals you're testing mock behavior, you've gone wrong.\r\n\r\nFix: Test real behavior or question why you're mocking at all.",
    "The Iron Laws": "```\r\n1. NEVER test mock behavior\r\n2. NEVER add test-only methods to production classes\r\n3. NEVER mock without understanding dependencies\r\n```"
  },
  "id": "testing-anti-patterns_obra",
  "name": "testing-anti-patterns",
  "description": "Use when writing or changing tests, adding mocks, or tempted to add test-only methods to production code - prevents testing mock behavior, production pollution with test-only methods, and mocking without understanding dependencies"
}