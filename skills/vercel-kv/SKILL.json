{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/example-reference.md"
    ]
  },
  "content": "**Status**: Production Ready\r\n**Last Updated**: 2025-10-29\r\n**Dependencies**: None\r\n**Latest Versions**: `@vercel/kv@3.0.0`\r\n\r\n---\r\n\r\n\r\n### 1. Create Vercel KV Database\r\n\r\n```bash\r\n\r\n\r\n### Step 1: Create KV Database\r\n\r\n**Option A: Vercel Dashboard**\r\n1. Go to your Vercel project\r\n2. Storage → Create Database → KV\r\n3. Name your database\r\n4. Copy the environment variables\r\n\r\n**Option B: Vercel CLI**\r\n```bash\r\nvercel env pull .env.local\r\n```\r\n\r\nThis creates:\r\n```bash\r\nKV_REST_API_URL=\"https://xyz.kv.vercel-storage.com\"\r\nKV_REST_API_TOKEN=\"your-token-here\"\r\nKV_REST_API_READ_ONLY_TOKEN=\"your-readonly-token\"\r\n```\r\n\r\n**Key Points:**\r\n- One KV database per project recommended\r\n- Free tier: 30,000 commands/month, 256MB storage\r\n- Environment variables are automatically set for Vercel deployments\r\n\r\n---\r\n\r\n### Step 2: Install and Configure\r\n\r\n```bash\r\nnpm install @vercel/kv\r\n```\r\n\r\n**For local development**, create `.env.local`:\r\n```bash\r\nKV_REST_API_URL=\"https://your-db.kv.vercel-storage.com\"\r\nKV_REST_API_TOKEN=\"your-token\"\r\n```\r\n\r\n**For production**, environment variables are automatically available.\r\n\r\n**Cloudflare Workers** (using Vercel KV):\r\n```toml\r\n\r\n### package.json\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@vercel/kv\": \"^3.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n### .env.local (Local Development)\r\n\r\n```bash",
  "name": "vercel-kv",
  "id": "vercel-kv",
  "sections": {
    "Production Example": "This skill is based on production deployments of Vercel KV:\r\n- **Next.js E-commerce**: Session management, cart caching, rate limiting\r\n- **Blog Platform**: View counters, page caching, API caching\r\n- **API Gateway**: Rate limiting, response caching, distributed locks\r\n- **Errors**: 0 (all 10 known issues prevented)\r\n- **Uptime**: 99.9%+ (Upstash SLA)\r\n\r\n---",
    "Quick Start (3 Minutes)": "vercel env pull .env.local\r\n```\r\n\r\nThis automatically creates:\r\n- `KV_REST_API_URL` - Your KV database URL\r\n- `KV_REST_API_TOKEN` - Auth token\r\n- `KV_REST_API_READ_ONLY_TOKEN` - Read-only token (optional)\r\n\r\n### 2. Install Package\r\n\r\n```bash\r\nnpm install @vercel/kv\r\n```\r\n\r\n### 3. Use in Your App\r\n\r\n**Next.js Server Action:**\r\n```typescript\r\n'use server';\r\n\r\nimport { kv } from '@vercel/kv';\r\n\r\nexport async function incrementViews(slug: string) {\r\n  const views = await kv.incr(`views:${slug}`);\r\n  return views;\r\n}\r\n```\r\n\r\n**Edge API Route:**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nexport const runtime = 'edge';\r\n\r\nexport async function GET(request: Request) {\r\n  const value = await kv.get('mykey');\r\n  return Response.json({ value });\r\n}\r\n```\r\n\r\n**CRITICAL:**\r\n- Always set TTL for temporary data: `await kv.setex('key', 3600, value)`\r\n- Use namespacing for keys: `user:${id}:profile` instead of just `${id}`\r\n- JSON values must be serializable (no functions, circular refs)\r\n\r\n---",
    "Configuration Files Reference": "KV_REST_API_URL=\"https://your-database.kv.vercel-storage.com\"\r\nKV_REST_API_TOKEN=\"your-token-here\"\r\nKV_REST_API_READ_ONLY_TOKEN=\"optional-readonly-token\"\r\n```\r\n\r\n### .gitignore\r\n\r\n```\r\n.env.local\r\n.env*.local\r\n```\r\n\r\n---",
    "Package Versions (Verified 2025-10-29)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"@vercel/kv\": \"^3.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Troubleshooting": "### Problem: `KV_REST_API_URL is not defined`\r\n**Solution**: Run `vercel env pull .env.local` to get environment variables.\r\n\r\n### Problem: Rate limit exceeded (free tier)\r\n**Solution**: Upgrade plan or optimize queries (use `mget` instead of multiple `get` calls, add caching layer).\r\n\r\n### Problem: Values not expiring\r\n**Solution**: Use `setex()` instead of `set()`, or call `expire(key, ttl)` after `set()`.\r\n\r\n### Problem: JSON serialization error\r\n**Solution**: Ensure values are JSON-serializable (no functions, BigInt, circular refs). Convert BigInt to string.\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ **Set TTL for temporary data** - Avoid memory leaks and stale data\r\n\r\n✅ **Use namespaced keys** - `user:123` not `123` (prevents collisions)\r\n\r\n✅ **Handle null returns** - Non-existent keys return `null`\r\n\r\n✅ **Use pipeline for multiple operations** - Reduces latency (single round-trip)\r\n\r\n✅ **Serialize JSON-compatible data only** - No functions, circular references, etc.\r\n\r\n✅ **Use SETNX for distributed locks** - Prevents race conditions\r\n\r\n✅ **Monitor command usage** - Stay within free tier limits (30K commands/month)\r\n\r\n✅ **Use read-only token for public reads** - Better security\r\n\r\n### Never Do\r\n\r\n❌ **Never store sensitive data without encryption** - KV is not encrypted at rest by default\r\n\r\n❌ **Never forget to set TTL** - Keys without TTL stay forever (memory leak)\r\n\r\n❌ **Never use generic key names** - `data`, `cache`, `temp` will collide\r\n\r\n❌ **Never store large values (>1MB)** - Use Vercel Blob for large files\r\n\r\n❌ **Never use KV as primary database** - It's a cache, not persistent storage\r\n\r\n❌ **Never exceed rate limits** - 30K commands/month on free tier\r\n\r\n❌ **Never assume strong durability** - KV is for ephemeral data, not critical data\r\n\r\n❌ **Never commit `.env.local`** - Contains KV tokens (add to `.gitignore`)\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- `@vercel/kv@^3.0.0` - Vercel KV client library\r\n\r\n**Optional**:\r\n- `zod@^3.24.0` - Runtime type validation for KV data\r\n- `ioredis-mock@^8.9.0` - Mock KV for testing\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **10 documented issues**:\r\n\r\n### Issue #1: Missing Environment Variables\r\n**Error**: `Error: KV_REST_API_URL is not defined` or `KV_REST_API_TOKEN is not defined`\r\n**Source**: https://vercel.com/docs/storage/vercel-kv/quickstart\r\n**Why It Happens**: Environment variables not set locally or in deployment\r\n**Prevention**: Run `vercel env pull .env.local` and ensure `.env.local` is in `.gitignore`.\r\n\r\n### Issue #2: JSON Serialization Error\r\n**Error**: `TypeError: Do not know how to serialize a BigInt` or circular reference errors\r\n**Source**: https://github.com/vercel/storage/issues/89\r\n**Why It Happens**: Trying to store non-JSON-serializable data (functions, BigInt, circular refs)\r\n**Prevention**: Only store plain objects, arrays, strings, numbers, booleans, null. Convert BigInt to string.\r\n\r\n### Issue #3: Key Naming Collisions\r\n**Error**: Unexpected data returned, data overwritten by different feature\r\n**Source**: Production debugging, best practices\r\n**Why It Happens**: Using generic key names like `cache`, `data`, `temp` across different features\r\n**Prevention**: Always use namespaced keys: `feature:id:type` pattern.\r\n\r\n### Issue #4: TTL Not Set\r\n**Error**: Memory usage grows indefinitely, old data never expires\r\n**Source**: Vercel KV best practices\r\n**Why It Happens**: Using `set()` without `setex()` for temporary data\r\n**Prevention**: Use `setex(key, ttl, value)` for all temporary data. Set appropriate TTL (seconds).\r\n\r\n### Issue #5: Rate Limit Exceeded (Free Tier)\r\n**Error**: `Error: Rate limit exceeded` or commands failing\r\n**Source**: https://vercel.com/docs/storage/vercel-kv/limits\r\n**Why It Happens**: Exceeding 30,000 commands/month on free tier\r\n**Prevention**: Monitor usage in Vercel dashboard, upgrade plan if needed, use caching to reduce KV calls.\r\n\r\n### Issue #6: Storing Large Values\r\n**Error**: `Error: Value too large` or performance degradation\r\n**Source**: https://vercel.com/docs/storage/vercel-kv/limits\r\n**Why It Happens**: Trying to store values >1MB in KV\r\n**Prevention**: Use Vercel Blob for files/images. Keep KV values small (<100KB recommended).\r\n\r\n### Issue #7: Type Mismatch on Get\r\n**Error**: TypeScript errors, runtime type errors\r\n**Source**: Common TypeScript issue\r\n**Why It Happens**: `kv.get()` returns `unknown` type, need to cast or validate\r\n**Prevention**: Use type assertion with validation: `const user = await kv.get<User>('user:123')` and validate with Zod.\r\n\r\n### Issue #8: Pipeline Errors Not Handled\r\n**Error**: Silent failures, partial execution\r\n**Source**: https://github.com/vercel/storage/issues/120\r\n**Why It Happens**: Pipeline execution can have individual command failures\r\n**Prevention**: Check results array from `pipeline.exec()` and handle errors.\r\n\r\n### Issue #9: Scan Operation Inefficiency\r\n**Error**: Slow queries, timeout errors\r\n**Source**: Redis best practices\r\n**Why It Happens**: Using `scan()` with large datasets or wrong cursor handling\r\n**Prevention**: Limit `count` parameter, iterate properly with cursor, avoid full scans in production.\r\n\r\n### Issue #10: Missing TTL Refresh\r\n**Error**: Session expires too early, cache invalidates prematurely\r\n**Source**: Production debugging\r\n**Why It Happens**: Not refreshing TTL on access (sliding expiration)\r\n**Prevention**: Use `expire(key, newTTL)` on access to implement sliding windows.\r\n\r\n---",
    "Official Documentation": "- **Vercel KV**: https://vercel.com/docs/storage/vercel-kv\r\n- **Vercel KV Quickstart**: https://vercel.com/docs/storage/vercel-kv/quickstart\r\n- **Vercel KV SDK Reference**: https://vercel.com/docs/storage/vercel-kv/kv-reference\r\n- **GitHub**: https://github.com/vercel/storage\r\n- **Redis Commands**: https://redis.io/commands (Vercel KV is Redis-compatible)\r\n\r\n---",
    "Common Patterns": "### Pattern 1: Cache-Aside (Lazy Loading)\r\n\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function getUser(id: number) {\r\n  const cacheKey = `user:${id}`;\r\n\r\n  // Check cache\r\n  const cached = await kv.get<User>(cacheKey);\r\n  if (cached) return cached;\r\n\r\n  // Fetch from database\r\n  const user = await db.query.users.findFirst({\r\n    where: eq(users.id, id)\r\n  });\r\n\r\n  if (!user) return null;\r\n\r\n  // Cache for 5 minutes\r\n  await kv.setex(cacheKey, 300, user);\r\n\r\n  return user;\r\n}\r\n```\r\n\r\n### Pattern 2: Write-Through Cache\r\n\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function updateUser(id: number, data: Partial<User>) {\r\n  // Update database\r\n  const updated = await db.update(users)\r\n    .set(data)\r\n    .where(eq(users.id, id))\r\n    .returning();\r\n\r\n  // Update cache\r\n  await kv.setex(`user:${id}`, 300, updated[0]);\r\n\r\n  return updated[0];\r\n}\r\n```\r\n\r\n### Pattern 3: Distributed Lock\r\n\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function acquireLock(resource: string, timeout: number = 10) {\r\n  const lockKey = `lock:${resource}`;\r\n  const lockValue = crypto.randomUUID();\r\n\r\n  // Try to set lock (only if not exists)\r\n  const acquired = await kv.setnx(lockKey, lockValue);\r\n\r\n  if (acquired) {\r\n    // Set TTL to prevent deadlock\r\n    await kv.expire(lockKey, timeout);\r\n    return lockValue;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\nasync function releaseLock(resource: string, lockValue: string) {\r\n  const lockKey = `lock:${resource}`;\r\n  const current = await kv.get(lockKey);\r\n\r\n  // Only delete if we own the lock\r\n  if (current === lockValue) {\r\n    await kv.del(lockKey);\r\n  }\r\n}\r\n\r\n// Usage\r\nconst lock = await acquireLock('process-orders');\r\nif (lock) {\r\n  try {\r\n    await processOrders();\r\n  } finally {\r\n    await releaseLock('process-orders', lock);\r\n  }\r\n}\r\n```\r\n\r\n### Pattern 4: Leaderboard\r\n\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function updateScore(userId: number, score: number) {\r\n  await kv.zadd('leaderboard', { score, member: userId.toString() });\r\n}\r\n\r\nasync function getTopPlayers(limit: number = 10) {\r\n  // Get top scores (descending)\r\n  const top = await kv.zrange('leaderboard', 0, limit - 1, { rev: true, withScores: true });\r\n  return top;\r\n}\r\n\r\nasync function getUserRank(userId: number) {\r\n  // Get user's rank (0-based)\r\n  const rank = await kv.zrevrank('leaderboard', userId.toString());\r\n  return rank !== null ? rank + 1 : null;\r\n}\r\n```\r\n\r\n---",
    "Complete Setup Checklist": "- [ ] Vercel KV database created in dashboard\r\n- [ ] Environment variables pulled locally (`vercel env pull`)\r\n- [ ] `@vercel/kv` package installed\r\n- [ ] `.env.local` added to `.gitignore`\r\n- [ ] Key naming convention established (namespaced keys)\r\n- [ ] TTL set for all temporary data\r\n- [ ] Rate limit monitoring set up\r\n- [ ] Type validation implemented (Zod schemas)\r\n- [ ] Error handling for null returns\r\n- [ ] Tested locally and in production\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check official docs: https://vercel.com/docs/storage/vercel-kv\r\n2. Review Redis commands: https://redis.io/commands\r\n3. Monitor usage in Vercel dashboard\r\n4. Ensure environment variables are set correctly",
    "The 5-Step Setup Process": "[vars]\r\nKV_REST_API_URL = \"https://your-db.kv.vercel-storage.com\"\r\n\r\n[[secrets]]\r\nKV_REST_API_TOKEN = \"your-token\"\r\n```\r\n\r\n---\r\n\r\n### Step 3: Basic Operations\r\n\r\n**Set/Get:**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\n// Set a value\r\nawait kv.set('user:123', { name: 'Alice', email: 'alice@example.com' });\r\n\r\n// Get a value\r\nconst user = await kv.get('user:123');\r\n// Returns: { name: 'Alice', email: 'alice@example.com' }\r\n\r\n// Set with TTL (expires in 1 hour)\r\nawait kv.setex('session:abc', 3600, { userId: 123 });\r\n\r\n// Check if key exists\r\nconst exists = await kv.exists('user:123'); // Returns 1 if exists, 0 if not\r\n\r\n// Delete a key\r\nawait kv.del('user:123');\r\n```\r\n\r\n**Atomic Operations:**\r\n```typescript\r\n// Increment counter\r\nconst views = await kv.incr('views:post:123');\r\n\r\n// Decrement counter\r\nconst stock = await kv.decr('inventory:item:456');\r\n\r\n// Increment by amount\r\nawait kv.incrby('score:user:789', 10);\r\n\r\n// Set if not exists (returns 1 if set, 0 if key already exists)\r\nconst wasSet = await kv.setnx('lock:process', 'running');\r\n```\r\n\r\n**Multiple Operations:**\r\n```typescript\r\n// Get multiple keys\r\nconst values = await kv.mget('user:1', 'user:2', 'user:3');\r\n// Returns: [{ name: '...' }, { name: '...' }, null]\r\n\r\n// Set multiple keys\r\nawait kv.mset({\r\n  'user:1': { name: 'Alice' },\r\n  'user:2': { name: 'Bob' }\r\n});\r\n\r\n// Delete multiple keys\r\nawait kv.del('key1', 'key2', 'key3');\r\n```\r\n\r\n**Key Points:**\r\n- Values are automatically JSON-serialized\r\n- `null` is returned for non-existent keys\r\n- All operations are atomic\r\n- TTL is in seconds\r\n\r\n---\r\n\r\n### Step 4: Advanced Patterns\r\n\r\n**Caching Pattern:**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function getPost(slug: string) {\r\n  // Try cache first\r\n  const cached = await kv.get(`post:${slug}`);\r\n  if (cached) return cached;\r\n\r\n  // Fetch from database\r\n  const post = await db.select().from(posts).where(eq(posts.slug, slug));\r\n\r\n  // Cache for 1 hour\r\n  await kv.setex(`post:${slug}`, 3600, post);\r\n\r\n  return post;\r\n}\r\n```\r\n\r\n**Rate Limiting:**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\nasync function checkRateLimit(ip: string): Promise<boolean> {\r\n  const key = `ratelimit:${ip}`;\r\n  const limit = 10; // 10 requests\r\n  const window = 60; // per 60 seconds\r\n\r\n  const current = await kv.incr(key);\r\n\r\n  if (current === 1) {\r\n    // First request, set TTL\r\n    await kv.expire(key, window);\r\n  }\r\n\r\n  return current <= limit;\r\n}\r\n\r\n// Usage in API route\r\nexport async function POST(request: Request) {\r\n  const ip = request.headers.get('x-forwarded-for') || 'unknown';\r\n\r\n  if (!await checkRateLimit(ip)) {\r\n    return new Response('Rate limit exceeded', { status: 429 });\r\n  }\r\n\r\n  // Process request...\r\n}\r\n```\r\n\r\n**Session Management:**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\nimport { cookies } from 'next/headers';\r\n\r\nexport async function createSession(userId: number) {\r\n  const sessionId = crypto.randomUUID();\r\n  const sessionData = { userId, createdAt: Date.now() };\r\n\r\n  // Store session for 7 days\r\n  await kv.setex(`session:${sessionId}`, 7 * 24 * 3600, sessionData);\r\n\r\n  // Set cookie\r\n  cookies().set('session', sessionId, {\r\n    httpOnly: true,\r\n    secure: true,\r\n    maxAge: 7 * 24 * 3600\r\n  });\r\n\r\n  return sessionId;\r\n}\r\n\r\nexport async function getSession() {\r\n  const sessionId = cookies().get('session')?.value;\r\n  if (!sessionId) return null;\r\n\r\n  return await kv.get(`session:${sessionId}`);\r\n}\r\n```\r\n\r\n**Pipeline (Batch Operations):**\r\n```typescript\r\nimport { kv } from '@vercel/kv';\r\n\r\n// Execute multiple commands in a single round-trip\r\nconst pipeline = kv.pipeline();\r\n\r\npipeline.set('user:1', { name: 'Alice' });\r\npipeline.incr('counter');\r\npipeline.get('config');\r\n\r\nconst results = await pipeline.exec();\r\n// Returns: ['OK', 1, { ... }]\r\n```\r\n\r\n---\r\n\r\n### Step 5: Key Naming Conventions\r\n\r\n**Use Namespaces:**\r\n```typescript\r\n// ❌ Bad: No structure\r\nawait kv.set('123', data);\r\n\r\n// ✅ Good: Clear namespace\r\nawait kv.set('user:123', data);\r\nawait kv.set('post:abc:views', 100);\r\nawait kv.set('cache:homepage:en', html);\r\n```\r\n\r\n**Naming Patterns:**\r\n- `user:{id}:profile` - User profile data\r\n- `post:{slug}:views` - View counter for post\r\n- `cache:{page}:{locale}` - Cached page content\r\n- `session:{token}` - Session data\r\n- `ratelimit:{ip}:{endpoint}` - Rate limit tracking\r\n- `lock:{resource}` - Distributed locks\r\n\r\n---"
  }
}