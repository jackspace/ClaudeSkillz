{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/accessibility.md",
      "references/error-handling.md",
      "references/links-to-official-docs.md",
      "references/performance-optimization.md",
      "references/rhf-api-reference.md",
      "references/shadcn-integration.md",
      "references/top-errors.md",
      "references/zod-schemas-guide.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-23\r\n**Dependencies**: None (standalone)\r\n**Latest Versions**: react-hook-form@7.65.0, zod@4.1.12, @hookform/resolvers@5.2.2\r\n\r\n---",
  "name": "react-hook-form-zod",
  "id": "react-hook-form-zod",
  "sections": {
    "Performance Optimization": "### Form Mode Strategies\r\n\r\n```typescript\r\n// Best performance - validate only on submit\r\nconst form = useForm({\r\n  mode: 'onSubmit',\r\n  resolver: zodResolver(schema),\r\n})\r\n\r\n// Good balance - validate on blur\r\nconst form = useForm({\r\n  mode: 'onBlur',\r\n  resolver: zodResolver(schema),\r\n})\r\n\r\n// Live feedback - validate on every change\r\nconst form = useForm({\r\n  mode: 'onChange',\r\n  resolver: zodResolver(schema),\r\n})\r\n\r\n// Maximum validation - all events\r\nconst form = useForm({\r\n  mode: 'all',\r\n  resolver: zodResolver(schema),\r\n})\r\n```\r\n\r\n### Controlled vs Uncontrolled Inputs\r\n\r\n```typescript\r\n// Uncontrolled (better performance) - use register\r\n<input {...register('email')} />\r\n\r\n// Controlled (more control) - use Controller\r\n<Controller\r\n  name=\"email\"\r\n  control={control}\r\n  render={({ field }) => <Input {...field} />}\r\n/>\r\n```\r\n\r\n**Recommendation**: Use `register` for standard inputs, `Controller` only when necessary (third-party components, custom behavior).\r\n\r\n### Isolation with Controller\r\n\r\n```typescript\r\n// BAD: Entire form re-renders when any field changes\r\nfunction BadForm() {\r\n  const { watch } = useForm()\r\n  const values = watch() // Watches ALL fields\r\n\r\n  return <div>{JSON.stringify(values)}</div>\r\n}\r\n\r\n// GOOD: Only re-render when specific field changes\r\nfunction GoodForm() {\r\n  const { watch } = useForm()\r\n  const email = watch('email') // Watches only email field\r\n\r\n  return <div>{email}</div>\r\n}\r\n```\r\n\r\n### shouldUnregister Flag\r\n\r\n```typescript\r\nconst form = useForm({\r\n  resolver: zodResolver(schema),\r\n  shouldUnregister: true, // Remove field data when unmounted\r\n})\r\n```\r\n\r\n**When to use**:\r\n- ✅ Multi-step forms where steps have different fields\r\n- ✅ Conditional fields that should not persist\r\n- ✅ Want to clear data when component unmounts\r\n\r\n**When NOT to use**:\r\n- ❌ Want to preserve form data when toggling visibility\r\n- ❌ Navigating between form sections (tabs, accordions)\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **12** documented issues:\r\n\r\n### Issue #1: Zod v4 Type Inference Errors\r\n**Error**: Type inference doesn't work correctly with Zod v4\r\n**Source**: [GitHub Issue #13109](https://github.com/react-hook-form/react-hook-form/issues/13109)\r\n**Why It Happens**: Zod v4 changed how types are inferred\r\n**Prevention**: Use correct type patterns: `type FormData = z.infer<typeof schema>`\r\n\r\n### Issue #2: Uncontrolled to Controlled Warning\r\n**Error**: \"A component is changing an uncontrolled input to be controlled\"\r\n**Source**: React documentation\r\n**Why It Happens**: Not setting defaultValues causes undefined -> value transition\r\n**Prevention**: Always set defaultValues for all fields\r\n\r\n### Issue #3: Nested Object Validation Errors\r\n**Error**: Errors for nested fields don't display correctly\r\n**Source**: Common React Hook Form issue\r\n**Why It Happens**: Accessing nested errors incorrectly\r\n**Prevention**: Use optional chaining: `errors.address?.street?.message`\r\n\r\n### Issue #4: Array Field Re-renders\r\n**Error**: Form re-renders excessively with array fields\r\n**Source**: Performance issue\r\n**Why It Happens**: Not using field.id as key\r\n**Prevention**: Use `key={field.id}` in useFieldArray map\r\n\r\n### Issue #5: Async Validation Race Conditions\r\n**Error**: Multiple validation requests cause conflicting results\r\n**Source**: Common async pattern issue\r\n**Why It Happens**: No debouncing or request cancellation\r\n**Prevention**: Debounce validation and cancel pending requests\r\n\r\n### Issue #6: Server Error Mapping\r\n**Error**: Server validation errors don't map to form fields\r\n**Source**: Integration issue\r\n**Why It Happens**: Server error format doesn't match React Hook Form format\r\n**Prevention**: Use setError() to map server errors to fields\r\n\r\n### Issue #7: Default Values Not Applied\r\n**Error**: Form fields don't show default values\r\n**Source**: Common mistake\r\n**Why It Happens**: defaultValues set after form initialization\r\n**Prevention**: Set defaultValues in useForm options, not useState\r\n\r\n### Issue #8: Controller Field Not Updating\r\n**Error**: Custom component doesn't update when value changes\r\n**Source**: Common Controller issue\r\n**Why It Happens**: Not spreading {...field} in render function\r\n**Prevention**: Always spread {...field} to custom component\r\n\r\n### Issue #9: useFieldArray Key Warnings\r\n**Error**: React warning about duplicate keys in list\r\n**Source**: React list rendering\r\n**Why It Happens**: Using array index as key instead of field.id\r\n**Prevention**: Use field.id: `key={field.id}`\r\n\r\n### Issue #10: Schema Refinement Error Paths\r\n**Error**: Custom validation errors appear at wrong field\r\n**Source**: Zod refinement behavior\r\n**Why It Happens**: Not specifying path in refinement options\r\n**Prevention**: Add path option: `refine(..., { message: '...', path: ['fieldName'] })`\r\n\r\n### Issue #11: Transform vs Preprocess Confusion\r\n**Error**: Data transformation doesn't work as expected\r\n**Source**: Zod API confusion\r\n**Why It Happens**: Using wrong method for use case\r\n**Prevention**: Use transform for output transformation, preprocess for input transformation\r\n\r\n### Issue #12: Multiple Resolver Conflicts\r\n**Error**: Form validation doesn't work with multiple resolvers\r\n**Source**: Configuration error\r\n**Why It Happens**: Trying to use multiple validation libraries\r\n**Prevention**: Use single resolver (zodResolver), combine schemas if needed\r\n\r\n---",
    "Accessibility Best Practices": "### ARIA Attributes\r\n\r\n```typescript\r\nfunction AccessibleForm() {\r\n  const { register, handleSubmit, formState: { errors } } = useForm({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input\r\n          id=\"email\"\r\n          {...register('email')}\r\n          aria-invalid={errors.email ? 'true' : 'false'}\r\n          aria-describedby={errors.email ? 'email-error' : undefined}\r\n        />\r\n        {errors.email && (\r\n          <span id=\"email-error\" role=\"alert\">\r\n            {errors.email.message}\r\n          </span>\r\n        )}\r\n      </div>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Error Announcements\r\n\r\n```typescript\r\nimport { useEffect } from 'react'\r\n\r\nfunction FormWithAnnouncements() {\r\n  const { formState: { errors, isSubmitted } } = useForm()\r\n\r\n  // Announce errors to screen readers\r\n  useEffect(() => {\r\n    if (isSubmitted && Object.keys(errors).length > 0) {\r\n      const errorCount = Object.keys(errors).length\r\n      const announcement = `Form submission failed with ${errorCount} error${errorCount > 1 ? 's' : ''}`\r\n\r\n      // Create live region for announcement\r\n      const liveRegion = document.createElement('div')\r\n      liveRegion.setAttribute('role', 'alert')\r\n      liveRegion.setAttribute('aria-live', 'assertive')\r\n      liveRegion.textContent = announcement\r\n      document.body.appendChild(liveRegion)\r\n\r\n      setTimeout(() => {\r\n        document.body.removeChild(liveRegion)\r\n      }, 1000)\r\n    }\r\n  }, [errors, isSubmitted])\r\n\r\n  return (\r\n    <form>\r\n      {/* ... */}\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Focus Management\r\n\r\n```typescript\r\nimport { useRef, useEffect } from 'react'\r\n\r\nfunction FormWithFocus() {\r\n  const { handleSubmit, formState: { errors } } = useForm()\r\n  const firstErrorRef = useRef<HTMLInputElement>(null)\r\n\r\n  // Focus first error field on validation failure\r\n  useEffect(() => {\r\n    if (Object.keys(errors).length > 0) {\r\n      firstErrorRef.current?.focus()\r\n    }\r\n  }, [errors])\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <input\r\n        {...register('email')}\r\n        ref={errors.email ? firstErrorRef : undefined}\r\n      />\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n---",
    "References": "See the `references/` directory for deep-dive documentation:\r\n\r\n1. **zod-schemas-guide.md** - Comprehensive Zod schema patterns\r\n2. **rhf-api-reference.md** - Complete React Hook Form API\r\n3. **error-handling.md** - Error messages, formatting, accessibility\r\n4. **accessibility.md** - WCAG compliance, ARIA attributes\r\n5. **performance-optimization.md** - Form modes, validation strategies\r\n6. **shadcn-integration.md** - shadcn/ui Form vs Field components\r\n7. **top-errors.md** - 12 common errors with solutions\r\n8. **links-to-official-docs.md** - Organized documentation links\r\n\r\n---",
    "Form Registration Patterns": "### Pattern 1: Simple Input Registration\r\n\r\n```typescript\r\nfunction BasicForm() {\r\n  const { register, handleSubmit } = useForm<FormData>({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      {/* Spread register result to input */}\r\n      <input {...register('email')} />\r\n      <input {...register('password')} />\r\n\r\n      {/* With custom props */}\r\n      <input\r\n        {...register('username')}\r\n        placeholder=\"Enter username\"\r\n        className=\"input\"\r\n      />\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n**What `register()` Returns**:\r\n```typescript\r\n{\r\n  onChange: (e) => void,\r\n  onBlur: (e) => void,\r\n  ref: (instance) => void,\r\n  name: string,\r\n}\r\n```\r\n\r\n### Pattern 2: Controller (for Custom Components)\r\n\r\nUse `Controller` when the input doesn't expose `ref` (like custom components, React Select, date pickers, etc.):\r\n\r\n```typescript\r\nimport { Controller } from 'react-hook-form'\r\n\r\nfunction FormWithCustomInput() {\r\n  const { control, handleSubmit } = useForm<FormData>({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <Controller\r\n        name=\"category\"\r\n        control={control}\r\n        render={({ field }) => (\r\n          <CustomSelect\r\n            {...field}                      // value, onChange, onBlur, ref\r\n            options={categoryOptions}\r\n          />\r\n        )}\r\n      />\r\n\r\n      {/* With more control */}\r\n      <Controller\r\n        name=\"dateOfBirth\"\r\n        control={control}\r\n        render={({ field, fieldState }) => (\r\n          <div>\r\n            <DatePicker\r\n              selected={field.value}\r\n              onChange={field.onChange}\r\n              onBlur={field.onBlur}\r\n            />\r\n            {fieldState.error && (\r\n              <span>{fieldState.error.message}</span>\r\n            )}\r\n          </div>\r\n        )}\r\n      />\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n**When to Use Controller**:\r\n- ✅ Third-party UI libraries (React Select, Material-UI, Ant Design, etc.)\r\n- ✅ Custom components that don't expose ref\r\n- ✅ Components that don't use onChange (like checkboxes with custom handlers)\r\n- ✅ Need fine-grained control over field behavior\r\n\r\n**When NOT to Use Controller**:\r\n- ❌ Standard HTML inputs (use `register` instead - it's simpler and faster)\r\n- ❌ When performance is critical (Controller adds minimal overhead)\r\n\r\n### Pattern 3: useController (Reusable Controlled Inputs)\r\n\r\n```typescript\r\nimport { useController } from 'react-hook-form'\r\n\r\n// Reusable custom input component\r\nfunction CustomInput({ name, control, label }) {\r\n  const {\r\n    field,\r\n    fieldState: { error },\r\n  } = useController({\r\n    name,\r\n    control,\r\n    defaultValue: '',\r\n  })\r\n\r\n  return (\r\n    <div>\r\n      <label>{label}</label>\r\n      <input {...field} />\r\n      {error && <span>{error.message}</span>}\r\n    </div>\r\n  )\r\n}\r\n\r\n// Usage\r\nfunction MyForm() {\r\n  const { control, handleSubmit } = useForm({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <CustomInput name=\"email\" control={control} label=\"Email\" />\r\n      <CustomInput name=\"username\" control={control} label=\"Username\" />\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n---",
    "Core Concepts": "### useForm Hook Anatomy\r\n\r\n```typescript\r\nconst {\r\n  register,           // Register input fields\r\n  handleSubmit,       // Wrap onSubmit handler\r\n  watch,              // Watch field values\r\n  formState,          // Form state (errors, isValid, isDirty, etc.)\r\n  setValue,           // Set field value programmatically\r\n  getValues,          // Get current form values\r\n  reset,              // Reset form to defaults\r\n  trigger,            // Trigger validation manually\r\n  control,            // Control object for Controller/useController\r\n} = useForm<FormData>({\r\n  resolver: zodResolver(schema),  // Validation resolver\r\n  mode: 'onSubmit',               // When to validate (onSubmit, onChange, onBlur, all)\r\n  defaultValues: {},              // Initial values (REQUIRED for controlled inputs)\r\n})\r\n```\r\n\r\n**useForm Options**:\r\n\r\n| Option | Description | Default |\r\n|--------|-------------|---------|\r\n| `resolver` | Validation resolver (e.g., zodResolver) | undefined |\r\n| `mode` | When to validate ('onSubmit', 'onChange', 'onBlur', 'all') | 'onSubmit' |\r\n| `reValidateMode` | When to re-validate after error | 'onChange' |\r\n| `defaultValues` | Initial form values | {} |\r\n| `shouldUnregister` | Unregister inputs when unmounted | false |\r\n| `criteriaMode` | Return all errors or first error only | 'firstError' |\r\n\r\n**Form Validation Modes**:\r\n- `onSubmit` - Validate on submit (best performance, less responsive)\r\n- `onChange` - Validate on every change (live feedback, more re-renders)\r\n- `onBlur` - Validate when field loses focus (good balance)\r\n- `all` - Validate on submit, blur, and change (most responsive, highest cost)\r\n\r\n### Zod Schema Definition\r\n\r\n```typescript\r\nimport { z } from 'zod'\r\n\r\n// Primitives\r\nconst stringSchema = z.string()\r\nconst numberSchema = z.number()\r\nconst booleanSchema = z.boolean()\r\nconst dateSchema = z.date()\r\n\r\n// With validation\r\nconst emailSchema = z.string().email('Invalid email')\r\nconst ageSchema = z.number().min(18, 'Must be 18+').max(120, 'Invalid age')\r\nconst usernameSchema = z.string().min(3).max(20).regex(/^[a-zA-Z0-9_]+$/)\r\n\r\n// Objects\r\nconst userSchema = z.object({\r\n  name: z.string(),\r\n  email: z.string().email(),\r\n  age: z.number().int().positive(),\r\n})\r\n\r\n// Arrays\r\nconst tagsSchema = z.array(z.string())\r\nconst usersSchema = z.array(userSchema)\r\n\r\n// Optional and Nullable\r\nconst optionalField = z.string().optional()       // string | undefined\r\nconst nullableField = z.string().nullable()       // string | null\r\nconst nullishField = z.string().nullish()         // string | null | undefined\r\n\r\n// Default values\r\nconst withDefault = z.string().default('default value')\r\n\r\n// Unions\r\nconst statusSchema = z.union([\r\n  z.literal('active'),\r\n  z.literal('inactive'),\r\n  z.literal('pending'),\r\n])\r\n// Shorthand for literals\r\nconst statusEnum = z.enum(['active', 'inactive', 'pending'])\r\n\r\n// Nested objects\r\nconst addressSchema = z.object({\r\n  street: z.string(),\r\n  city: z.string(),\r\n  zipCode: z.string().regex(/^\\d{5}$/),\r\n})\r\n\r\nconst profileSchema = z.object({\r\n  name: z.string(),\r\n  address: addressSchema,  // Nested object\r\n})\r\n\r\n// Custom error messages\r\nconst passwordSchema = z.string()\r\n  .min(8, { message: 'Password must be at least 8 characters' })\r\n  .regex(/[A-Z]/, { message: 'Password must contain uppercase letter' })\r\n  .regex(/[0-9]/, { message: 'Password must contain number' })\r\n```\r\n\r\n**Type Inference**:\r\n```typescript\r\nconst userSchema = z.object({\r\n  name: z.string(),\r\n  age: z.number(),\r\n})\r\n\r\n// Automatically infer TypeScript type\r\ntype User = z.infer<typeof userSchema>\r\n// Result: { name: string; age: number }\r\n```\r\n\r\n### Zod Refinements (Custom Validation)\r\n\r\n```typescript\r\n// Simple refinement\r\nconst passwordConfirmSchema = z.object({\r\n  password: z.string().min(8),\r\n  confirmPassword: z.string(),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: \"Passwords don't match\",\r\n  path: ['confirmPassword'], // Error will appear on confirmPassword field\r\n})\r\n\r\n// Multiple refinements\r\nconst signupSchema = z.object({\r\n  username: z.string(),\r\n  email: z.string().email(),\r\n  age: z.number(),\r\n})\r\n  .refine((data) => data.username !== data.email.split('@')[0], {\r\n    message: 'Username cannot be your email prefix',\r\n    path: ['username'],\r\n  })\r\n  .refine((data) => data.age >= 18, {\r\n    message: 'Must be 18 or older',\r\n    path: ['age'],\r\n  })\r\n\r\n// Async refinement (for API checks)\r\nconst usernameSchema = z.string().refine(async (username) => {\r\n  // Check if username is available via API\r\n  const response = await fetch(`/api/check-username?username=${username}`)\r\n  const { available } = await response.json()\r\n  return available\r\n}, {\r\n  message: 'Username is already taken',\r\n})\r\n```\r\n\r\n### Zod Transforms (Data Manipulation)\r\n\r\n```typescript\r\n// Transform string to number\r\nconst ageSchema = z.string().transform((val) => parseInt(val, 10))\r\n\r\n// Transform to uppercase\r\nconst uppercaseSchema = z.string().transform((val) => val.toUpperCase())\r\n\r\n// Transform date string to Date object\r\nconst dateSchema = z.string().transform((val) => new Date(val))\r\n\r\n// Trim whitespace\r\nconst trimmedSchema = z.string().transform((val) => val.trim())\r\n\r\n// Complex transform\r\nconst userInputSchema = z.object({\r\n  email: z.string().email().transform((val) => val.toLowerCase()),\r\n  tags: z.string().transform((val) => val.split(',').map(tag => tag.trim())),\r\n})\r\n\r\n// Chain transform and refine\r\nconst positiveNumberSchema = z.string()\r\n  .transform((val) => parseFloat(val))\r\n  .refine((val) => !isNaN(val), { message: 'Must be a number' })\r\n  .refine((val) => val > 0, { message: 'Must be positive' })\r\n```\r\n\r\n### zodResolver Integration\r\n\r\n```typescript\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\n\r\nconst form = useForm<FormData>({\r\n  resolver: zodResolver(schema),\r\n})\r\n```\r\n\r\n**What zodResolver Does**:\r\n1. Takes your Zod schema\r\n2. Converts it to a format React Hook Form understands\r\n3. Provides validation function that runs on form submission\r\n4. Maps Zod errors to React Hook Form error format\r\n5. Preserves type safety with TypeScript inference\r\n\r\n**zodResolver Options**:\r\n```typescript\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\n\r\n// With options\r\nconst form = useForm({\r\n  resolver: zodResolver(schema, {\r\n    async: false,     // Use async validation\r\n    raw: false,       // Return raw Zod error\r\n  }),\r\n})\r\n```\r\n\r\n---",
    "Templates": "See the `templates/` directory for working examples:\r\n\r\n1. **basic-form.tsx** - Simple login/signup form\r\n2. **advanced-form.tsx** - Nested objects, arrays, conditional fields\r\n3. **shadcn-form.tsx** - shadcn/ui Form component integration\r\n4. **server-validation.ts** - Server-side validation with same schema\r\n5. **async-validation.tsx** - Async validation with debouncing\r\n6. **dynamic-fields.tsx** - useFieldArray for adding/removing items\r\n7. **multi-step-form.tsx** - Wizard with per-step validation\r\n8. **custom-error-display.tsx** - Custom error formatting\r\n9. **package.json** - Complete dependencies\r\n\r\n---",
    "Error Handling": "### Displaying Errors\r\n\r\n```typescript\r\nfunction FormWithErrors() {\r\n  const { register, handleSubmit, formState: { errors } } = useForm<FormData>({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <div>\r\n        <input {...register('email')} aria-invalid={errors.email ? 'true' : 'false'} />\r\n\r\n        {/* Simple error display */}\r\n        {errors.email && <span>{errors.email.message}</span>}\r\n\r\n        {/* Accessible error display */}\r\n        {errors.email && (\r\n          <span role=\"alert\" className=\"error\">\r\n            {errors.email.message}\r\n          </span>\r\n        )}\r\n\r\n        {/* Error with icon */}\r\n        {errors.email && (\r\n          <div role=\"alert\" className=\"error\">\r\n            <ErrorIcon />\r\n            <span>{errors.email.message}</span>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Error Object Structure\r\n\r\n```typescript\r\n// errors object structure\r\n{\r\n  email: {\r\n    type: 'invalid_string',\r\n    message: 'Invalid email address',\r\n  },\r\n  password: {\r\n    type: 'too_small',\r\n    message: 'Password must be at least 8 characters',\r\n  },\r\n  // Nested errors\r\n  address: {\r\n    street: {\r\n      type: 'invalid_type',\r\n      message: 'Expected string, received undefined',\r\n    },\r\n  },\r\n}\r\n```\r\n\r\n### Form-Level Validation Errors\r\n\r\n```typescript\r\nconst schema = z.object({\r\n  password: z.string().min(8),\r\n  confirmPassword: z.string(),\r\n}).refine((data) => data.password === data.confirmPassword, {\r\n  message: \"Passwords don't match\",\r\n  path: ['confirmPassword'], // Attach error to confirmPassword field\r\n})\r\n\r\n// Without path - creates root error\r\n.refine((data) => someCondition, {\r\n  message: 'Form validation failed',\r\n})\r\n\r\n// Access root errors\r\nconst { formState: { errors } } = useForm()\r\nerrors.root?.message // Root-level error\r\n```\r\n\r\n### Server Errors Integration\r\n\r\n```typescript\r\nfunction FormWithServerErrors() {\r\n  const { register, handleSubmit, setError, formState: { errors } } = useForm({\r\n    resolver: zodResolver(schema),\r\n  })\r\n\r\n  const onSubmit = async (data) => {\r\n    try {\r\n      const response = await fetch('/api/submit', {\r\n        method: 'POST',\r\n        body: JSON.stringify(data),\r\n      })\r\n\r\n      if (!response.ok) {\r\n        const { errors: serverErrors } = await response.json()\r\n\r\n        // Map server errors to form fields\r\n        Object.entries(serverErrors).forEach(([field, message]) => {\r\n          setError(field, {\r\n            type: 'server',\r\n            message,\r\n          })\r\n        })\r\n\r\n        return\r\n      }\r\n\r\n      // Success!\r\n    } catch (error) {\r\n      // Generic error\r\n      setError('root', {\r\n        type: 'server',\r\n        message: 'An error occurred. Please try again.',\r\n      })\r\n    }\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      {errors.root && <div role=\"alert\">{errors.root.message}</div>}\r\n      {/* ... */}\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ **Set defaultValues** to prevent \"uncontrolled to controlled\" warnings\r\n```typescript\r\nconst form = useForm({\r\n  defaultValues: { email: '', password: '' }, // ALWAYS set defaults\r\n})\r\n```\r\n\r\n✅ **Use zodResolver** for Zod integration\r\n```typescript\r\nconst form = useForm({\r\n  resolver: zodResolver(schema), // Required for Zod validation\r\n})\r\n```\r\n\r\n✅ **Type forms with z.infer**\r\n```typescript\r\ntype FormData = z.infer<typeof schema> // Automatic type inference\r\n```\r\n\r\n✅ **Validate on both client AND server**\r\n```typescript\r\n// Client\r\nconst form = useForm({ resolver: zodResolver(schema) })\r\n\r\n// Server\r\nconst data = schema.parse(await req.json()) // SAME schema\r\n```\r\n\r\n✅ **Use formState.errors for error display**\r\n```typescript\r\n{errors.email && <span role=\"alert\">{errors.email.message}</span>}\r\n```\r\n\r\n✅ **Add ARIA attributes for accessibility**\r\n```typescript\r\n<input\r\n  {...register('email')}\r\n  aria-invalid={errors.email ? 'true' : 'false'}\r\n  aria-describedby=\"email-error\"\r\n/>\r\n```\r\n\r\n✅ **Use field.id for useFieldArray keys**\r\n```typescript\r\n{fields.map((field) => <div key={field.id}>{/* ... */}</div>)}\r\n```\r\n\r\n✅ **Debounce async validation**\r\n```typescript\r\nconst debouncedValidation = useDebouncedCallback(() => trigger('username'), 500)\r\n```\r\n\r\n### Never Do\r\n\r\n❌ **Skip server-side validation** (security vulnerability!)\r\n```typescript\r\n// BAD: Only client validation\r\nconst form = useForm({ resolver: zodResolver(schema) })\r\n// API endpoint has no validation\r\n\r\n// GOOD: Validate on both client and server\r\nconst form = useForm({ resolver: zodResolver(schema) })\r\n// API: schema.parse(data) on server too\r\n```\r\n\r\n❌ **Use Zod v4 without checking type inference**\r\n```typescript\r\n// Issue #13109: Zod v4 has type inference changes\r\n// Test your types carefully when upgrading\r\n```\r\n\r\n❌ **Forget to spread {...field} in Controller**\r\n```typescript\r\n// BAD\r\n<Controller render={({ field }) => <Input value={field.value} />} />\r\n\r\n// GOOD\r\n<Controller render={({ field }) => <Input {...field} />} />\r\n```\r\n\r\n❌ **Mutate form values directly**\r\n```typescript\r\n// BAD\r\nconst values = getValues()\r\nvalues.email = 'new@email.com' // Direct mutation\r\n\r\n// GOOD\r\nsetValue('email', 'new@email.com') // Use setValue\r\n```\r\n\r\n❌ **Use inline validation without debouncing**\r\n```typescript\r\n// BAD: Validates on every keystroke\r\nconst form = useForm({ mode: 'onChange' })\r\n\r\n// GOOD: Debounce async validation\r\nconst debouncedTrigger = useDebouncedCallback(() => trigger(), 500)\r\n```\r\n\r\n❌ **Mix controlled and uncontrolled inputs**\r\n```typescript\r\n// BAD: Mixing patterns\r\n<input {...register('email')} value={email} onChange={setEmail} />\r\n\r\n// GOOD: Choose one pattern\r\n<input {...register('email')} /> // Uncontrolled\r\n// OR\r\n<Controller render={({ field }) => <Input {...field} />} /> // Controlled\r\n```\r\n\r\n❌ **Use index as key in useFieldArray**\r\n```typescript\r\n// BAD\r\n{fields.map((field, index) => <div key={index}>{/* ... */}</div>)}\r\n\r\n// GOOD\r\n{fields.map((field) => <div key={field.id}>{/* ... */}</div>)}\r\n```\r\n\r\n❌ **Forget defaultValues for all fields**\r\n```typescript\r\n// BAD: Missing defaults causes warnings\r\nconst form = useForm({\r\n  resolver: zodResolver(schema),\r\n})\r\n\r\n// GOOD: Set defaults for all fields\r\nconst form = useForm({\r\n  resolver: zodResolver(schema),\r\n  defaultValues: { email: '', password: '', remember: false },\r\n})\r\n```\r\n\r\n---",
    "Official Documentation": "- **React Hook Form**: https://react-hook-form.com/\r\n- **Zod**: https://zod.dev/\r\n- **@hookform/resolvers**: https://github.com/react-hook-form/resolvers\r\n- **shadcn/ui Form**: https://ui.shadcn.com/docs/components/form\r\n\r\n---\r\n\r\n**License**: MIT\r\n**Last Verified**: 2025-10-23\r\n**Maintainer**: Jeremy Dawes (jeremy@jezweb.net)",
    "Quick Start (10 Minutes)": "### 1. Install Packages\r\n\r\n```bash\r\nnpm install react-hook-form@7.65.0 zod@4.1.12 @hookform/resolvers@5.2.2\r\n```\r\n\r\n**Why These Packages**:\r\n- **react-hook-form**: Performant, flexible form library with minimal re-renders\r\n- **zod**: TypeScript-first schema validation with type inference\r\n- **@hookform/resolvers**: Adapter to connect Zod (and other validators) to React Hook Form\r\n\r\n### 2. Create Your First Form\r\n\r\n```typescript\r\nimport { useForm } from 'react-hook-form'\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { z } from 'zod'\r\n\r\n// 1. Define validation schema\r\nconst loginSchema = z.object({\r\n  email: z.string().email('Invalid email address'),\r\n  password: z.string().min(8, 'Password must be at least 8 characters'),\r\n})\r\n\r\n// 2. Infer TypeScript type from schema\r\ntype LoginFormData = z.infer<typeof loginSchema>\r\n\r\nfunction LoginForm() {\r\n  // 3. Initialize form with zodResolver\r\n  const {\r\n    register,\r\n    handleSubmit,\r\n    formState: { errors, isSubmitting },\r\n  } = useForm<LoginFormData>({\r\n    resolver: zodResolver(loginSchema),\r\n    defaultValues: {\r\n      email: '',\r\n      password: '',\r\n    },\r\n  })\r\n\r\n  // 4. Handle form submission\r\n  const onSubmit = async (data: LoginFormData) => {\r\n    // Data is guaranteed to be valid here\r\n    console.log('Valid data:', data)\r\n    // Make API call, etc.\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <div>\r\n        <label htmlFor=\"email\">Email</label>\r\n        <input id=\"email\" type=\"email\" {...register('email')} />\r\n        {errors.email && (\r\n          <span role=\"alert\" className=\"error\">\r\n            {errors.email.message}\r\n          </span>\r\n        )}\r\n      </div>\r\n\r\n      <div>\r\n        <label htmlFor=\"password\">Password</label>\r\n        <input id=\"password\" type=\"password\" {...register('password')} />\r\n        {errors.password && (\r\n          <span role=\"alert\" className=\"error\">\r\n            {errors.password.message}\r\n          </span>\r\n        )}\r\n      </div>\r\n\r\n      <button type=\"submit\" disabled={isSubmitting}>\r\n        {isSubmitting ? 'Logging in...' : 'Login'}\r\n      </button>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n**CRITICAL**:\r\n- Always set `defaultValues` to prevent \"uncontrolled to controlled\" warnings\r\n- Use `zodResolver(schema)` to connect Zod validation\r\n- Type form with `z.infer<typeof schema>` for full type safety\r\n- Validate on both client AND server (never trust client validation alone)\r\n\r\n### 3. Add Server-Side Validation\r\n\r\n```typescript\r\n// server/api/login.ts\r\nimport { z } from 'zod'\r\n\r\n// SAME schema on server\r\nconst loginSchema = z.object({\r\n  email: z.string().email('Invalid email address'),\r\n  password: z.string().min(8, 'Password must be at least 8 characters'),\r\n})\r\n\r\nexport async function loginHandler(req: Request) {\r\n  try {\r\n    // Parse and validate request body\r\n    const data = loginSchema.parse(await req.json())\r\n\r\n    // Data is type-safe and validated\r\n    // Proceed with authentication logic\r\n    return { success: true }\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      // Return validation errors to client\r\n      return { success: false, errors: error.flatten().fieldErrors }\r\n    }\r\n    throw error\r\n  }\r\n}\r\n```\r\n\r\n**Why Server Validation**:\r\n- Client validation can be bypassed (inspect element, Postman, curl)\r\n- Server validation is your security layer\r\n- Same Zod schema = single source of truth\r\n- Type safety across frontend and backend\r\n\r\n---",
    "Advanced Patterns": "### Dynamic Form Fields (useFieldArray)\r\n\r\n```typescript\r\nimport { useForm, useFieldArray } from 'react-hook-form'\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { z } from 'zod'\r\n\r\nconst contactSchema = z.object({\r\n  contacts: z.array(\r\n    z.object({\r\n      name: z.string().min(1, 'Name is required'),\r\n      email: z.string().email('Invalid email'),\r\n    })\r\n  ).min(1, 'At least one contact is required'),\r\n})\r\n\r\ntype ContactFormData = z.infer<typeof contactSchema>\r\n\r\nfunction ContactListForm() {\r\n  const { register, control, handleSubmit, formState: { errors } } = useForm<ContactFormData>({\r\n    resolver: zodResolver(contactSchema),\r\n    defaultValues: {\r\n      contacts: [{ name: '', email: '' }],\r\n    },\r\n  })\r\n\r\n  const { fields, append, remove } = useFieldArray({\r\n    control,\r\n    name: 'contacts',\r\n  })\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      {fields.map((field, index) => (\r\n        <div key={field.id}> {/* IMPORTANT: Use field.id, not index */}\r\n          <input\r\n            {...register(`contacts.${index}.name` as const)}\r\n            placeholder=\"Name\"\r\n          />\r\n          {errors.contacts?.[index]?.name && (\r\n            <span>{errors.contacts[index].name.message}</span>\r\n          )}\r\n\r\n          <input\r\n            {...register(`contacts.${index}.email` as const)}\r\n            placeholder=\"Email\"\r\n          />\r\n          {errors.contacts?.[index]?.email && (\r\n            <span>{errors.contacts[index].email.message}</span>\r\n          )}\r\n\r\n          <button type=\"button\" onClick={() => remove(index)}>\r\n            Remove\r\n          </button>\r\n        </div>\r\n      ))}\r\n\r\n      <button\r\n        type=\"button\"\r\n        onClick={() => append({ name: '', email: '' })}\r\n      >\r\n        Add Contact\r\n      </button>\r\n\r\n      <button type=\"submit\">Submit</button>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n**useFieldArray API**:\r\n- `fields` - Array of field items with unique IDs\r\n- `append(value)` - Add new item to end\r\n- `prepend(value)` - Add new item to beginning\r\n- `insert(index, value)` - Insert item at index\r\n- `remove(index)` - Remove item at index\r\n- `update(index, value)` - Update item at index\r\n- `replace(values)` - Replace entire array\r\n\r\n### Async Validation with Debouncing\r\n\r\n```typescript\r\nimport { useForm } from 'react-hook-form'\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { z } from 'zod'\r\nimport { useDebouncedCallback } from 'use-debounce' // npm install use-debounce\r\n\r\nconst usernameSchema = z.string().min(3).refine(async (username) => {\r\n  const response = await fetch(`/api/check-username?username=${username}`)\r\n  const { available } = await response.json()\r\n  return available\r\n}, {\r\n  message: 'Username is already taken',\r\n})\r\n\r\nfunction AsyncValidationForm() {\r\n  const { register, handleSubmit, trigger, formState: { errors, isValidating } } = useForm({\r\n    resolver: zodResolver(z.object({ username: usernameSchema })),\r\n    mode: 'onChange', // Validate on every change\r\n  })\r\n\r\n  // Debounce validation to avoid too many API calls\r\n  const debouncedValidation = useDebouncedCallback(() => {\r\n    trigger('username')\r\n  }, 500) // Wait 500ms after user stops typing\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      <input\r\n        {...register('username')}\r\n        onChange={(e) => {\r\n          register('username').onChange(e)\r\n          debouncedValidation()\r\n        }}\r\n      />\r\n      {isValidating && <span>Checking availability...</span>}\r\n      {errors.username && <span>{errors.username.message}</span>}\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Multi-Step Form (Wizard)\r\n\r\n```typescript\r\nimport { useState } from 'react'\r\nimport { useForm } from 'react-hook-form'\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { z } from 'zod'\r\n\r\n// Step schemas\r\nconst step1Schema = z.object({\r\n  name: z.string().min(1, 'Name is required'),\r\n  email: z.string().email('Invalid email'),\r\n})\r\n\r\nconst step2Schema = z.object({\r\n  address: z.string().min(1, 'Address is required'),\r\n  city: z.string().min(1, 'City is required'),\r\n})\r\n\r\nconst step3Schema = z.object({\r\n  cardNumber: z.string().regex(/^\\d{16}$/, 'Invalid card number'),\r\n  cvv: z.string().regex(/^\\d{3,4}$/, 'Invalid CVV'),\r\n})\r\n\r\n// Combined schema for final validation\r\nconst fullSchema = step1Schema.merge(step2Schema).merge(step3Schema)\r\n\r\ntype FormData = z.infer<typeof fullSchema>\r\n\r\nfunction MultiStepForm() {\r\n  const [step, setStep] = useState(1)\r\n\r\n  const { register, handleSubmit, trigger, formState: { errors } } = useForm<FormData>({\r\n    resolver: zodResolver(fullSchema),\r\n    mode: 'onChange',\r\n  })\r\n\r\n  const nextStep = async () => {\r\n    let fieldsToValidate: (keyof FormData)[] = []\r\n\r\n    if (step === 1) {\r\n      fieldsToValidate = ['name', 'email']\r\n    } else if (step === 2) {\r\n      fieldsToValidate = ['address', 'city']\r\n    }\r\n\r\n    // Validate current step fields\r\n    const isValid = await trigger(fieldsToValidate)\r\n\r\n    if (isValid) {\r\n      setStep(step + 1)\r\n    }\r\n  }\r\n\r\n  const prevStep = () => setStep(step - 1)\r\n\r\n  const onSubmit = (data: FormData) => {\r\n    console.log('Final data:', data)\r\n  }\r\n\r\n  return (\r\n    <form onSubmit={handleSubmit(onSubmit)}>\r\n      {/* Progress indicator */}\r\n      <div className=\"progress\">\r\n        Step {step} of 3\r\n      </div>\r\n\r\n      {/* Step 1 */}\r\n      {step === 1 && (\r\n        <div>\r\n          <h2>Personal Information</h2>\r\n          <input {...register('name')} placeholder=\"Name\" />\r\n          {errors.name && <span>{errors.name.message}</span>}\r\n\r\n          <input {...register('email')} placeholder=\"Email\" />\r\n          {errors.email && <span>{errors.email.message}</span>}\r\n        </div>\r\n      )}\r\n\r\n      {/* Step 2 */}\r\n      {step === 2 && (\r\n        <div>\r\n          <h2>Address</h2>\r\n          <input {...register('address')} placeholder=\"Address\" />\r\n          {errors.address && <span>{errors.address.message}</span>}\r\n\r\n          <input {...register('city')} placeholder=\"City\" />\r\n          {errors.city && <span>{errors.city.message}</span>}\r\n        </div>\r\n      )}\r\n\r\n      {/* Step 3 */}\r\n      {step === 3 && (\r\n        <div>\r\n          <h2>Payment</h2>\r\n          <input {...register('cardNumber')} placeholder=\"Card Number\" />\r\n          {errors.cardNumber && <span>{errors.cardNumber.message}</span>}\r\n\r\n          <input {...register('cvv')} placeholder=\"CVV\" />\r\n          {errors.cvv && <span>{errors.cvv.message}</span>}\r\n        </div>\r\n      )}\r\n\r\n      {/* Navigation */}\r\n      <div>\r\n        {step > 1 && (\r\n          <button type=\"button\" onClick={prevStep}>\r\n            Previous\r\n          </button>\r\n        )}\r\n        {step < 3 ? (\r\n          <button type=\"button\" onClick={nextStep}>\r\n            Next\r\n          </button>\r\n        ) : (\r\n          <button type=\"submit\">Submit</button>\r\n        )}\r\n      </div>\r\n    </form>\r\n  )\r\n}\r\n```\r\n\r\n### Conditional Validation\r\n\r\n```typescript\r\nimport { z } from 'zod'\r\n\r\n// Schema with conditional validation\r\nconst formSchema = z.discriminatedUnion('accountType', [\r\n  z.object({\r\n    accountType: z.literal('personal'),\r\n    name: z.string().min(1),\r\n  }),\r\n  z.object({\r\n    accountType: z.literal('business'),\r\n    companyName: z.string().min(1),\r\n    taxId: z.string().regex(/^\\d{9}$/),\r\n  }),\r\n])\r\n\r\n// Alternative: Using refine\r\nconst conditionalSchema = z.object({\r\n  hasDiscount: z.boolean(),\r\n  discountCode: z.string().optional(),\r\n}).refine((data) => {\r\n  // If hasDiscount is true, discountCode is required\r\n  if (data.hasDiscount && !data.discountCode) {\r\n    return false\r\n  }\r\n  return true\r\n}, {\r\n  message: 'Discount code is required when discount is enabled',\r\n  path: ['discountCode'],\r\n})\r\n```\r\n\r\n---",
    "shadcn/ui Integration": "### Using Form Component (Legacy)\r\n\r\n```typescript\r\nimport { zodResolver } from '@hookform/resolvers/zod'\r\nimport { useForm } from 'react-hook-form'\r\nimport { z } from 'zod'\r\nimport {\r\n  Form,\r\n  FormControl,\r\n  FormDescription,\r\n  FormField,\r\n  FormItem,\r\n  FormLabel,\r\n  FormMessage,\r\n} from '@/components/ui/form'\r\nimport { Input } from '@/components/ui/input'\r\n\r\nconst formSchema = z.object({\r\n  username: z.string().min(2, 'Username must be at least 2 characters'),\r\n  email: z.string().email('Invalid email address'),\r\n})\r\n\r\nfunction ProfileForm() {\r\n  const form = useForm<z.infer<typeof formSchema>>({\r\n    resolver: zodResolver(formSchema),\r\n    defaultValues: {\r\n      username: '',\r\n      email: '',\r\n    },\r\n  })\r\n\r\n  return (\r\n    <Form {...form}>\r\n      <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-8\">\r\n        <FormField\r\n          control={form.control}\r\n          name=\"username\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Username</FormLabel>\r\n              <FormControl>\r\n                <Input placeholder=\"shadcn\" {...field} />\r\n              </FormControl>\r\n              <FormDescription>\r\n                This is your public display name.\r\n              </FormDescription>\r\n              <FormMessage />\r\n            </FormItem>\r\n          )}\r\n        />\r\n\r\n        <FormField\r\n          control={form.control}\r\n          name=\"email\"\r\n          render={({ field }) => (\r\n            <FormItem>\r\n              <FormLabel>Email</FormLabel>\r\n              <FormControl>\r\n                <Input type=\"email\" placeholder=\"email@example.com\" {...field} />\r\n              </FormControl>\r\n              <FormMessage />\r\n            </FormItem>\r\n          )}\r\n        />\r\n\r\n        <button type=\"submit\">Submit</button>\r\n      </form>\r\n    </Form>\r\n  )\r\n}\r\n```\r\n\r\n**Note**: shadcn/ui states \"We are not actively developing the Form component anymore.\" They recommend using the Field component for new implementations.\r\n\r\n### Using Field Component (Recommended)\r\n\r\nCheck shadcn/ui documentation for the latest Field component API as it's the actively maintained approach.\r\n\r\n---"
  }
}