{
  "description": "\"Molecular machine learning toolkit. Property prediction (ADMET, toxicity), GNNs (GCN, MPNN), MoleculeNet benchmarks, pretrained models, featurization, for drug discovery ML.\"",
  "references": {
    "files": [
      "references/api_reference.md",
      "references/workflows.md"
    ]
  },
  "content": "### 1. Molecular Data Loading and Processing\r\n\r\nDeepChem provides specialized loaders for various chemical data formats:\r\n\r\n```python\r\nimport deepchem as dc\r\n\r\nfeaturizer = dc.feat.CircularFingerprint(radius=2, size=2048)\r\nloader = dc.data.CSVLoader(\r\n    tasks=['solubility', 'toxicity'],\r\n    feature_field='smiles',\r\n    featurizer=featurizer\r\n)\r\ndataset = loader.create_dataset('molecules.csv')\r\n\r\nloader = dc.data.SDFLoader(tasks=['activity'], featurizer=featurizer)\r\ndataset = loader.create_dataset('compounds.sdf')\r\n\r\nloader = dc.data.FASTALoader()\r\ndataset = loader.create_dataset('proteins.fasta')\r\n```\r\n\r\n**Key Loaders**:\r\n- `CSVLoader`: Tabular data with molecular identifiers\r\n- `SDFLoader`: Molecular structure files\r\n- `FASTALoader`: Protein/DNA sequences\r\n- `ImageLoader`: Molecular images\r\n- `JsonLoader`: JSON-formatted datasets\r\n\r\n### 2. Molecular Featurization\r\n\r\nConvert molecules into numerical representations for ML models.\r\n\r\n#### Decision Tree for Featurizer Selection\r\n\r\n```\r\nIs the model a graph neural network?\r\n├─ YES → Use graph featurizers\r\n│   ├─ Standard GNN → MolGraphConvFeaturizer\r\n│   ├─ Message passing → DMPNNFeaturizer\r\n│   └─ Pretrained → GroverFeaturizer\r\n│\r\n└─ NO → What type of model?\r\n    ├─ Traditional ML (RF, XGBoost, SVM)\r\n    │   ├─ Fast baseline → CircularFingerprint (ECFP)\r\n    │   ├─ Interpretable → RDKitDescriptors\r\n    │   └─ Maximum coverage → MordredDescriptors\r\n    │\r\n    ├─ Deep learning (non-graph)\r\n    │   ├─ Dense networks → CircularFingerprint\r\n    │   └─ CNN → SmilesToImage\r\n    │\r\n    ├─ Sequence models (LSTM, Transformer)\r\n    │   └─ SmilesToSeq\r\n    │\r\n    └─ 3D structure analysis\r\n        └─ CoulombMatrix\r\n```\r\n\r\n#### Example Featurization\r\n\r\n```python\r\nfp = dc.feat.CircularFingerprint(radius=2, size=2048)\r\n\r\ndesc = dc.feat.RDKitDescriptors()\r\n\r\ngraph_feat = dc.feat.MolGraphConvFeaturizer()\r\n\r\nfeatures = fp.featurize(['CCO', 'c1ccccc1'])\r\n```\r\n\r\n**Selection Guide**:\r\n- **Small datasets (<1K)**: CircularFingerprint or RDKitDescriptors\r\n- **Medium datasets (1K-100K)**: CircularFingerprint or graph featurizers\r\n- **Large datasets (>100K)**: Graph featurizers (MolGraphConvFeaturizer, DMPNNFeaturizer)\r\n- **Transfer learning**: Pretrained model featurizers (GroverFeaturizer)\r\n\r\nSee `references/api_reference.md` for complete featurizer documentation.\r\n\r\n### 3. Data Splitting\r\n\r\n**Critical**: For drug discovery tasks, use `ScaffoldSplitter` to prevent data leakage from similar molecular structures appearing in both training and test sets.\r\n\r\n```python\r\nsplitter = dc.splits.ScaffoldSplitter()\r\ntrain, valid, test = splitter.train_valid_test_split(\r\n    dataset,\r\n    frac_train=0.8,\r\n    frac_valid=0.1,\r\n    frac_test=0.1\r\n)\r\n\r\nsplitter = dc.splits.RandomSplitter()\r\ntrain, test = splitter.train_test_split(dataset)\r\n\r\nsplitter = dc.splits.RandomStratifiedSplitter()\r\ntrain, test = splitter.train_test_split(dataset)\r\n```\r\n\r\n**Available Splitters**:\r\n- `ScaffoldSplitter`: Split by molecular scaffolds (prevents leakage)\r\n- `ButinaSplitter`: Clustering-based molecular splitting\r\n- `MaxMinSplitter`: Maximize diversity between sets\r\n- `RandomSplitter`: Random splitting\r\n- `RandomStratifiedSplitter`: Preserves class distributions\r\n\r\n### 4. Model Selection and Training\r\n\r\n#### Quick Model Selection Guide\r\n\r\n| Dataset Size | Task | Recommended Model | Featurizer |\r\n|-------------|------|-------------------|------------|\r\n| < 1K samples | Any | SklearnModel (RandomForest) | CircularFingerprint |\r\n| 1K-100K | Classification/Regression | GBDTModel or MultitaskRegressor | CircularFingerprint |\r\n| > 100K | Molecular properties | GCNModel, AttentiveFPModel, DMPNNModel | MolGraphConvFeaturizer |\r\n| Any (small preferred) | Transfer learning | ChemBERTa, GROVER, MolFormer | Model-specific |\r\n| Crystal structures | Materials properties | CGCNNModel, MEGNetModel | Structure-based |\r\n| Protein sequences | Protein properties | ProtBERT | Sequence-based |\r\n\r\n#### Example: Traditional ML\r\n```python\r\nfrom sklearn.ensemble import RandomForestRegressor\r\n\r\nsklearn_model = RandomForestRegressor(n_estimators=100)\r\nmodel = dc.models.SklearnModel(model=sklearn_model)\r\nmodel.fit(train)\r\n```\r\n\r\n#### Example: Deep Learning\r\n```python\r\nmodel = dc.models.MultitaskRegressor(\r\n    n_tasks=2,\r\n    n_features=2048,\r\n    layer_sizes=[1000, 500],\r\n    dropouts=0.25,\r\n    learning_rate=0.001\r\n)\r\nmodel.fit(train, nb_epoch=50)\r\n```\r\n\r\n#### Example: Graph Neural Networks\r\n```python\r\nmodel = dc.models.GCNModel(\r\n    n_tasks=1,\r\n    mode='regression',\r\n    batch_size=128,\r\n    learning_rate=0.001\r\n)\r\nmodel.fit(train, nb_epoch=50)\r\n\r\nmodel = dc.models.GATModel(n_tasks=1, mode='classification')\r\nmodel.fit(train, nb_epoch=50)\r\n\r\nmodel = dc.models.AttentiveFPModel(n_tasks=1, mode='regression')\r\nmodel.fit(train, nb_epoch=50)\r\n```\r\n\r\n### 5. MoleculeNet Benchmarks\r\n\r\nQuick access to 30+ curated benchmark datasets with standardized train/valid/test splits:\r\n\r\n```python\r\ntasks, datasets, transformers = dc.molnet.load_tox21(\r\n    featurizer='GraphConv',  # or 'ECFP', 'Weave', 'Raw'\r\n    splitter='scaffold',     # or 'random', 'stratified'\r\n    reload=False\r\n)\r\ntrain, valid, test = datasets\r\n\r\nmodel = dc.models.GCNModel(n_tasks=len(tasks), mode='classification')\r\nmodel.fit(train, nb_epoch=50)\r\n\r\nmetric = dc.metrics.Metric(dc.metrics.roc_auc_score)\r\ntest_score = model.evaluate(test, [metric])\r\n```\r\n\r\n**Common Datasets**:\r\n- **Classification**: `load_tox21()`, `load_bbbp()`, `load_hiv()`, `load_clintox()`\r\n- **Regression**: `load_delaney()`, `load_freesolv()`, `load_lipo()`\r\n- **Quantum properties**: `load_qm7()`, `load_qm8()`, `load_qm9()`\r\n- **Materials**: `load_perovskite()`, `load_bandgap()`, `load_mp_formation_energy()`\r\n\r\nSee `references/api_reference.md` for complete dataset list.\r\n\r\n### 6. Transfer Learning\r\n\r\nLeverage pretrained models for improved performance, especially on small datasets:\r\n\r\n```python\r\nmodel = dc.models.HuggingFaceModel(\r\n    model='seyonec/ChemBERTa-zinc-base-v1',\r\n    task='classification',\r\n    n_tasks=1,\r\n    learning_rate=2e-5  # Lower LR for fine-tuning\r\n)\r\nmodel.fit(train, nb_epoch=10)\r\n\r\nmodel = dc.models.GroverModel(\r\n    task='regression',\r\n    n_tasks=1\r\n)\r\nmodel.fit(train, nb_epoch=20)\r\n```\r\n\r\n**When to use transfer learning**:\r\n- Small datasets (< 1000 samples)\r\n- Novel molecular scaffolds\r\n- Limited computational resources\r\n- Need for rapid prototyping\r\n\r\nUse the `scripts/transfer_learning.py` script for guided transfer learning workflows.\r\n\r\n### 7. Model Evaluation\r\n\r\n```python\r\nclassification_metrics = [\r\n    dc.metrics.Metric(dc.metrics.roc_auc_score, name='ROC-AUC'),\r\n    dc.metrics.Metric(dc.metrics.accuracy_score, name='Accuracy'),\r\n    dc.metrics.Metric(dc.metrics.f1_score, name='F1')\r\n]\r\n\r\nregression_metrics = [\r\n    dc.metrics.Metric(dc.metrics.r2_score, name='R²'),\r\n    dc.metrics.Metric(dc.metrics.mean_absolute_error, name='MAE'),\r\n    dc.metrics.Metric(dc.metrics.root_mean_squared_error, name='RMSE')\r\n]\r\n\r\ntrain_scores = model.evaluate(train, classification_metrics)\r\ntest_scores = model.evaluate(test, classification_metrics)\r\n```\r\n\r\n### 8. Making Predictions\r\n\r\n```python\r\npredictions = model.predict(test)\r\n\r\nnew_smiles = ['CCO', 'c1ccccc1', 'CC(C)O']\r\nnew_features = featurizer.featurize(new_smiles)\r\nnew_dataset = dc.data.NumpyDataset(X=new_features)\r\n\r\n\r\n### Workflow A: Quick Benchmark Evaluation\r\n\r\nFor evaluating a model on standard benchmarks:\r\n\r\n```python\r\nimport deepchem as dc\r\n\r\ntasks, datasets, _ = dc.molnet.load_bbbp(\r\n    featurizer='GraphConv',\r\n    splitter='scaffold'\r\n)\r\ntrain, valid, test = datasets\r\n\r\nmodel = dc.models.GCNModel(n_tasks=len(tasks), mode='classification')\r\nmodel.fit(train, nb_epoch=50)\r\n\r\nmetric = dc.metrics.Metric(dc.metrics.roc_auc_score)\r\ntest_score = model.evaluate(test, [metric])\r\nprint(f\"Test ROC-AUC: {test_score}\")\r\n```\r\n\r\n### Workflow B: Custom Data Prediction\r\n\r\nFor training on custom molecular datasets:\r\n\r\n```python\r\nimport deepchem as dc\r\n\r\nfeaturizer = dc.feat.CircularFingerprint(radius=2, size=2048)\r\nloader = dc.data.CSVLoader(\r\n    tasks=['activity'],\r\n    feature_field='smiles',\r\n    featurizer=featurizer\r\n)\r\ndataset = loader.create_dataset('my_molecules.csv')\r\n\r\nsplitter = dc.splits.ScaffoldSplitter()\r\ntrain, valid, test = splitter.train_valid_test_split(dataset)\r\n\r\ntransformers = [dc.trans.NormalizationTransformer(\r\n    transform_y=True, dataset=train\r\n)]\r\nfor transformer in transformers:\r\n    train = transformer.transform(train)\r\n    valid = transformer.transform(valid)\r\n    test = transformer.transform(test)\r\n\r\nmodel = dc.models.MultitaskRegressor(\r\n    n_tasks=1,\r\n    n_features=2048,\r\n    layer_sizes=[1000, 500],\r\n    dropouts=0.25\r\n)\r\nmodel.fit(train, nb_epoch=50)\r\n\r\nmetric = dc.metrics.Metric(dc.metrics.r2_score)\r\ntest_score = model.evaluate(test, [metric])\r\n```\r\n\r\n### Workflow C: Transfer Learning on Small Dataset\r\n\r\nFor leveraging pretrained models:\r\n\r\n```python\r\nimport deepchem as dc\r\n\r\nloader = dc.data.CSVLoader(\r\n    tasks=['activity'],\r\n    feature_field='smiles',\r\n    featurizer=dc.feat.DummyFeaturizer()  # Model handles featurization\r\n)\r\ndataset = loader.create_dataset('small_dataset.csv')\r\n\r\nsplitter = dc.splits.ScaffoldSplitter()\r\ntrain, test = splitter.train_test_split(dataset)\r\n\r\nmodel = dc.models.HuggingFaceModel(\r\n    model='seyonec/ChemBERTa-zinc-base-v1',\r\n    task='classification',\r\n    n_tasks=1,\r\n    learning_rate=2e-5\r\n)\r\n\r\nmodel.fit(train, nb_epoch=10)\r\n\r\n\r\nThis skill includes three production-ready scripts in the `scripts/` directory:\r\n\r\n### 1. `predict_solubility.py`\r\nTrain and evaluate solubility prediction models. Works with Delaney benchmark or custom CSV data.\r\n\r\n```bash\r\npython scripts/predict_solubility.py\r\n\r\npython scripts/predict_solubility.py \\\r\n    --data my_data.csv \\\r\n    --smiles-col smiles \\\r\n    --target-col solubility \\\r\n    --predict \"CCO\" \"c1ccccc1\"\r\n```\r\n\r\n### 2. `graph_neural_network.py`\r\nTrain various graph neural network architectures on molecular data.\r\n\r\n```bash\r\npython scripts/graph_neural_network.py --model gcn --dataset tox21\r\n\r\npython scripts/graph_neural_network.py \\\r\n    --model attentivefp \\\r\n    --data molecules.csv \\\r\n    --task-type regression \\\r\n    --targets activity \\\r\n    --epochs 100\r\n```\r\n\r\n### 3. `transfer_learning.py`\r\nFine-tune pretrained models (ChemBERTa, GROVER) on molecular property prediction tasks.\r\n\r\n```bash\r\npython scripts/transfer_learning.py --model chemberta --dataset bbbp\r\n\r\n\r\n### Pattern 1: Always Use Scaffold Splitting for Molecules\r\n```python\r\nsplitter = dc.splits.ScaffoldSplitter()\r\ntrain, test = splitter.train_test_split(dataset)\r\n\r\nsplitter = dc.splits.RandomSplitter()\r\ntrain, test = splitter.train_test_split(dataset)\r\n```\r\n\r\n### Pattern 2: Normalize Features and Targets\r\n```python\r\ntransformers = [\r\n    dc.trans.NormalizationTransformer(\r\n        transform_y=True,  # Also normalize target values\r\n        dataset=train\r\n    )\r\n]\r\nfor transformer in transformers:\r\n    train = transformer.transform(train)\r\n    test = transformer.transform(test)\r\n```\r\n\r\n### Pattern 3: Start Simple, Then Scale\r\n1. Start with Random Forest + CircularFingerprint (fast baseline)\r\n2. Try XGBoost/LightGBM if RF works well\r\n3. Move to deep learning (MultitaskRegressor) if you have >5K samples\r\n4. Try GNNs if you have >10K samples\r\n5. Use transfer learning for small datasets or novel scaffolds\r\n\r\n### Pattern 4: Handle Imbalanced Data\r\n```python\r\ntransformer = dc.trans.BalancingTransformer(dataset=train)\r\ntrain = transformer.transform(train)\r\n\r\nmetric = dc.metrics.Metric(dc.metrics.balanced_accuracy_score)\r\n```\r\n\r\n### Pattern 5: Avoid Memory Issues\r\n```python\r\ndataset = dc.data.DiskDataset.from_numpy(X, y, w, ids)\r\n\r\n\r\n### Issue 1: Data Leakage in Drug Discovery\r\n**Problem**: Using random splitting allows similar molecules in train/test sets.\r\n**Solution**: Always use `ScaffoldSplitter` for molecular datasets.\r\n\r\n### Issue 2: GNN Underperforming vs Fingerprints\r\n**Problem**: Graph neural networks perform worse than simple fingerprints.\r\n**Solutions**:\r\n- Ensure dataset is large enough (>10K samples typically)\r\n- Increase training epochs (50-100)\r\n- Try different architectures (AttentiveFP, DMPNN instead of GCN)\r\n- Use pretrained models (GROVER)\r\n\r\n### Issue 3: Overfitting on Small Datasets\r\n**Problem**: Model memorizes training data.\r\n**Solutions**:\r\n- Use stronger regularization (increase dropout to 0.5)\r\n- Use simpler models (Random Forest instead of deep learning)\r\n- Apply transfer learning (ChemBERTa, GROVER)\r\n- Collect more data\r\n\r\n### Issue 4: Import Errors\r\n**Problem**: Module not found errors.\r\n**Solution**: Ensure DeepChem is installed with required dependencies:\r\n```bash\r\npip install deepchem\r\npip install deepchem[torch]",
  "name": "deepchem",
  "id": "scientific-pkg-deepchem",
  "sections": {
    "Reference Documentation": "This skill includes comprehensive reference documentation:\r\n\r\n### `references/api_reference.md`\r\nComplete API documentation including:\r\n- All data loaders and their use cases\r\n- Dataset classes and when to use each\r\n- Complete featurizer catalog with selection guide\r\n- Model catalog organized by category (50+ models)\r\n- MoleculeNet dataset descriptions\r\n- Metrics and evaluation functions\r\n- Common code patterns\r\n\r\n**When to reference**: Search this file when you need specific API details, parameter names, or want to explore available options.\r\n\r\n### `references/workflows.md`\r\nEight detailed end-to-end workflows:\r\n1. Molecular property prediction from SMILES\r\n2. Using MoleculeNet benchmarks\r\n3. Hyperparameter optimization\r\n4. Transfer learning with pretrained models\r\n5. Molecular generation with GANs\r\n6. Materials property prediction\r\n7. Protein sequence analysis\r\n8. Custom model integration\r\n\r\n**When to reference**: Use these workflows as templates for implementing complete solutions.",
    "Example Scripts": "python scripts/transfer_learning.py \\\r\n    --model grover \\\r\n    --data small_dataset.csv \\\r\n    --target activity \\\r\n    --task-type classification \\\r\n    --epochs 20\r\n```",
    "Additional Resources": "- Official documentation: https://deepchem.readthedocs.io/\r\n- GitHub repository: https://github.com/deepchem/deepchem\r\n- Tutorials: https://deepchem.readthedocs.io/en/latest/get_started/tutorials.html\r\n- Paper: \"MoleculeNet: A Benchmark for Molecular Machine Learning\"",
    "Installation Notes": "Basic installation:\r\n```bash\r\npip install deepchem\r\n```\r\n\r\nFor PyTorch models (GCN, GAT, etc.):\r\n```bash\r\npip install deepchem[torch]\r\n```\r\n\r\nFor all features:\r\n```bash\r\npip install deepchem[all]\r\n```\r\n\r\nIf import errors occur, the user may need specific dependencies. Check the DeepChem documentation for detailed installation instructions.",
    "Overview": "DeepChem is a comprehensive Python library for applying machine learning to chemistry, materials science, and biology. Enable molecular property prediction, drug discovery, materials design, and biomolecule analysis through specialized neural networks, molecular featurization methods, and pretrained models.",
    "Common Patterns and Best Practices": "model = dc.models.GCNModel(batch_size=32)  # Instead of 128\r\n```",
    "Typical Workflows": "predictions = model.predict(test)\r\n```\r\n\r\nSee `references/workflows.md` for 8 detailed workflow examples covering molecular generation, materials science, protein analysis, and more.",
    "When to Use This Skill": "This skill should be used when:\r\n- Loading and processing molecular data (SMILES strings, SDF files, protein sequences)\r\n- Predicting molecular properties (solubility, toxicity, binding affinity, ADMET properties)\r\n- Training models on chemical/biological datasets\r\n- Using MoleculeNet benchmark datasets (Tox21, BBBP, Delaney, etc.)\r\n- Converting molecules to ML-ready features (fingerprints, graph representations, descriptors)\r\n- Implementing graph neural networks for molecules (GCN, GAT, MPNN, AttentiveFP)\r\n- Applying transfer learning with pretrained models (ChemBERTa, GROVER, MolFormer)\r\n- Predicting crystal/materials properties (bandgap, formation energy)\r\n- Analyzing protein or DNA sequences",
    "Core Capabilities": "for transformer in transformers:\r\n    new_dataset = transformer.transform(new_dataset)\r\n\r\npredictions = model.predict(new_dataset)\r\n```",
    "Common Pitfalls": "pip install deepchem[all]\r\n```"
  }
}