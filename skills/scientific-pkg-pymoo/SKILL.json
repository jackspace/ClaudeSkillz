{
  "description": "\"Multi-objective optimization framework. NSGA-II, NSGA-III, MOEA/D, Pareto fronts, constraint handling, benchmarks (ZDT, DTLZ), for engineering design and optimization problems.\"",
  "references": {
    "files": [
      "references/algorithms.md",
      "references/constraints_mcdm.md",
      "references/operators.md",
      "references/problems.md",
      "references/visualization.md"
    ]
  },
  "content": "### Workflow 1: Single-Objective Optimization\r\n\r\n**When:** Optimizing one objective function\r\n\r\n**Steps:**\r\n1. Define or select problem\r\n2. Choose single-objective algorithm (GA, DE, PSO, CMA-ES)\r\n3. Configure termination criteria\r\n4. Run optimization\r\n5. Extract best solution\r\n\r\n**Example:**\r\n```python\r\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\r\nfrom pymoo.problems import get_problem\r\nfrom pymoo.optimize import minimize\r\n\r\nproblem = get_problem(\"rastrigin\", n_var=10)\r\n\r\nalgorithm = GA(\r\n    pop_size=100,\r\n    eliminate_duplicates=True\r\n)\r\n\r\nresult = minimize(\r\n    problem,\r\n    algorithm,\r\n    ('n_gen', 200),\r\n    seed=1,\r\n    verbose=True\r\n)\r\n\r\nprint(f\"Best solution: {result.X}\")\r\nprint(f\"Best objective: {result.F[0]}\")\r\n```\r\n\r\n**See:** `scripts/single_objective_example.py` for complete example\r\n\r\n### Workflow 2: Multi-Objective Optimization (2-3 objectives)\r\n\r\n**When:** Optimizing 2-3 conflicting objectives, need Pareto front\r\n\r\n**Algorithm choice:** NSGA-II (standard for bi/tri-objective)\r\n\r\n**Steps:**\r\n1. Define multi-objective problem\r\n2. Configure NSGA-II\r\n3. Run optimization to obtain Pareto front\r\n4. Visualize trade-offs\r\n5. Apply decision making (optional)\r\n\r\n**Example:**\r\n```python\r\nfrom pymoo.algorithms.moo.nsga2 import NSGA2\r\nfrom pymoo.problems import get_problem\r\nfrom pymoo.optimize import minimize\r\nfrom pymoo.visualization.scatter import Scatter\r\n\r\nproblem = get_problem(\"zdt1\")\r\n\r\nalgorithm = NSGA2(pop_size=100)\r\n\r\nresult = minimize(problem, algorithm, ('n_gen', 200), seed=1)\r\n\r\nplot = Scatter()\r\nplot.add(result.F, label=\"Obtained Front\")\r\nplot.add(problem.pareto_front(), label=\"True Front\", alpha=0.3)\r\nplot.show()\r\n\r\nprint(f\"Found {len(result.F)} Pareto-optimal solutions\")\r\n```\r\n\r\n**See:** `scripts/multi_objective_example.py` for complete example\r\n\r\n### Workflow 3: Many-Objective Optimization (4+ objectives)\r\n\r\n**When:** Optimizing 4 or more objectives\r\n\r\n**Algorithm choice:** NSGA-III (designed for many objectives)\r\n\r\n**Key difference:** Must provide reference directions for population guidance\r\n\r\n**Steps:**\r\n1. Define many-objective problem\r\n2. Generate reference directions\r\n3. Configure NSGA-III with reference directions\r\n4. Run optimization\r\n5. Visualize using Parallel Coordinate Plot\r\n\r\n**Example:**\r\n```python\r\nfrom pymoo.algorithms.moo.nsga3 import NSGA3\r\nfrom pymoo.problems import get_problem\r\nfrom pymoo.optimize import minimize\r\nfrom pymoo.util.ref_dirs import get_reference_directions\r\nfrom pymoo.visualization.pcp import PCP\r\n\r\nproblem = get_problem(\"dtlz2\", n_obj=5)\r\n\r\nref_dirs = get_reference_directions(\"das-dennis\", n_dim=5, n_partitions=12)\r\n\r\nalgorithm = NSGA3(ref_dirs=ref_dirs)\r\n\r\nresult = minimize(problem, algorithm, ('n_gen', 300), seed=1)\r\n\r\nplot = PCP(labels=[f\"f{i+1}\" for i in range(5)])\r\nplot.add(result.F, alpha=0.3)\r\nplot.show()\r\n```\r\n\r\n**See:** `scripts/many_objective_example.py` for complete example\r\n\r\n### Workflow 4: Custom Problem Definition\r\n\r\n**When:** Solving domain-specific optimization problem\r\n\r\n**Steps:**\r\n1. Extend `ElementwiseProblem` class\r\n2. Define `__init__` with problem dimensions and bounds\r\n3. Implement `_evaluate` method for objectives (and constraints)\r\n4. Use with any algorithm\r\n\r\n**Unconstrained example:**\r\n```python\r\nfrom pymoo.core.problem import ElementwiseProblem\r\nimport numpy as np\r\n\r\nclass MyProblem(ElementwiseProblem):\r\n    def __init__(self):\r\n        super().__init__(\r\n            n_var=2,              # Number of variables\r\n            n_obj=2,              # Number of objectives\r\n            xl=np.array([0, 0]),  # Lower bounds\r\n            xu=np.array([5, 5])   # Upper bounds\r\n        )\r\n\r\n    def _evaluate(self, x, out, *args, **kwargs):\r\n        # Define objectives\r\n        f1 = x[0]**2 + x[1]**2\r\n        f2 = (x[0]-1)**2 + (x[1]-1)**2\r\n\r\n        out[\"F\"] = [f1, f2]\r\n```\r\n\r\n**Constrained example:**\r\n```python\r\nclass ConstrainedProblem(ElementwiseProblem):\r\n    def __init__(self):\r\n        super().__init__(\r\n            n_var=2,\r\n            n_obj=2,\r\n            n_ieq_constr=2,        # Inequality constraints\r\n            n_eq_constr=1,         # Equality constraints\r\n            xl=np.array([0, 0]),\r\n            xu=np.array([5, 5])\r\n        )\r\n\r\n    def _evaluate(self, x, out, *args, **kwargs):\r\n        # Objectives\r\n        out[\"F\"] = [f1, f2]\r\n\r\n        # Inequality constraints (g <= 0)\r\n        out[\"G\"] = [g1, g2]\r\n\r\n        # Equality constraints (h = 0)\r\n        out[\"H\"] = [h1]\r\n```\r\n\r\n**Constraint formulation rules:**\r\n- Inequality: Express as `g(x) <= 0` (feasible when ≤ 0)\r\n- Equality: Express as `h(x) = 0` (feasible when = 0)\r\n- Convert `g(x) >= b` to `-(g(x) - b) <= 0`\r\n\r\n**See:** `scripts/custom_problem_example.py` for complete examples\r\n\r\n### Workflow 5: Constraint Handling\r\n\r\n**When:** Problem has feasibility constraints\r\n\r\n**Approach options:**\r\n\r\n**1. Feasibility First (Default - Recommended)**\r\n```python\r\nfrom pymoo.algorithms.moo.nsga2 import NSGA2\r\n\r\nalgorithm = NSGA2(pop_size=100)\r\nresult = minimize(problem, algorithm, termination)\r\n\r\nfeasible = result.CV[:, 0] == 0  # CV = constraint violation\r\nprint(f\"Feasible solutions: {np.sum(feasible)}\")\r\n```\r\n\r\n**2. Penalty Method**\r\n```python\r\nfrom pymoo.constraints.as_penalty import ConstraintsAsPenalty\r\n\r\nproblem_penalized = ConstraintsAsPenalty(problem, penalty=1e6)\r\n```\r\n\r\n**3. Constraint as Objective**\r\n```python\r\nfrom pymoo.constraints.as_obj import ConstraintsAsObjective\r\n\r\nproblem_with_cv = ConstraintsAsObjective(problem)\r\n```\r\n\r\n**4. Specialized Algorithms**\r\n```python\r\nfrom pymoo.algorithms.soo.nonconvex.sres import SRES\r\n\r\nalgorithm = SRES()\r\n```\r\n\r\n**See:** `references/constraints_mcdm.md` for comprehensive constraint handling guide\r\n\r\n### Workflow 6: Decision Making from Pareto Front\r\n\r\n**When:** Have Pareto front, need to select preferred solution(s)\r\n\r\n**Steps:**\r\n1. Run multi-objective optimization\r\n2. Normalize objectives to [0, 1]\r\n3. Define preference weights\r\n4. Apply MCDM method\r\n5. Visualize selected solution\r\n\r\n**Example using Pseudo-Weights:**\r\n```python\r\nfrom pymoo.mcdm.pseudo_weights import PseudoWeights\r\nimport numpy as np\r\n\r\nF_norm = (result.F - result.F.min(axis=0)) / (result.F.max(axis=0) - result.F.min(axis=0))\r\n\r\nweights = np.array([0.3, 0.7])  # 30% f1, 70% f2\r\n\r\ndm = PseudoWeights(weights)\r\nselected_idx = dm.do(F_norm)\r\n\r\n\r\n### Quick problem access:\r\n```python\r\nfrom pymoo.problems import get_problem\r\n\r\nproblem = get_problem(\"rastrigin\", n_var=10)\r\nproblem = get_problem(\"rosenbrock\", n_var=10)\r\n\r\nproblem = get_problem(\"zdt1\")        # Convex front\r\nproblem = get_problem(\"zdt2\")        # Non-convex front\r\nproblem = get_problem(\"zdt3\")        # Disconnected front",
  "name": "pymoo",
  "id": "scientific-pkg-pymoo",
  "sections": {
    "Additional Notes": "**Installation:**\r\n```bash\r\npip install pymoo\r\n```\r\n\r\n**Dependencies:** NumPy, SciPy, matplotlib, autograd (optional for gradient-based)\r\n\r\n**Documentation:** https://pymoo.org/\r\n\r\n**Version:** This skill is based on pymoo 0.6.x\r\n\r\n**Common patterns:**\r\n- Always use `ElementwiseProblem` for custom problems\r\n- Constraints formulated as `g(x) <= 0` and `h(x) = 0`\r\n- Reference directions required for NSGA-III\r\n- Normalize objectives before MCDM\r\n- Use appropriate termination: `('n_gen', N)` or `get_termination(\"f_tol\", tol=0.001)`",
    "Genetic Operator Customization": "### Standard operator configuration:\r\n```python\r\nfrom pymoo.algorithms.soo.nonconvex.ga import GA\r\nfrom pymoo.operators.crossover.sbx import SBX\r\nfrom pymoo.operators.mutation.pm import PM\r\n\r\nalgorithm = GA(\r\n    pop_size=100,\r\n    crossover=SBX(prob=0.9, eta=15),\r\n    mutation=PM(eta=20),\r\n    eliminate_duplicates=True\r\n)\r\n```\r\n\r\n### Operator selection by variable type:\r\n\r\n**Continuous variables:**\r\n- Crossover: SBX (Simulated Binary Crossover)\r\n- Mutation: PM (Polynomial Mutation)\r\n\r\n**Binary variables:**\r\n- Crossover: TwoPointCrossover, UniformCrossover\r\n- Mutation: BitflipMutation\r\n\r\n**Permutations (TSP, scheduling):**\r\n- Crossover: OrderCrossover (OX)\r\n- Mutation: InversionMutation\r\n\r\n**See:** `references/operators.md` for comprehensive operator reference",
    "Performance and Troubleshooting": "### Common issues and solutions:\r\n\r\n**Problem: Algorithm not converging**\r\n- Increase population size\r\n- Increase number of generations\r\n- Check if problem is multimodal (try different algorithms)\r\n- Verify constraints are correctly formulated\r\n\r\n**Problem: Poor Pareto front distribution**\r\n- For NSGA-III: Adjust reference directions\r\n- Increase population size\r\n- Check for duplicate elimination\r\n- Verify problem scaling\r\n\r\n**Problem: Few feasible solutions**\r\n- Use constraint-as-objective approach\r\n- Apply repair operators\r\n- Try SRES/ISRES for constrained problems\r\n- Check constraint formulation (should be g <= 0)\r\n\r\n**Problem: High computational cost**\r\n- Reduce population size\r\n- Decrease number of generations\r\n- Use simpler operators\r\n- Enable parallelization (if problem supports)\r\n\r\n### Best practices:\r\n\r\n1. **Normalize objectives** when scales differ significantly\r\n2. **Set random seed** for reproducibility\r\n3. **Save history** to analyze convergence: `save_history=True`\r\n4. **Visualize results** to understand solution quality\r\n5. **Compare with true Pareto front** when available\r\n6. **Use appropriate termination criteria** (generations, evaluations, tolerance)\r\n7. **Tune operator parameters** for problem characteristics",
    "Benchmark Problems": "problem = get_problem(\"dtlz2\", n_obj=5, n_var=12)\r\nproblem = get_problem(\"dtlz7\", n_obj=4)\r\n```\r\n\r\n**See:** `references/problems.md` for complete test problem reference",
    "Overview": "Pymoo is a comprehensive Python framework for optimization with emphasis on multi-objective problems. Solve single and multi-objective optimization using state-of-the-art algorithms (NSGA-II/III, MOEA/D), benchmark problems (ZDT, DTLZ), customizable genetic operators, and multi-criteria decision making methods. Excels at finding trade-off solutions (Pareto fronts) for problems with conflicting objectives.",
    "When to Use This Skill": "This skill should be used when:\r\n- Solving optimization problems with one or multiple objectives\r\n- Finding Pareto-optimal solutions and analyzing trade-offs\r\n- Implementing evolutionary algorithms (GA, DE, PSO, NSGA-II/III)\r\n- Working with constrained optimization problems\r\n- Benchmarking algorithms on standard test problems (ZDT, DTLZ, WFG)\r\n- Customizing genetic operators (crossover, mutation, selection)\r\n- Visualizing high-dimensional optimization results\r\n- Making decisions from multiple competing solutions\r\n- Handling binary, discrete, continuous, or mixed-variable problems",
    "Resources": "This skill includes comprehensive reference documentation and executable examples:\r\n\r\n### references/\r\nDetailed documentation for in-depth understanding:\r\n\r\n- **algorithms.md**: Complete algorithm reference with parameters, usage, and selection guidelines\r\n- **problems.md**: Benchmark test problems (ZDT, DTLZ, WFG) with characteristics\r\n- **operators.md**: Genetic operators (sampling, selection, crossover, mutation) with configuration\r\n- **visualization.md**: All visualization types with examples and selection guide\r\n- **constraints_mcdm.md**: Constraint handling techniques and multi-criteria decision making methods\r\n\r\n**Search patterns for references:**\r\n- Algorithm details: `grep -r \"NSGA-II\\|NSGA-III\\|MOEA/D\" references/`\r\n- Constraint methods: `grep -r \"Feasibility First\\|Penalty\\|Repair\" references/`\r\n- Visualization types: `grep -r \"Scatter\\|PCP\\|Petal\" references/`\r\n\r\n### scripts/\r\nExecutable examples demonstrating common workflows:\r\n\r\n- **single_objective_example.py**: Basic single-objective optimization with GA\r\n- **multi_objective_example.py**: Multi-objective optimization with NSGA-II, visualization\r\n- **many_objective_example.py**: Many-objective optimization with NSGA-III, reference directions\r\n- **custom_problem_example.py**: Defining custom problems (constrained and unconstrained)\r\n- **decision_making_example.py**: Multi-criteria decision making with different preferences\r\n\r\n**Run examples:**\r\n```bash\r\npython3 scripts/single_objective_example.py\r\npython3 scripts/multi_objective_example.py\r\npython3 scripts/many_objective_example.py\r\npython3 scripts/custom_problem_example.py\r\npython3 scripts/decision_making_example.py\r\n```",
    "Algorithm Selection Guide": "### Single-Objective Problems\r\n\r\n| Algorithm | Best For | Key Features |\r\n|-----------|----------|--------------|\r\n| **GA** | General-purpose | Flexible, customizable operators |\r\n| **DE** | Continuous optimization | Good global search |\r\n| **PSO** | Smooth landscapes | Fast convergence |\r\n| **CMA-ES** | Difficult/noisy problems | Self-adapting |\r\n\r\n### Multi-Objective Problems (2-3 objectives)\r\n\r\n| Algorithm | Best For | Key Features |\r\n|-----------|----------|--------------|\r\n| **NSGA-II** | Standard benchmark | Fast, reliable, well-tested |\r\n| **R-NSGA-II** | Preference regions | Reference point guidance |\r\n| **MOEA/D** | Decomposable problems | Scalarization approach |\r\n\r\n### Many-Objective Problems (4+ objectives)\r\n\r\n| Algorithm | Best For | Key Features |\r\n|-----------|----------|--------------|\r\n| **NSGA-III** | 4-15 objectives | Reference direction-based |\r\n| **RVEA** | Adaptive search | Reference vector evolution |\r\n| **AGE-MOEA** | Complex landscapes | Adaptive geometry |\r\n\r\n### Constrained Problems\r\n\r\n| Approach | Algorithm | When to Use |\r\n|----------|-----------|-------------|\r\n| Feasibility-first | Any algorithm | Large feasible region |\r\n| Specialized | SRES, ISRES | Heavy constraints |\r\n| Penalty | GA + penalty | Algorithm compatibility |\r\n\r\n**See:** `references/algorithms.md` for comprehensive algorithm reference",
    "Core Concepts": "### The Unified Interface\r\n\r\nPymoo uses a consistent `minimize()` function for all optimization tasks:\r\n\r\n```python\r\nfrom pymoo.optimize import minimize\r\n\r\nresult = minimize(\r\n    problem,        # What to optimize\r\n    algorithm,      # How to optimize\r\n    termination,    # When to stop\r\n    seed=1,\r\n    verbose=True\r\n)\r\n```\r\n\r\n**Result object contains:**\r\n- `result.X`: Decision variables of optimal solution(s)\r\n- `result.F`: Objective values of optimal solution(s)\r\n- `result.G`: Constraint violations (if constrained)\r\n- `result.algorithm`: Algorithm object with history\r\n\r\n### Problem Types\r\n\r\n**Single-objective:** One objective to minimize/maximize\r\n**Multi-objective:** 2-3 conflicting objectives → Pareto front\r\n**Many-objective:** 4+ objectives → High-dimensional Pareto front\r\n**Constrained:** Objectives + inequality/equality constraints\r\n**Dynamic:** Time-varying objectives or constraints",
    "Quick Start Workflows": "best_solution = result.X[selected_idx]\r\nbest_objectives = result.F[selected_idx]\r\n\r\nprint(f\"Selected solution: {best_solution}\")\r\nprint(f\"Objective values: {best_objectives}\")\r\n```\r\n\r\n**Other MCDM methods:**\r\n- Compromise Programming: Select closest to ideal point\r\n- Knee Point: Find balanced trade-off solutions\r\n- Hypervolume Contribution: Select most diverse subset\r\n\r\n**See:**\r\n- `scripts/decision_making_example.py` for complete example\r\n- `references/constraints_mcdm.md` for detailed MCDM methods\r\n\r\n### Workflow 7: Visualization\r\n\r\n**Choose visualization based on number of objectives:**\r\n\r\n**2 objectives: Scatter Plot**\r\n```python\r\nfrom pymoo.visualization.scatter import Scatter\r\n\r\nplot = Scatter(title=\"Bi-objective Results\")\r\nplot.add(result.F, color=\"blue\", alpha=0.7)\r\nplot.show()\r\n```\r\n\r\n**3 objectives: 3D Scatter**\r\n```python\r\nplot = Scatter(title=\"Tri-objective Results\")\r\nplot.add(result.F)  # Automatically renders in 3D\r\nplot.show()\r\n```\r\n\r\n**4+ objectives: Parallel Coordinate Plot**\r\n```python\r\nfrom pymoo.visualization.pcp import PCP\r\n\r\nplot = PCP(\r\n    labels=[f\"f{i+1}\" for i in range(n_obj)],\r\n    normalize_each_axis=True\r\n)\r\nplot.add(result.F, alpha=0.3)\r\nplot.show()\r\n```\r\n\r\n**Solution comparison: Petal Diagram**\r\n```python\r\nfrom pymoo.visualization.petal import Petal\r\n\r\nplot = Petal(\r\n    bounds=[result.F.min(axis=0), result.F.max(axis=0)],\r\n    labels=[\"Cost\", \"Weight\", \"Efficiency\"]\r\n)\r\nplot.add(solution_A, label=\"Design A\")\r\nplot.add(solution_B, label=\"Design B\")\r\nplot.show()\r\n```\r\n\r\n**See:** `references/visualization.md` for all visualization types and usage"
  }
}