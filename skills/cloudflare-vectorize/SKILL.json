{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/embedding-models.md",
      "references/index-operations.md",
      "references/integration-openai-embeddings.md",
      "references/integration-workers-ai-bge-base.md",
      "references/metadata-guide.md",
      "references/vector-operations.md",
      "references/wrangler-commands.md"
    ]
  },
  "content": "Complete implementation guide for Cloudflare Vectorize - a globally distributed vector database for building semantic search, RAG (Retrieval Augmented Generation), and AI-powered applications with Cloudflare Workers.\r\n\r\n**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-21\r\n**Dependencies**: cloudflare-worker-base (for Worker setup), cloudflare-workers-ai (for embeddings)\r\n**Latest Versions**: wrangler@4.43.0, @cloudflare/workers-types@4.20251014.0\r\n**Token Savings**: ~65%\r\n**Errors Prevented**: 8\r\n**Dev Time Saved**: ~3 hours\r\n\r\n\r\n### ⚠️ MUST DO BEFORE INSERTING VECTORS\r\n```bash\r\nnpx wrangler vectorize create my-index \\\r\n  --dimensions=768 \\\r\n  --metric=cosine\r\n\r\nnpx wrangler vectorize create-metadata-index my-index \\\r\n  --property-name=category \\\r\n  --type=string\r\n\r\nnpx wrangler vectorize create-metadata-index my-index \\\r\n  --property-name=timestamp \\\r\n  --type=number\r\n```\r\n\r\n**Why**: Metadata indexes MUST exist before vectors are inserted. Vectors added before a metadata index was created won't be filterable on that property.\r\n\r\n### Index Configuration (Cannot Be Changed Later)\r\n\r\n```bash\r\n\r\n\r\n```bash\r\nnpx wrangler vectorize create <name> \\\r\n  --dimensions=768 \\\r\n  --metric=cosine\r\n\r\nnpx wrangler vectorize list\r\n\r\nnpx wrangler vectorize get <name>\r\n\r\nnpx wrangler vectorize info <name>\r\n\r\nnpx wrangler vectorize delete <name>\r\n\r\nnpx wrangler vectorize create-metadata-index <name> \\\r\n  --property-name=category \\\r\n  --type=string\r\n\r\nnpx wrangler vectorize list-metadata-index <name>\r\n\r\nnpx wrangler vectorize delete-metadata-index <name> \\\r\n  --property-name=category\r\n\r\nnpx wrangler vectorize insert <name> \\\r\n  --file=vectors.ndjson\r\n\r\nnpx wrangler vectorize query <name> \\\r\n  --vector=\"[0.1, 0.2, ...]\" \\\r\n  --top-k=5 \\\r\n  --return-metadata=all\r\n\r\nnpx wrangler vectorize list-vectors <name> \\\r\n  --count=100\r\n\r\nnpx wrangler vectorize get-vectors <name> \\\r\n  --ids=\"id1,id2,id3\"",
  "name": "cloudflare-vectorize",
  "id": "cloudflare-vectorize",
  "sections": {
    "Metadata Best Practices": "### 1. Cardinality Considerations\r\n\r\n**Low Cardinality (Good for $eq filters)**:\r\n```typescript\r\n// Few unique values - efficient filtering\r\nmetadata: {\r\n  category: \"docs\",        // ~10 categories\r\n  language: \"en\",          // ~5 languages\r\n  published: true          // 2 values (boolean)\r\n}\r\n```\r\n\r\n**High Cardinality (Avoid in range queries)**:\r\n```typescript\r\n// Many unique values - avoid large range scans\r\nmetadata: {\r\n  user_id: \"uuid-v4...\",         // Millions of unique values\r\n  timestamp_ms: 1704067200123    // Use seconds instead\r\n}\r\n```\r\n\r\n### 2. Metadata Limits\r\n\r\n- **Max 10 metadata indexes** per Vectorize index\r\n- **Max 10 KiB metadata** per vector\r\n- **String indexes**: First 64 bytes (UTF-8)\r\n- **Number indexes**: Float64 precision\r\n- **Filter size**: Max 2048 bytes (compact JSON)\r\n\r\n### 3. Key Restrictions\r\n\r\n```typescript\r\n// ❌ INVALID metadata keys\r\nmetadata: {\r\n  \"\": \"value\",              // Empty key\r\n  \"user.name\": \"John\",      // Contains dot (reserved for nesting)\r\n  \"$admin\": true,           // Starts with $\r\n  \"key\\\"with\\\"quotes\": 1    // Contains quotes\r\n}\r\n\r\n// ✅ VALID metadata keys\r\nmetadata: {\r\n  \"user_name\": \"John\",\r\n  \"isAdmin\": true,\r\n  \"nested\": { \"allowed\": true }  // Access as \"nested.allowed\" in filters\r\n}\r\n```",
    "RAG Pattern (Full Example)": "```typescript\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { question } = await request.json();\r\n\r\n    // 1. Generate embedding for user question\r\n    const questionEmbedding = await env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n      text: question\r\n    });\r\n\r\n    // 2. Search vector database for similar content\r\n    const results = await env.VECTORIZE_INDEX.query(\r\n      questionEmbedding.data[0],\r\n      {\r\n        topK: 3,\r\n        returnMetadata: 'all',\r\n        filter: { type: \"documentation\" }\r\n      }\r\n    );\r\n\r\n    // 3. Build context from retrieved documents\r\n    const context = results.matches\r\n      .map(m => m.metadata.content)\r\n      .join('\\n\\n---\\n\\n');\r\n\r\n    // 4. Generate answer with LLM using context\r\n    const answer = await env.AI.run('@cf/meta/llama-3-8b-instruct', {\r\n      messages: [\r\n        {\r\n          role: \"system\",\r\n          content: `Answer based on this context:\\n\\n${context}`\r\n        },\r\n        {\r\n          role: \"user\",\r\n          content: question\r\n        }\r\n      ]\r\n    });\r\n\r\n    return Response.json({\r\n      answer: answer.response,\r\n      sources: results.matches.map(m => m.metadata.title)\r\n    });\r\n  }\r\n};\r\n```",
    "Document Chunking Strategy": "```typescript\r\nfunction chunkText(text: string, maxChunkSize = 500): string[] {\r\n  const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];\r\n  const chunks: string[] = [];\r\n  let currentChunk = '';\r\n\r\n  for (const sentence of sentences) {\r\n    if ((currentChunk + sentence).length > maxChunkSize && currentChunk) {\r\n      chunks.push(currentChunk.trim());\r\n      currentChunk = sentence;\r\n    } else {\r\n      currentChunk += sentence;\r\n    }\r\n  }\r\n\r\n  if (currentChunk) chunks.push(currentChunk.trim());\r\n  return chunks;\r\n}\r\n\r\n// Usage\r\nconst chunks = chunkText(longDocument, 500);\r\nconst embeddings = await env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n  text: chunks\r\n});\r\n\r\nconst vectors = embeddings.data.map((values, i) => ({\r\n  id: `doc-${docId}-chunk-${i}`,\r\n  values,\r\n  metadata: {\r\n    doc_id: docId,\r\n    chunk_index: i,\r\n    total_chunks: chunks.length,\r\n    content: chunks[i]\r\n  }\r\n}));\r\n\r\nawait env.VECTORIZE_INDEX.upsert(vectors);\r\n```",
    "Reference Documentation": "Detailed guides in `./references/`:\r\n- `wrangler-commands.md` - Complete CLI reference\r\n- `index-operations.md` - Index creation and management\r\n- `vector-operations.md` - Insert, query, delete operations\r\n- `metadata-guide.md` - Metadata indexes and filtering\r\n- `embedding-models.md` - Model configurations",
    "What This Skill Provides": "### Core Capabilities\r\n- ✅ **Index Management**: Create, configure, and manage vector indexes\r\n- ✅ **Vector Operations**: Insert, upsert, query, delete, and list vectors\r\n- ✅ **Metadata Filtering**: Advanced filtering with 10 metadata indexes per index\r\n- ✅ **Semantic Search**: Find similar vectors using cosine, euclidean, or dot-product metrics\r\n- ✅ **RAG Patterns**: Complete retrieval-augmented generation workflows\r\n- ✅ **Workers AI Integration**: Native embedding generation with @cf/baai/bge-base-en-v1.5\r\n- ✅ **OpenAI Integration**: Support for text-embedding-3-small/large models\r\n- ✅ **Document Processing**: Text chunking and batch ingestion pipelines\r\n\r\n### Templates Included\r\n1. **basic-search.ts** - Simple vector search with Workers AI\r\n2. **rag-chat.ts** - Full RAG chatbot with context retrieval\r\n3. **document-ingestion.ts** - Document chunking and embedding pipeline\r\n4. **metadata-filtering.ts** - Advanced filtering examples",
    "TypeScript Types": "```typescript\r\nexport interface Env {\r\n  VECTORIZE_INDEX: VectorizeIndex;\r\n  AI: Ai;\r\n}\r\n\r\ninterface VectorizeVector {\r\n  id: string;\r\n  values: number[] | Float32Array | Float64Array;\r\n  namespace?: string;\r\n  metadata?: Record<string, string | number | boolean | string[]>;\r\n}\r\n\r\ninterface VectorizeMatches {\r\n  matches: Array<{\r\n    id: string;\r\n    score: number;\r\n    values?: number[];\r\n    metadata?: Record<string, any>;\r\n    namespace?: string;\r\n  }>;\r\n  count: number;\r\n}\r\n```",
    "When to Use This Skill": "✅ **Use Vectorize when**:\r\n- Building semantic search over documents, products, or content\r\n- Implementing RAG chatbots with context retrieval\r\n- Creating recommendation engines based on similarity\r\n- Building multi-tenant applications (use namespaces)\r\n- Need global distribution and low latency\r\n\r\n❌ **Don't use Vectorize for**:\r\n- Traditional relational data (use D1)\r\n- Key-value lookups (use KV)\r\n- Large file storage (use R2)\r\n- Real-time collaborative state (use Durable Objects)",
    "Critical Setup Rules": "```",
    "Integration Examples": "Complete integration guides in `./references/`:\r\n- `integration-workers-ai-bge-base.md` - Workers AI integration (@cf/baai/bge-base-en-v1.5)\r\n- `integration-openai-embeddings.md` - OpenAI embeddings integration",
    "Templates Location": "All working code examples are in `./templates/`:\r\n- `basic-search.ts` - Simple vector search implementation\r\n- `rag-chat.ts` - Complete RAG chatbot\r\n- `document-ingestion.ts` - Document processing pipeline\r\n- `metadata-filtering.ts` - Advanced filtering patterns",
    "Performance Tips": "1. **Batch Operations**: Insert/upsert in batches of 100-1000 vectors\r\n2. **Selective Return**: Only use `returnValues: true` when needed (saves bandwidth)\r\n3. **Metadata Cardinality**: Keep indexed metadata fields low cardinality for range queries\r\n4. **Namespace Filtering**: Apply namespace filter before metadata filters (processed first)\r\n5. **Query Optimization**: Use topK=3-10 for best latency (larger values increase search time)",
    "Official Documentation": "- [Vectorize Docs](https://developers.cloudflare.com/vectorize/)\r\n- [Workers AI Models](https://developers.cloudflare.com/workers-ai/models/)\r\n- [RAG Tutorial](https://developers.cloudflare.com/workers-ai/guides/tutorials/build-a-retrieval-augmented-generation-ai/)\r\n\r\n---\r\n\r\n**Version**: 1.0.0\r\n**Status**: Production Ready ✅\r\n**Token Savings**: ~65%\r\n**Errors Prevented**: 8 major categories\r\n**Dev Time Saved**: ~2.5 hours per implementation",
    "Common Errors & Solutions": "### Error 1: Metadata Index Created After Vectors Inserted\r\n```\r\nProblem: Filtering doesn't work on existing vectors\r\nSolution: Delete and re-insert vectors OR create metadata indexes BEFORE inserting\r\n```\r\n\r\n### Error 2: Dimension Mismatch\r\n```\r\nProblem: \"Vector dimensions do not match index configuration\"\r\nSolution: Ensure embedding model output matches index dimensions:\r\n  - Workers AI bge-base: 768\r\n  - OpenAI small: 1536\r\n  - OpenAI large: 3072\r\n```\r\n\r\n### Error 3: Invalid Metadata Keys\r\n```\r\nProblem: \"Invalid metadata key\"\r\nSolution: Keys cannot:\r\n  - Be empty\r\n  - Contain . (dot)\r\n  - Contain \" (quote)\r\n  - Start with $ (dollar sign)\r\n```\r\n\r\n### Error 4: Filter Too Large\r\n```\r\nProblem: \"Filter exceeds 2048 bytes\"\r\nSolution: Simplify filter or split into multiple queries\r\n```\r\n\r\n### Error 5: Range Query on High Cardinality\r\n```\r\nProblem: Slow queries or reduced accuracy\r\nSolution: Use lower cardinality fields for range queries, or use seconds instead of milliseconds for timestamps\r\n```\r\n\r\n### Error 6: Insert vs Upsert Confusion\r\n```\r\nProblem: Updates not reflecting in index\r\nSolution: Use upsert() to overwrite existing vectors, not insert()\r\n```\r\n\r\n### Error 7: Missing Bindings\r\n```\r\nProblem: \"VECTORIZE_INDEX is not defined\"\r\nSolution: Add [[vectorize]] binding to wrangler.jsonc\r\n```\r\n\r\n### Error 8: Namespace vs Metadata Confusion\r\n```\r\nProblem: Unclear when to use namespace vs metadata filtering\r\nSolution:\r\n  - Namespace: Partition key, applied BEFORE metadata filters\r\n  - Metadata: Flexible key-value filtering within namespace\r\n```",
    "Embedding Generation": "### Workers AI (Recommended - Free)\r\n\r\n```typescript\r\nconst embeddings = await env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n  text: [\"Document 1 content\", \"Document 2 content\"]\r\n});\r\n\r\n// embeddings.data is number[][] (array of 768-dim vectors)\r\nconst vectors = embeddings.data.map((values, i) => ({\r\n  id: `doc-${i}`,\r\n  values,\r\n  metadata: { source: 'batch-import' }\r\n}));\r\n\r\nawait env.VECTORIZE_INDEX.upsert(vectors);\r\n```\r\n\r\n### OpenAI Embeddings\r\n\r\n```typescript\r\nimport OpenAI from 'openai';\r\n\r\nconst openai = new OpenAI({ apiKey: env.OPENAI_API_KEY });\r\n\r\nconst response = await openai.embeddings.create({\r\n  model: \"text-embedding-3-small\",  // 1536 dimensions\r\n  input: \"Text to embed\"\r\n});\r\n\r\nawait env.VECTORIZE_INDEX.upsert([{\r\n  id: \"doc-1\",\r\n  values: response.data[0].embedding,\r\n  metadata: { model: \"openai-3-small\" }\r\n}]);\r\n```",
    "Wrangler CLI Reference": "npx wrangler vectorize delete-vectors <name> \\\r\n  --ids=\"id1,id2,id3\"\r\n```",
    "Common Operations": "### 1. Insert vs Upsert\r\n\r\n```typescript\r\n// INSERT: Keeps first insertion if ID exists\r\nawait env.VECTORIZE_INDEX.insert([\r\n  {\r\n    id: \"doc-1\",\r\n    values: [0.1, 0.2, 0.3, ...],\r\n    metadata: { title: \"First version\" }\r\n  }\r\n]);\r\n\r\n// UPSERT: Overwrites with latest if ID exists (use this for updates)\r\nawait env.VECTORIZE_INDEX.upsert([\r\n  {\r\n    id: \"doc-1\",\r\n    values: [0.1, 0.2, 0.3, ...],\r\n    metadata: { title: \"Updated version\" }\r\n  }\r\n]);\r\n```\r\n\r\n### 2. Query with Filters\r\n\r\n```typescript\r\n// Generate embedding for query\r\nconst queryEmbedding = await env.AI.run('@cf/baai/bge-base-en-v1.5', {\r\n  text: \"What is Cloudflare Workers?\"\r\n});\r\n\r\n// Search with metadata filtering\r\nconst results = await env.VECTORIZE_INDEX.query(\r\n  queryEmbedding.data[0],\r\n  {\r\n    topK: 5,\r\n    filter: {\r\n      category: \"documentation\",\r\n      timestamp: { $gte: 1704067200 }  // After Jan 1, 2024\r\n    },\r\n    returnMetadata: 'all',\r\n    returnValues: false,\r\n    namespace: 'prod'\r\n  }\r\n);\r\n```\r\n\r\n### 3. Metadata Filter Operators\r\n\r\n```typescript\r\n// Equality (implicit $eq)\r\n{ category: \"docs\" }\r\n\r\n// Explicit operators\r\n{ status: { $ne: \"archived\" } }\r\n\r\n// In array\r\n{ category: { $in: [\"docs\", \"tutorials\", \"guides\"] } }\r\n\r\n// Not in array\r\n{ category: { $nin: [\"deprecated\", \"draft\"] } }\r\n\r\n// Range queries (numbers)\r\n{\r\n  timestamp: {\r\n    $gte: 1704067200,  // >= Jan 1, 2024\r\n    $lt: 1735689600    // < Jan 1, 2025\r\n  }\r\n}\r\n\r\n// Range queries (strings) - prefix searching\r\n{\r\n  url: {\r\n    $gte: \"/docs/workers\",\r\n    $lt: \"/docs/workersz\"  // Matches all /docs/workers/*\r\n  }\r\n}\r\n\r\n// Nested metadata with dot notation\r\n{ \"author.id\": \"user123\" }\r\n\r\n// Multiple conditions (implicit AND)\r\n{\r\n  category: \"docs\",\r\n  language: \"en\",\r\n  \"metadata.published\": true\r\n}\r\n```\r\n\r\n### 4. Namespace Filtering\r\n\r\n```typescript\r\n// Insert with namespace (partition key)\r\nawait env.VECTORIZE_INDEX.upsert([\r\n  {\r\n    id: \"1\",\r\n    values: embedding,\r\n    namespace: \"customer-123\",\r\n    metadata: { type: \"support_ticket\" }\r\n  }\r\n]);\r\n\r\n// Query only within namespace\r\nconst results = await env.VECTORIZE_INDEX.query(queryVector, {\r\n  topK: 5,\r\n  namespace: \"customer-123\"  // Only search this customer's data\r\n});\r\n```\r\n\r\n### 5. List and Delete Vectors\r\n\r\n```typescript\r\n// List vector IDs (paginated)\r\nconst vectors = await env.VECTORIZE_INDEX.listVectors({\r\n  cursor: null,\r\n  limit: 100\r\n});\r\n\r\n// Get specific vectors by ID\r\nconst retrieved = await env.VECTORIZE_INDEX.getByIds([\r\n  \"doc-1\", \"doc-2\", \"doc-3\"\r\n]);\r\n\r\n// Delete vectors\r\nawait env.VECTORIZE_INDEX.deleteByIds([\r\n  \"doc-1\", \"doc-2\"\r\n]);\r\n```",
    "Wrangler Configuration": "**wrangler.jsonc**:\r\n```jsonc\r\n{\r\n  \"name\": \"my-vectorize-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-21\",\r\n  \"vectorize\": [\r\n    {\r\n      \"binding\": \"VECTORIZE_INDEX\",\r\n      \"index_name\": \"my-index\"\r\n    }\r\n  ],\r\n  \"ai\": {\r\n    \"binding\": \"AI\"\r\n  }\r\n}\r\n```"
  }
}