{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/alarms-api.md",
      "references/best-practices.md",
      "references/migrations-guide.md",
      "references/rpc-patterns.md",
      "references/state-api-reference.md",
      "references/top-errors.md",
      "references/websocket-hibernation.md",
      "references/wrangler-commands.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-22\r\n**Dependencies**: cloudflare-worker-base (recommended)\r\n**Latest Versions**: wrangler@4.43.0+, @cloudflare/workers-types@4.20251014.0+\r\n**Official Docs**: https://developers.cloudflare.com/durable-objects/\r\n\r\n---\r\n\r\n\r\n### Always Do\r\n\r\n✅ **Export DO class** from Worker\r\n```typescript\r\nexport class MyDO extends DurableObject { }\r\nexport default MyDO;  // Required\r\n```\r\n\r\n✅ **Call `super(ctx, env)`** in constructor\r\n```typescript\r\nconstructor(ctx: DurableObjectState, env: Env) {\r\n  super(ctx, env);  // Required first line\r\n}\r\n```\r\n\r\n✅ **Use `new_sqlite_classes`** for new DOs\r\n```jsonc\r\n{ \"tag\": \"v1\", \"new_sqlite_classes\": [\"MyDO\"] }\r\n```\r\n\r\n✅ **Use `ctx.acceptWebSocket()`** for hibernation\r\n```typescript\r\nthis.ctx.acceptWebSocket(server);  // Enables hibernation\r\n```\r\n\r\n✅ **Persist critical state** to storage (not just memory)\r\n```typescript\r\nawait this.ctx.storage.put('important', value);\r\n```\r\n\r\n✅ **Use alarms** instead of setTimeout/setInterval\r\n```typescript\r\nawait this.ctx.storage.setAlarm(Date.now() + 60000);\r\n```\r\n\r\n✅ **Use parameterized SQL queries**\r\n```typescript\r\nthis.sql.exec('SELECT * FROM table WHERE id = ?', id);\r\n```\r\n\r\n✅ **Minimize constructor work**\r\n```typescript\r\nconstructor(ctx, env) {\r\n  super(ctx, env);\r\n  // Minimal initialization only\r\n  ctx.blockConcurrencyWhile(async () => {\r\n    // Load from storage\r\n  });\r\n}\r\n```\r\n\r\n### Never Do\r\n\r\n❌ **Create DO without migration**\r\n```jsonc\r\n// Missing migrations array = error\r\n```\r\n\r\n❌ **Forget to export DO class**\r\n```typescript\r\nclass MyDO extends DurableObject { }\r\n// Missing: export default MyDO;\r\n```\r\n\r\n❌ **Use `setTimeout` or `setInterval`**\r\n```typescript\r\nsetTimeout(() => {}, 1000);  // Prevents hibernation\r\n```\r\n\r\n❌ **Rely only on in-memory state** with WebSockets\r\n```typescript\r\n// ❌ WRONG: this.sessions will be lost on hibernation\r\n// ✅ CORRECT: Use serializeAttachment()\r\n```\r\n\r\n❌ **Deploy migrations gradually**\r\n```bash",
  "name": "cloudflare-durable-objects",
  "id": "cloudflare-durable-objects",
  "sections": {
    "Known Issues Prevention": "This skill prevents **15+ documented issues**:\r\n\r\n### Issue #1: Class Not Exported\r\n**Error**: `\"binding not found\"` or `\"Class X not found\"`\r\n**Source**: https://developers.cloudflare.com/durable-objects/get-started/\r\n**Why It Happens**: DO class not exported from Worker\r\n**Prevention**:\r\n```typescript\r\nexport class MyDO extends DurableObject { }\r\nexport default MyDO;  // ← Required\r\n```\r\n\r\n### Issue #2: Missing Migration\r\n**Error**: `\"migrations required\"` or `\"no migration found for class\"`\r\n**Source**: https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/\r\n**Why It Happens**: Created DO class without migration entry\r\n**Prevention**: Always add migration when creating new DO class\r\n```jsonc\r\n{\r\n  \"migrations\": [\r\n    { \"tag\": \"v1\", \"new_sqlite_classes\": [\"MyDO\"] }\r\n  ]\r\n}\r\n```\r\n\r\n### Issue #3: Wrong Migration Type (KV vs SQLite)\r\n**Error**: Schema errors, storage API mismatch\r\n**Source**: https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/\r\n**Why It Happens**: Used `new_classes` instead of `new_sqlite_classes`\r\n**Prevention**: Use `new_sqlite_classes` for SQLite backend (recommended)\r\n\r\n### Issue #4: Constructor Overhead Blocks Hibernation Wake\r\n**Error**: Slow hibernation wake-up times\r\n**Source**: https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage/\r\n**Why It Happens**: Heavy work in constructor\r\n**Prevention**: Minimize constructor, use `blockConcurrencyWhile()`\r\n```typescript\r\nconstructor(ctx, env) {\r\n  super(ctx, env);\r\n  ctx.blockConcurrencyWhile(async () => {\r\n    // Load from storage\r\n  });\r\n}\r\n```\r\n\r\n### Issue #5: setTimeout Breaks Hibernation\r\n**Error**: DO never hibernates, high duration charges\r\n**Source**: https://developers.cloudflare.com/durable-objects/concepts/durable-object-lifecycle/\r\n**Why It Happens**: `setTimeout`/`setInterval` prevents hibernation\r\n**Prevention**: Use alarms API instead\r\n```typescript\r\n// ❌ WRONG\r\nsetTimeout(() => {}, 1000);\r\n\r\n// ✅ CORRECT\r\nawait this.ctx.storage.setAlarm(Date.now() + 1000);\r\n```\r\n\r\n### Issue #6: In-Memory State Lost on Hibernation\r\n**Error**: WebSocket metadata lost, state reset unexpectedly\r\n**Source**: https://developers.cloudflare.com/durable-objects/best-practices/websockets/\r\n**Why It Happens**: Relied on in-memory state that's cleared on hibernation\r\n**Prevention**: Use `serializeAttachment()` for WebSocket metadata\r\n```typescript\r\nws.serializeAttachment({ userId, username });\r\n\r\n// Restore in constructor\r\nctx.getWebSockets().forEach(ws => {\r\n  const metadata = ws.deserializeAttachment();\r\n  this.sessions.set(ws, metadata);\r\n});\r\n```\r\n\r\n### Issue #7: Outgoing WebSocket Cannot Hibernate\r\n**Error**: High charges despite hibernation API\r\n**Source**: https://developers.cloudflare.com/durable-objects/best-practices/websockets/\r\n**Why It Happens**: Outgoing WebSockets don't support hibernation\r\n**Prevention**: Only use hibernation for server-side (incoming) WebSockets\r\n\r\n### Issue #8: Global Uniqueness Confusion\r\n**Error**: Unexpected DO class name conflicts\r\n**Source**: https://developers.cloudflare.com/durable-objects/platform/known-issues/#global-uniqueness\r\n**Why It Happens**: DO class names are globally unique per account\r\n**Prevention**: Understand DO class names are shared across all Workers in account\r\n\r\n### Issue #9: Partial deleteAll on KV Backend\r\n**Error**: Storage not fully deleted, billing continues\r\n**Source**: https://developers.cloudflare.com/durable-objects/api/legacy-kv-storage-api/\r\n**Why It Happens**: KV backend `deleteAll()` can fail partially\r\n**Prevention**: Use SQLite backend for atomic deleteAll\r\n\r\n### Issue #10: Binding Name Mismatch\r\n**Error**: Runtime error accessing DO binding\r\n**Source**: https://developers.cloudflare.com/durable-objects/get-started/\r\n**Why It Happens**: Binding name in wrangler.jsonc doesn't match code\r\n**Prevention**: Ensure consistency\r\n```jsonc\r\n{ \"bindings\": [{ \"name\": \"MY_DO\", \"class_name\": \"MyDO\" }] }\r\n```\r\n```typescript\r\nenv.MY_DO.getByName('instance');  // Must match binding name\r\n```\r\n\r\n### Issue #11: State Size Exceeded\r\n**Error**: `\"state limit exceeded\"` or storage errors\r\n**Source**: https://developers.cloudflare.com/durable-objects/platform/pricing/\r\n**Why It Happens**: Exceeded 1GB (SQLite) or 128MB (KV) limit\r\n**Prevention**: Monitor storage size, implement cleanup with alarms\r\n\r\n### Issue #12: Migration Not Atomic\r\n**Error**: Gradual deployment blocked\r\n**Source**: https://developers.cloudflare.com/workers/configuration/versions-and-deployments/gradual-deployments/\r\n**Why It Happens**: Tried to use gradual rollout with migrations\r\n**Prevention**: Migrations deploy atomically across all instances\r\n\r\n### Issue #13: Location Hint Ignored\r\n**Error**: DO created in wrong region\r\n**Source**: https://developers.cloudflare.com/durable-objects/reference/data-location/\r\n**Why It Happens**: Location hints are best-effort, not guaranteed\r\n**Prevention**: Use jurisdiction for strict requirements\r\n\r\n### Issue #14: Alarm Retry Failures\r\n**Error**: Tasks lost after alarm failures\r\n**Source**: https://developers.cloudflare.com/durable-objects/api/alarms/\r\n**Why It Happens**: Alarm handler throws errors repeatedly\r\n**Prevention**: Implement idempotent alarm handlers\r\n```typescript\r\nasync alarm(info: { retryCount: number }): Promise<void> {\r\n  if (info.retryCount > 3) {\r\n    console.error('Giving up after 3 retries');\r\n    return;\r\n  }\r\n  // Idempotent operation\r\n}\r\n```\r\n\r\n### Issue #15: Fetch Blocks Hibernation\r\n**Error**: DO never hibernates despite using hibernation API\r\n**Source**: https://developers.cloudflare.com/durable-objects/concepts/durable-object-lifecycle/\r\n**Why It Happens**: In-progress `fetch()` requests prevent hibernation\r\n**Prevention**: Ensure all async I/O completes before idle period\r\n\r\n---",
    "Creating Durable Object Stubs and Routing": "To interact with a Durable Object from a Worker, you need to:\r\n1. Get a **Durable Object ID**\r\n2. Create a **stub** from the ID\r\n3. Call methods on the stub\r\n\r\n### Getting Durable Object IDs\r\n\r\n**Three methods to create IDs:**\r\n\r\n#### 1. `idFromName(name)` - Named DOs (Most Common)\r\n\r\nUse when you want **consistent routing** to the same DO instance based on a name:\r\n\r\n```typescript\r\n// Same name always routes to same DO instance globally\r\nconst roomId = env.CHAT_ROOM.idFromName('room-123');\r\nconst userId = env.USER_SESSION.idFromName('user-alice');\r\nconst globalCounter = env.COUNTER.idFromName('global');\r\n```\r\n\r\n**Use for:**\r\n- Chat rooms (name = room ID)\r\n- User sessions (name = user ID)\r\n- Per-tenant logic (name = tenant ID)\r\n- Global singletons (name = 'global')\r\n\r\n**Characteristics:**\r\n- ✅ **Deterministic** - same name = same DO instance\r\n- ✅ **Easy to reference** - just need the name string\r\n- ⚠️ **First access latency** - ~100-300ms for global uniqueness check\r\n- ⚠️ **Cached after first use** - subsequent access is fast\r\n\r\n#### 2. `newUniqueId()` - Random IDs\r\n\r\nUse when you need a **new, unique DO instance**:\r\n\r\n```typescript\r\n// Creates a random, globally unique ID\r\nconst id = env.MY_DO.newUniqueId();\r\n\r\n// With jurisdiction restriction (EU data residency)\r\nconst euId = env.MY_DO.newUniqueId({ jurisdiction: 'eu' });\r\n\r\n// Store the ID for future use\r\nconst idString = id.toString();\r\nawait env.KV.put('session:123', idString);\r\n```\r\n\r\n**Use for:**\r\n- Creating new sessions/rooms that don't exist yet\r\n- One-time use DOs\r\n- When you don't have a natural name\r\n\r\n**Characteristics:**\r\n- ✅ **Lower latency** on first use (no global uniqueness check)\r\n- ⚠️ **Must store ID** to access same DO later\r\n- ⚠️ **ID format is opaque** - can't derive meaning from it\r\n\r\n#### 3. `idFromString(idString)` - Recreate from Saved ID\r\n\r\nUse when you've **previously stored an ID** and need to recreate it:\r\n\r\n```typescript\r\n// Get stored ID string (from KV, D1, cookie, etc.)\r\nconst idString = await env.KV.get('session:123');\r\n\r\n// Recreate ID\r\nconst id = env.MY_DO.idFromString(idString);\r\n\r\n// Get stub\r\nconst stub = env.MY_DO.get(id);\r\n```\r\n\r\n**Throws exception** if:\r\n- ID string is invalid\r\n- ID was not created from the same `DurableObjectNamespace`\r\n\r\n### Getting Stubs\r\n\r\n#### Method 1: `get(id)` - From ID\r\n\r\n```typescript\r\nconst id = env.MY_DO.idFromName('my-instance');\r\nconst stub = env.MY_DO.get(id);\r\n\r\n// Call methods\r\nawait stub.myMethod();\r\n```\r\n\r\n#### Method 2: `getByName(name)` - Shortcut for Named DOs\r\n\r\n```typescript\r\n// Shortcut that combines idFromName + get\r\nconst stub = env.MY_DO.getByName('my-instance');\r\n\r\n// Equivalent to:\r\n// const id = env.MY_DO.idFromName('my-instance');\r\n// const stub = env.MY_DO.get(id);\r\n\r\nawait stub.myMethod();\r\n```\r\n\r\n**Recommended** for named DOs (cleaner code).\r\n\r\n### Location Hints (Geographic Routing)\r\n\r\n**Control WHERE a Durable Object is created** with location hints:\r\n\r\n```typescript\r\n// Create DO near specific location\r\nconst id = env.MY_DO.idFromName('user-alice');\r\nconst stub = env.MY_DO.get(id, { locationHint: 'enam' });  // Eastern North America\r\n\r\n// Available location hints:\r\n// - 'wnam' - Western North America\r\n// - 'enam' - Eastern North America\r\n// - 'sam'  - South America\r\n// - 'weur' - Western Europe\r\n// - 'eeur' - Eastern Europe\r\n// - 'apac' - Asia-Pacific\r\n// - 'oc'   - Oceania\r\n// - 'afr'  - Africa\r\n// - 'me'   - Middle East\r\n```\r\n\r\n**When to use:**\r\n- ✅ Create DO near user's location (lower latency)\r\n- ✅ Data residency requirements (e.g., EU users → weur/eeur)\r\n\r\n**Limitations:**\r\n- ⚠️ **Hints are best-effort** - not guaranteed\r\n- ⚠️ **Only affects first creation** - subsequent access uses existing location\r\n- ⚠️ **Cannot move existing DOs** - once created, location is fixed\r\n\r\n### Jurisdiction Restriction (Data Residency)\r\n\r\n**Enforce strict data location** requirements:\r\n\r\n```typescript\r\n// Create DO that MUST stay in EU\r\nconst euId = env.MY_DO.newUniqueId({ jurisdiction: 'eu' });\r\n\r\n// Available jurisdictions:\r\n// - 'eu' - European Union\r\n// - 'fedramp' - FedRAMP (US government)\r\n```\r\n\r\n**Use for:**\r\n- Regulatory compliance (GDPR, FedRAMP)\r\n- Data sovereignty requirements\r\n\r\n**CRITICAL:**\r\n- ✅ **Strictly enforced** - DO will never leave jurisdiction\r\n- ⚠️ **Cannot combine** jurisdiction with location hints\r\n- ⚠️ **Higher latency** for users outside jurisdiction\r\n\r\n---",
    "RPC vs HTTP Fetch": "Durable Objects support **two invocation patterns**:\r\n\r\n1. **RPC (Remote Procedure Call)** - Recommended for new projects\r\n2. **HTTP Fetch** - For HTTP request/response flows or legacy compatibility\r\n\r\n### RPC Pattern (Recommended)\r\n\r\n**Enable RPC** with compatibility date `>= 2024-04-03`:\r\n\r\n```jsonc\r\n{\r\n  \"compatibility_date\": \"2025-10-22\"\r\n}\r\n```\r\n\r\n**Define RPC methods** on DO class:\r\n\r\n```typescript\r\nexport class Counter extends DurableObject {\r\n  // Public RPC methods (automatically exposed)\r\n  async increment(): Promise<number> {\r\n    let value = await this.ctx.storage.get<number>('count') || 0;\r\n    value += 1;\r\n    await this.ctx.storage.put('count', value);\r\n    return value;\r\n  }\r\n\r\n  async decrement(): Promise<number> {\r\n    let value = await this.ctx.storage.get<number>('count') || 0;\r\n    value -= 1;\r\n    await this.ctx.storage.put('count', value);\r\n    return value;\r\n  }\r\n\r\n  async get(): Promise<number> {\r\n    return await this.ctx.storage.get<number>('count') || 0;\r\n  }\r\n}\r\n```\r\n\r\n**Call from Worker:**\r\n\r\n```typescript\r\n// Get stub\r\nconst id = env.COUNTER.idFromName('my-counter');\r\nconst stub = env.COUNTER.get(id);\r\n\r\n// Call RPC methods directly\r\nconst count = await stub.increment();\r\nconst current = await stub.get();\r\n```\r\n\r\n**RPC Benefits:**\r\n- ✅ **Type-safe** - TypeScript knows method signatures\r\n- ✅ **Simple** - Direct method calls, no HTTP ceremony\r\n- ✅ **Automatic serialization** - Handles structured data\r\n- ✅ **Exception propagation** - Errors thrown in DO are received in Worker\r\n\r\n### HTTP Fetch Pattern\r\n\r\n**Define `fetch()` handler** on DO class:\r\n\r\n```typescript\r\nexport class Counter extends DurableObject {\r\n  async fetch(request: Request): Promise<Response> {\r\n    const url = new URL(request.url);\r\n\r\n    if (url.pathname === '/increment' && request.method === 'POST') {\r\n      let value = await this.ctx.storage.get<number>('count') || 0;\r\n      value += 1;\r\n      await this.ctx.storage.put('count', value);\r\n      return new Response(JSON.stringify({ count: value }));\r\n    }\r\n\r\n    if (url.pathname === '/get' && request.method === 'GET') {\r\n      let value = await this.ctx.storage.get<number>('count') || 0;\r\n      return new Response(JSON.stringify({ count: value }));\r\n    }\r\n\r\n    return new Response('Not found', { status: 404 });\r\n  }\r\n}\r\n```\r\n\r\n**Call from Worker:**\r\n\r\n```typescript\r\n// Get stub\r\nconst id = env.COUNTER.idFromName('my-counter');\r\nconst stub = env.COUNTER.get(id);\r\n\r\n// Call fetch\r\nconst response = await stub.fetch('https://fake-host/increment', {\r\n  method: 'POST',\r\n});\r\n\r\nconst data = await response.json();\r\n```\r\n\r\n### When to Use Each\r\n\r\n| Use Case | Recommendation |\r\n|----------|----------------|\r\n| **New project** | ✅ RPC (simpler, type-safe) |\r\n| **HTTP request/response flow** | HTTP Fetch |\r\n| **Complex routing logic** | HTTP Fetch |\r\n| **Type safety important** | ✅ RPC |\r\n| **Legacy compatibility** | HTTP Fetch |\r\n| **WebSocket upgrades** | HTTP Fetch (required) |\r\n\r\n---",
    "What are Durable Objects?": "Cloudflare Durable Objects are **globally unique, stateful objects** that provide:\r\n\r\n- **Single-point coordination** - Each Durable Object instance is globally unique across Cloudflare's network\r\n- **Strong consistency** - Transactional, serializable storage (ACID guarantees)\r\n- **Real-time communication** - WebSocket Hibernation API for thousands of connections per instance\r\n- **Persistent state** - Built-in SQLite database (up to 1GB) or key-value storage\r\n- **Scheduled tasks** - Alarms API for future task execution\r\n- **Global distribution** - Automatically routed to optimal location\r\n- **Automatic scaling** - Millions of independent instances\r\n\r\n**Use Cases**:\r\n- Chat rooms and real-time collaboration\r\n- Multiplayer game servers\r\n- Rate limiting and session management\r\n- Leader election and coordination\r\n- WebSocket servers with hibernation\r\n- Stateful workflows and queues\r\n- Per-user or per-room logic\r\n\r\n---",
    "Migrations - Managing DO Classes": "**Migrations are REQUIRED** when you:\r\n- Create a new DO class\r\n- Rename a DO class\r\n- Delete a DO class\r\n- Transfer a DO class to another Worker\r\n\r\n**Migration Types:**\r\n\r\n### 1. Create New DO Class\r\n\r\n```jsonc\r\n{\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"COUNTER\",\r\n        \"class_name\": \"Counter\"\r\n      }\r\n    ]\r\n  },\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",                    // Unique identifier for this migration\r\n      \"new_sqlite_classes\": [         // SQLite backend (recommended)\r\n        \"Counter\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**For KV backend (legacy):**\r\n\r\n```jsonc\r\n{\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_classes\": [\"Counter\"]      // KV backend (128MB limit)\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**CRITICAL:**\r\n- ✅ Use `new_sqlite_classes` for new DOs (up to 1GB storage)\r\n- ❌ Cannot enable SQLite on existing deployed KV-backed DOs\r\n\r\n### 2. Rename DO Class\r\n\r\n```jsonc\r\n{\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"MY_DO\",\r\n        \"class_name\": \"NewClassName\"    // New class name\r\n      }\r\n    ]\r\n  },\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"OldClassName\"]\r\n    },\r\n    {\r\n      \"tag\": \"v2\",                      // New migration tag\r\n      \"renamed_classes\": [\r\n        {\r\n          \"from\": \"OldClassName\",\r\n          \"to\": \"NewClassName\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**What happens:**\r\n- ✅ Existing DO instances keep their data\r\n- ✅ Old bindings automatically forward to new class\r\n- ⚠️ **Must export new class** in Worker code\r\n\r\n### 3. Delete DO Class\r\n\r\n```jsonc\r\n{\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"Counter\"]\r\n    },\r\n    {\r\n      \"tag\": \"v2\",\r\n      \"deleted_classes\": [\"Counter\"]    // Mark as deleted\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**What happens:**\r\n- ✅ Existing DO instances are **deleted immediately**\r\n- ✅ All storage is deleted\r\n- ⚠️ **Cannot undo** - data is permanently lost\r\n\r\n**Before deleting:**\r\n- Export data if needed\r\n- Update Workers that reference this DO\r\n\r\n### 4. Transfer DO Class to Another Worker\r\n\r\n```jsonc\r\n// In destination Worker:\r\n{\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"TRANSFERRED_DO\",\r\n        \"class_name\": \"TransferredClass\"\r\n      }\r\n    ]\r\n  },\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"transferred_classes\": [\r\n        {\r\n          \"from\": \"OriginalClass\",\r\n          \"from_script\": \"original-worker\",  // Source Worker name\r\n          \"to\": \"TransferredClass\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**What happens:**\r\n- ✅ DO instances move to new Worker\r\n- ✅ All storage is transferred\r\n- ✅ Old bindings automatically forward\r\n- ⚠️ **Destination class must be exported**\r\n\r\n### Migration Rules\r\n\r\n**CRITICAL Migration Gotchas:**\r\n\r\n❌ **Migrations are ATOMIC** - cannot gradual deploy\r\n- All instances migrate at once when you deploy\r\n- No partial rollout support\r\n\r\n❌ **Migration tags must be unique**\r\n- Cannot reuse tags\r\n- Tags are append-only\r\n\r\n❌ **Cannot enable SQLite on existing KV-backed DOs**\r\n- Must create new DO class instead\r\n\r\n✅ **Code changes don't need migrations**\r\n- Only schema changes (new/rename/delete/transfer) need migrations\r\n- You can deploy code updates freely\r\n\r\n✅ **Global uniqueness is per account**\r\n- DO class names are unique across your entire account\r\n- Even across different Workers\r\n\r\n---",
    "TypeScript Types": "```typescript\r\nimport { DurableObject, DurableObjectState, DurableObjectNamespace } from 'cloudflare:workers';\r\n\r\n// Environment bindings\r\ninterface Env {\r\n  MY_DO: DurableObjectNamespace<MyDurableObject>;\r\n  DB: D1Database;\r\n  // ... other bindings\r\n}\r\n\r\n// Durable Object class\r\nexport class MyDurableObject extends DurableObject<Env> {\r\n  sql: SqlStorage;\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n    this.sql = ctx.storage.sql;\r\n  }\r\n\r\n  async myMethod(): Promise<string> {\r\n    // Access env bindings\r\n    await this.env.DB.prepare('...').run();\r\n    return 'Hello';\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Alarms API - Scheduled Tasks": "The **Alarms API** allows Durable Objects to schedule themselves to wake up at a specific time in the future.\r\n\r\n**Use for:** Batching, cleanup jobs, reminders, periodic tasks, delayed operations\r\n\r\n### Basic Alarm Pattern\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class Batcher extends DurableObject {\r\n  buffer: string[];\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n\r\n    ctx.blockConcurrencyWhile(async () => {\r\n      // Restore buffer from storage\r\n      this.buffer = await ctx.storage.get('buffer') || [];\r\n    });\r\n  }\r\n\r\n  async addItem(item: string): Promise<void> {\r\n    this.buffer.push(item);\r\n    await this.ctx.storage.put('buffer', this.buffer);\r\n\r\n    // Schedule alarm for 10 seconds from now (if not already set)\r\n    const currentAlarm = await this.ctx.storage.getAlarm();\r\n    if (currentAlarm === null) {\r\n      await this.ctx.storage.setAlarm(Date.now() + 10000);\r\n    }\r\n  }\r\n\r\n  // Called when alarm fires\r\n  async alarm(alarmInfo: { retryCount: number; isRetry: boolean }): Promise<void> {\r\n    console.log(`Alarm fired (retry count: ${alarmInfo.retryCount})`);\r\n\r\n    // Process batch\r\n    if (this.buffer.length > 0) {\r\n      await this.processBatch(this.buffer);\r\n\r\n      // Clear buffer\r\n      this.buffer = [];\r\n      await this.ctx.storage.put('buffer', []);\r\n    }\r\n\r\n    // Alarm is automatically deleted after successful execution\r\n  }\r\n\r\n  async processBatch(items: string[]): Promise<void> {\r\n    // Send to external API, write to database, etc.\r\n    console.log(`Processing ${items.length} items:`, items);\r\n  }\r\n}\r\n```\r\n\r\n**Alarm API Methods:**\r\n\r\n```typescript\r\n// Set alarm to fire at specific timestamp\r\nawait this.ctx.storage.setAlarm(Date.now() + 60000);  // 60 seconds from now\r\n\r\n// Set alarm to fire at specific date\r\nawait this.ctx.storage.setAlarm(new Date('2025-12-31T23:59:59Z'));\r\n\r\n// Get current alarm (null if not set)\r\nconst alarmTime = await this.ctx.storage.getAlarm();\r\n\r\n// Delete alarm\r\nawait this.ctx.storage.deleteAlarm();\r\n\r\n// Alarm handler (called when alarm fires)\r\nasync alarm(alarmInfo: { retryCount: number; isRetry: boolean }): Promise<void> {\r\n  // Do work\r\n}\r\n```\r\n\r\n**Alarm Behavior:**\r\n- ✅ **Guaranteed at-least-once execution** - will retry on failure\r\n- ✅ **Automatic retries** - up to 6 retries with exponential backoff (starting at 2 seconds)\r\n- ✅ **Persistent** - survives DO hibernation and eviction\r\n- ✅ **Automatically deleted** after successful execution\r\n- ⚠️ **One alarm per DO** - setting a new alarm overwrites the previous one\r\n\r\n**Retry Pattern (Idempotent Operations):**\r\n\r\n```typescript\r\nasync alarm(alarmInfo: { retryCount: number; isRetry: boolean }): Promise<void> {\r\n  if (alarmInfo.retryCount > 3) {\r\n    console.error('Alarm failed after 3 retries, giving up');\r\n    return;\r\n  }\r\n\r\n  try {\r\n    // Idempotent operation (safe to retry)\r\n    await this.sendNotification();\r\n  } catch (error) {\r\n    console.error('Alarm failed:', error);\r\n    throw error;  // Will trigger retry\r\n  }\r\n}\r\n```\r\n\r\n---",
    "WebSocket Hibernation API": "The **WebSocket Hibernation API** allows Durable Objects to:\r\n- Handle **thousands of WebSocket connections** per instance\r\n- **Hibernate** when idle (no messages, no events) to save costs\r\n- **Wake up** automatically when messages arrive\r\n- Maintain connections without incurring duration charges during idle periods\r\n\r\n**Use for:** Chat rooms, real-time collaboration, multiplayer games, live updates\r\n\r\n### How Hibernation Works\r\n\r\n1. **Active state** - DO is in memory, handling messages\r\n2. **Idle state** - No messages for ~10 seconds, DO can hibernate\r\n3. **Hibernation** - In-memory state cleared, WebSockets stay connected to Cloudflare edge\r\n4. **Wake up** - New message arrives → constructor runs → handler method called\r\n\r\n**CRITICAL:** In-memory state is **lost on hibernation**. Use `serializeAttachment()` to persist per-WebSocket metadata.\r\n\r\n### WebSocket Server Pattern\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class ChatRoom extends DurableObject {\r\n  sessions: Map<WebSocket, { userId: string; username: string }>;\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n\r\n    // Restore WebSocket connections after hibernation\r\n    this.sessions = new Map();\r\n\r\n    ctx.getWebSockets().forEach((ws) => {\r\n      // Deserialize attachment (persisted metadata)\r\n      const attachment = ws.deserializeAttachment();\r\n      this.sessions.set(ws, attachment);\r\n    });\r\n  }\r\n\r\n  async fetch(request: Request): Promise<Response> {\r\n    // Expect WebSocket upgrade request\r\n    const upgradeHeader = request.headers.get('Upgrade');\r\n    if (upgradeHeader !== 'websocket') {\r\n      return new Response('Expected websocket', { status: 426 });\r\n    }\r\n\r\n    // Create WebSocket pair\r\n    const webSocketPair = new WebSocketPair();\r\n    const [client, server] = Object.values(webSocketPair);\r\n\r\n    // Get user info from URL or headers\r\n    const url = new URL(request.url);\r\n    const userId = url.searchParams.get('userId') || 'anonymous';\r\n    const username = url.searchParams.get('username') || 'Anonymous';\r\n\r\n    // Accept WebSocket with hibernation\r\n    // CRITICAL: Use ctx.acceptWebSocket(), NOT ws.accept()\r\n    this.ctx.acceptWebSocket(server);\r\n\r\n    // Serialize metadata to persist across hibernation\r\n    const metadata = { userId, username };\r\n    server.serializeAttachment(metadata);\r\n\r\n    // Track in-memory (will be restored after hibernation)\r\n    this.sessions.set(server, metadata);\r\n\r\n    // Notify others\r\n    this.broadcast(`${username} joined`, server);\r\n\r\n    // Return client WebSocket to browser\r\n    return new Response(null, {\r\n      status: 101,\r\n      webSocket: client,\r\n    });\r\n  }\r\n\r\n  // Called when WebSocket receives a message\r\n  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer): Promise<void> {\r\n    const session = this.sessions.get(ws);\r\n\r\n    if (typeof message === 'string') {\r\n      const data = JSON.parse(message);\r\n\r\n      if (data.type === 'chat') {\r\n        // Broadcast to all connections\r\n        this.broadcast(`${session?.username}: ${data.text}`, ws);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Called when WebSocket closes\r\n  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean): Promise<void> {\r\n    const session = this.sessions.get(ws);\r\n    this.sessions.delete(ws);\r\n\r\n    // Close the WebSocket\r\n    ws.close(code, 'Durable Object closing WebSocket');\r\n\r\n    // Notify others\r\n    if (session) {\r\n      this.broadcast(`${session.username} left`);\r\n    }\r\n  }\r\n\r\n  // Called on WebSocket errors\r\n  async webSocketError(ws: WebSocket, error: any): Promise<void> {\r\n    console.error('WebSocket error:', error);\r\n    const session = this.sessions.get(ws);\r\n    this.sessions.delete(ws);\r\n  }\r\n\r\n  // Helper to broadcast to all connections\r\n  broadcast(message: string, except?: WebSocket): void {\r\n    this.sessions.forEach((session, ws) => {\r\n      if (ws !== except && ws.readyState === WebSocket.OPEN) {\r\n        ws.send(JSON.stringify({ type: 'message', text: message }));\r\n      }\r\n    });\r\n  }\r\n}\r\n```\r\n\r\n**WebSocket Handler Methods:**\r\n\r\n```typescript\r\n// Receive message from client\r\nasync webSocketMessage(\r\n  ws: WebSocket,\r\n  message: string | ArrayBuffer\r\n): Promise<void> {\r\n  // Handle message\r\n}\r\n\r\n// WebSocket closed by client\r\nasync webSocketClose(\r\n  ws: WebSocket,\r\n  code: number,\r\n  reason: string,\r\n  wasClean: boolean\r\n): Promise<void> {\r\n  // Cleanup\r\n}\r\n\r\n// WebSocket error occurred\r\nasync webSocketError(\r\n  ws: WebSocket,\r\n  error: any\r\n): Promise<void> {\r\n  // Handle error\r\n}\r\n```\r\n\r\n**Hibernation-Safe Patterns:**\r\n\r\n```typescript\r\n// ✅ CORRECT: Use ctx.acceptWebSocket (enables hibernation)\r\nthis.ctx.acceptWebSocket(server);\r\n\r\n// ❌ WRONG: Don't use ws.accept() (standard API, no hibernation)\r\nserver.accept();\r\n\r\n// ✅ CORRECT: Persist metadata across hibernation\r\nserver.serializeAttachment({ userId: '123', username: 'Alice' });\r\n\r\n// ✅ CORRECT: Restore metadata in constructor\r\nconstructor(ctx, env) {\r\n  super(ctx, env);\r\n\r\n  ctx.getWebSockets().forEach((ws) => {\r\n    const metadata = ws.deserializeAttachment();\r\n    this.sessions.set(ws, metadata);\r\n  });\r\n}\r\n\r\n// ❌ WRONG: Don't use setTimeout/setInterval (prevents hibernation)\r\nsetTimeout(() => { /* ... */ }, 1000);  // ❌ NEVER DO THIS\r\n\r\n// ✅ CORRECT: Use alarms for scheduled tasks\r\nawait this.ctx.storage.setAlarm(Date.now() + 60000);\r\n```\r\n\r\n**When Hibernation Does NOT Occur:**\r\n- `setTimeout` or `setInterval` callbacks are pending\r\n- In-progress `fetch()` request (awaited I/O)\r\n- Standard WebSocket API is used (not hibernation API)\r\n- Request/event is still being processed\r\n\r\n---",
    "Configuration Reference": "### Complete wrangler.jsonc Example\r\n\r\n```jsonc\r\n{\r\n  \"$schema\": \"node_modules/wrangler/config-schema.json\",\r\n  \"name\": \"my-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-22\",\r\n\r\n  // Durable Objects configuration\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"COUNTER\",              // Binding name (use as env.COUNTER)\r\n        \"class_name\": \"Counter\"         // Must match exported class\r\n      },\r\n      {\r\n        \"name\": \"CHAT_ROOM\",\r\n        \"class_name\": \"ChatRoom\"\r\n      }\r\n    ]\r\n  },\r\n\r\n  // Migrations (required for all DO changes)\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",                      // Initial migration\r\n      \"new_sqlite_classes\": [\r\n        \"Counter\",\r\n        \"ChatRoom\"\r\n      ]\r\n    },\r\n    {\r\n      \"tag\": \"v2\",                      // Rename example\r\n      \"renamed_classes\": [\r\n        {\r\n          \"from\": \"Counter\",\r\n          \"to\": \"CounterV2\"\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n---",
    "Critical Rules": "```\r\n\r\n❌ **Enable SQLite on existing KV-backed DO**\r\n```jsonc\r\n// Not supported - must create new DO class instead\r\n```\r\n\r\n❌ **Use standard WebSocket API** expecting hibernation\r\n```typescript\r\nws.accept();  // ❌ No hibernation\r\nthis.ctx.acceptWebSocket(ws);  // ✅ Hibernation enabled\r\n```\r\n\r\n❌ **Assume location hints are guaranteed**\r\n```typescript\r\n// Location hints are best-effort only\r\n```\r\n\r\n---",
    "Durable Object Class Structure": "### Base Class Pattern\r\n\r\nAll Durable Objects **MUST extend `DurableObject`** from `cloudflare:workers`:\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class MyDurableObject extends DurableObject {\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n\r\n    // Optional: Initialize from storage\r\n    ctx.blockConcurrencyWhile(async () => {\r\n      // Load state before handling requests\r\n      this.someValue = await ctx.storage.get('someKey') || defaultValue;\r\n    });\r\n  }\r\n\r\n  // RPC methods (recommended)\r\n  async myMethod(): Promise<string> {\r\n    return 'Hello from DO!';\r\n  }\r\n\r\n  // Optional: HTTP fetch handler\r\n  async fetch(request: Request): Promise<Response> {\r\n    return new Response('Hello from DO fetch!');\r\n  }\r\n}\r\n\r\n// CRITICAL: Export the class\r\nexport default MyDurableObject;\r\n```\r\n\r\n### Constructor Pattern\r\n\r\n```typescript\r\nconstructor(ctx: DurableObjectState, env: Env) {\r\n  super(ctx, env);  // REQUIRED\r\n\r\n  // Access to environment bindings\r\n  this.env = env;\r\n\r\n  // this.ctx provides:\r\n  // - this.ctx.storage      (storage API)\r\n  // - this.ctx.id           (unique ID)\r\n  // - this.ctx.waitUntil()  (background tasks)\r\n  // - this.ctx.acceptWebSocket() (WebSocket hibernation)\r\n}\r\n```\r\n\r\n**CRITICAL Rules:**\r\n- ✅ **Always call `super(ctx, env)`** first\r\n- ✅ **Keep constructor minimal** - heavy work blocks hibernation wake-up\r\n- ✅ **Use `ctx.blockConcurrencyWhile()`** to initialize from storage before requests\r\n- ❌ **Never use `setTimeout` or `setInterval`** - breaks hibernation (use alarms instead)\r\n- ❌ **Don't rely only on in-memory state** with WebSockets - persist to storage\r\n\r\n### Exporting the Class\r\n\r\n```typescript\r\n// Export as default (required for Worker to use it)\r\nexport default MyDurableObject;\r\n\r\n// Also export as named export (for type inference in Worker)\r\nexport { MyDurableObject };\r\n```\r\n\r\n**In Worker:**\r\n\r\n```typescript\r\n// Import the class for types\r\nimport { MyDurableObject } from './my-durable-object';\r\n\r\n// Export it so Worker can instantiate it\r\nexport { MyDurableObject };\r\n\r\ninterface Env {\r\n  MY_DO: DurableObjectNamespace<MyDurableObject>;\r\n}\r\n```\r\n\r\n---",
    "Common Patterns": "### Pattern 1: Rate Limiting (Per-User)\r\n\r\n```typescript\r\nexport class RateLimiter extends DurableObject {\r\n  async checkLimit(userId: string, limit: number, window: number): Promise<boolean> {\r\n    const key = `rate:${userId}`;\r\n    const now = Date.now();\r\n\r\n    // Get recent requests\r\n    const requests = await this.ctx.storage.get<number[]>(key) || [];\r\n\r\n    // Remove requests outside window\r\n    const validRequests = requests.filter(timestamp => now - timestamp < window);\r\n\r\n    // Check limit\r\n    if (validRequests.length >= limit) {\r\n      return false;  // Rate limit exceeded\r\n    }\r\n\r\n    // Add current request\r\n    validRequests.push(now);\r\n    await this.ctx.storage.put(key, validRequests);\r\n\r\n    return true;  // Within limit\r\n  }\r\n}\r\n\r\n// Worker usage:\r\nconst limiter = env.RATE_LIMITER.getByName(userId);\r\nconst allowed = await limiter.checkLimit(userId, 100, 60000);  // 100 req/min\r\n\r\nif (!allowed) {\r\n  return new Response('Rate limit exceeded', { status: 429 });\r\n}\r\n```\r\n\r\n### Pattern 2: Session Management\r\n\r\n```typescript\r\nexport class UserSession extends DurableObject {\r\n  sql: SqlStorage;\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n    this.sql = ctx.storage.sql;\r\n\r\n    this.sql.exec(`\r\n      CREATE TABLE IF NOT EXISTS session (\r\n        key TEXT PRIMARY KEY,\r\n        value TEXT NOT NULL,\r\n        expires_at INTEGER\r\n      );\r\n    `);\r\n\r\n    // Schedule cleanup alarm\r\n    ctx.blockConcurrencyWhile(async () => {\r\n      const alarm = await ctx.storage.getAlarm();\r\n      if (alarm === null) {\r\n        await ctx.storage.setAlarm(Date.now() + 3600000);  // 1 hour\r\n      }\r\n    });\r\n  }\r\n\r\n  async set(key: string, value: any, ttl?: number): Promise<void> {\r\n    const expiresAt = ttl ? Date.now() + ttl : null;\r\n\r\n    this.sql.exec(\r\n      'INSERT OR REPLACE INTO session (key, value, expires_at) VALUES (?, ?, ?)',\r\n      key,\r\n      JSON.stringify(value),\r\n      expiresAt\r\n    );\r\n  }\r\n\r\n  async get(key: string): Promise<any | null> {\r\n    const cursor = this.sql.exec(\r\n      'SELECT value, expires_at FROM session WHERE key = ?',\r\n      key\r\n    );\r\n\r\n    const row = cursor.one<{ value: string; expires_at: number | null }>({ allowNone: true });\r\n\r\n    if (!row) {\r\n      return null;\r\n    }\r\n\r\n    // Check expiration\r\n    if (row.expires_at && row.expires_at < Date.now()) {\r\n      this.sql.exec('DELETE FROM session WHERE key = ?', key);\r\n      return null;\r\n    }\r\n\r\n    return JSON.parse(row.value);\r\n  }\r\n\r\n  async alarm(): Promise<void> {\r\n    // Cleanup expired sessions\r\n    this.sql.exec('DELETE FROM session WHERE expires_at < ?', Date.now());\r\n\r\n    // Schedule next cleanup\r\n    await this.ctx.storage.setAlarm(Date.now() + 3600000);\r\n  }\r\n}\r\n```\r\n\r\n### Pattern 3: Leader Election\r\n\r\n```typescript\r\nexport class LeaderElection extends DurableObject {\r\n  sql: SqlStorage;\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n    this.sql = ctx.storage.sql;\r\n\r\n    this.sql.exec(`\r\n      CREATE TABLE IF NOT EXISTS leader (\r\n        id INTEGER PRIMARY KEY CHECK (id = 1),\r\n        worker_id TEXT NOT NULL,\r\n        elected_at INTEGER NOT NULL\r\n      );\r\n    `);\r\n  }\r\n\r\n  async electLeader(workerId: string): Promise<boolean> {\r\n    // Try to become leader\r\n    try {\r\n      this.sql.exec(\r\n        'INSERT INTO leader (id, worker_id, elected_at) VALUES (1, ?, ?)',\r\n        workerId,\r\n        Date.now()\r\n      );\r\n      return true;  // Became leader\r\n    } catch (error) {\r\n      return false;  // Someone else is leader\r\n    }\r\n  }\r\n\r\n  async getLeader(): Promise<string | null> {\r\n    const cursor = this.sql.exec('SELECT worker_id FROM leader WHERE id = 1');\r\n    const row = cursor.one<{ worker_id: string }>({ allowNone: true });\r\n    return row?.worker_id || null;\r\n  }\r\n\r\n  async releaseLeadership(workerId: string): Promise<void> {\r\n    this.sql.exec('DELETE FROM leader WHERE id = 1 AND worker_id = ?', workerId);\r\n  }\r\n}\r\n```\r\n\r\n### Pattern 4: Multi-DO Coordination\r\n\r\n```typescript\r\n// Coordinator DO\r\nexport class GameCoordinator extends DurableObject {\r\n  async createGame(gameId: string, env: Env): Promise<void> {\r\n    // Create game room DO\r\n    const gameRoom = env.GAME_ROOM.getByName(gameId);\r\n    await gameRoom.initialize();\r\n\r\n    // Track in coordinator\r\n    await this.ctx.storage.put(`game:${gameId}`, {\r\n      id: gameId,\r\n      created: Date.now(),\r\n    });\r\n  }\r\n\r\n  async listGames(): Promise<string[]> {\r\n    const games = await this.ctx.storage.list({ prefix: 'game:' });\r\n    return Array.from(games.keys()).map(key => key.replace('game:', ''));\r\n  }\r\n}\r\n\r\n// Game room DO\r\nexport class GameRoom extends DurableObject {\r\n  async initialize(): Promise<void> {\r\n    await this.ctx.storage.put('state', {\r\n      players: [],\r\n      started: false,\r\n    });\r\n  }\r\n\r\n  async addPlayer(playerId: string): Promise<void> {\r\n    const state = await this.ctx.storage.get('state');\r\n    state.players.push(playerId);\r\n    await this.ctx.storage.put('state', state);\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Official Documentation": "- **Durable Objects**: https://developers.cloudflare.com/durable-objects/\r\n- **State API (SQL)**: https://developers.cloudflare.com/durable-objects/api/sqlite-storage-api/\r\n- **WebSocket Hibernation**: https://developers.cloudflare.com/durable-objects/best-practices/websockets/\r\n- **Alarms API**: https://developers.cloudflare.com/durable-objects/api/alarms/\r\n- **Migrations**: https://developers.cloudflare.com/durable-objects/reference/durable-objects-migrations/\r\n- **Best Practices**: https://developers.cloudflare.com/durable-objects/best-practices/\r\n- **Pricing**: https://developers.cloudflare.com/durable-objects/platform/pricing/\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/top-errors.md` for common problems\r\n2. Review `templates/` for working examples\r\n3. Consult official docs: https://developers.cloudflare.com/durable-objects/\r\n4. Verify migrations configuration carefully",
    "Quick Start (10 Minutes)": "### Option 1: Scaffold New DO Project\r\n\r\n```bash\r\nnpm create cloudflare@latest my-durable-app -- \\\r\n  --template=cloudflare/durable-objects-template \\\r\n  --ts \\\r\n  --git \\\r\n  --deploy false\r\n\r\ncd my-durable-app\r\nnpm install\r\nnpm run dev\r\n```\r\n\r\n**What this creates:**\r\n- Complete Durable Objects project structure\r\n- TypeScript configuration\r\n- wrangler.jsonc with bindings and migrations\r\n- Example DO class implementation\r\n- Worker to call the DO\r\n\r\n### Option 2: Add to Existing Worker\r\n\r\n```bash\r\ncd my-existing-worker\r\nnpm install -D @cloudflare/workers-types\r\n```\r\n\r\n**Create a Durable Object class** (`src/counter.ts`):\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class Counter extends DurableObject {\r\n  async increment(): Promise<number> {\r\n    // Get current value from storage (default to 0)\r\n    let value: number = (await this.ctx.storage.get('value')) || 0;\r\n\r\n    // Increment\r\n    value += 1;\r\n\r\n    // Save back to storage\r\n    await this.ctx.storage.put('value', value);\r\n\r\n    return value;\r\n  }\r\n\r\n  async get(): Promise<number> {\r\n    return (await this.ctx.storage.get('value')) || 0;\r\n  }\r\n}\r\n\r\n// CRITICAL: Export the class\r\nexport default Counter;\r\n```\r\n\r\n**Configure wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"$schema\": \"node_modules/wrangler/config-schema.json\",\r\n  \"name\": \"my-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-22\",\r\n\r\n  // Durable Objects binding\r\n  \"durable_objects\": {\r\n    \"bindings\": [\r\n      {\r\n        \"name\": \"COUNTER\",           // How you access it: env.COUNTER\r\n        \"class_name\": \"Counter\"      // MUST match exported class name\r\n      }\r\n    ]\r\n  },\r\n\r\n  // REQUIRED: Migration for new DO class\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",                   // Unique migration identifier\r\n      \"new_sqlite_classes\": [        // Use SQLite backend (recommended)\r\n        \"Counter\"\r\n      ]\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Call from Worker** (`src/index.ts`):\r\n\r\n```typescript\r\nimport { Counter } from './counter';\r\n\r\ninterface Env {\r\n  COUNTER: DurableObjectNamespace<Counter>;\r\n}\r\n\r\nexport { Counter };\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    // Get Durable Object stub by name\r\n    const id = env.COUNTER.idFromName('global-counter');\r\n    const stub = env.COUNTER.get(id);\r\n\r\n    // Call RPC method on the DO\r\n    const count = await stub.increment();\r\n\r\n    return new Response(`Count: ${count}`);\r\n  },\r\n};\r\n```\r\n\r\n**Deploy:**\r\n\r\n```bash\r\nnpx wrangler deploy\r\n```\r\n\r\n---",
    "State API - Persistent Storage": "Durable Objects provide **two storage APIs** depending on the backend:\r\n\r\n1. **SQL API** (SQLite backend) - **Recommended**\r\n2. **Key-Value API** (KV or SQLite backend)\r\n\r\n### Enable SQLite Backend (Recommended)\r\n\r\nIn `wrangler.jsonc` migrations:\r\n\r\n```jsonc\r\n{\r\n  \"migrations\": [\r\n    {\r\n      \"tag\": \"v1\",\r\n      \"new_sqlite_classes\": [\"MyDurableObject\"]  // ← Use this for SQLite\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**Why SQLite?**\r\n- ✅ Up to **1GB storage** (vs 128MB for KV backend)\r\n- ✅ **Atomic operations** (deleteAll is all-or-nothing)\r\n- ✅ **SQL queries** with transactions\r\n- ✅ **Point-in-time recovery** (PITR)\r\n- ✅ Synchronous KV API available too\r\n\r\n### SQL API\r\n\r\nAccess via `ctx.storage.sql`:\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class MyDurableObject extends DurableObject {\r\n  sql: SqlStorage;\r\n\r\n  constructor(ctx: DurableObjectState, env: Env) {\r\n    super(ctx, env);\r\n    this.sql = ctx.storage.sql;\r\n\r\n    // Create table on first run\r\n    this.sql.exec(`\r\n      CREATE TABLE IF NOT EXISTS messages (\r\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n        text TEXT NOT NULL,\r\n        user TEXT NOT NULL,\r\n        created_at INTEGER NOT NULL\r\n      );\r\n\r\n      CREATE INDEX IF NOT EXISTS idx_created_at ON messages(created_at);\r\n    `);\r\n  }\r\n\r\n  async addMessage(text: string, user: string): Promise<number> {\r\n    // Insert with exec (returns cursor)\r\n    const cursor = this.sql.exec(\r\n      'INSERT INTO messages (text, user, created_at) VALUES (?, ?, ?) RETURNING id',\r\n      text,\r\n      user,\r\n      Date.now()\r\n    );\r\n\r\n    const row = cursor.one<{ id: number }>();\r\n    return row.id;\r\n  }\r\n\r\n  async getMessages(limit: number = 50): Promise<any[]> {\r\n    const cursor = this.sql.exec(\r\n      'SELECT * FROM messages ORDER BY created_at DESC LIMIT ?',\r\n      limit\r\n    );\r\n\r\n    // Convert cursor to array\r\n    return cursor.toArray();\r\n  }\r\n\r\n  async deleteOldMessages(beforeTimestamp: number): Promise<void> {\r\n    this.sql.exec(\r\n      'DELETE FROM messages WHERE created_at < ?',\r\n      beforeTimestamp\r\n    );\r\n  }\r\n}\r\n```\r\n\r\n**SQL API Methods:**\r\n\r\n```typescript\r\n// Execute query (returns cursor)\r\nconst cursor = this.sql.exec('SELECT * FROM table WHERE id = ?', id);\r\n\r\n// Get single row\r\nconst row = cursor.one<RowType>();\r\n\r\n// Get first row or null\r\nconst row = cursor.one<RowType>({ allowNone: true });\r\n\r\n// Get all rows as array\r\nconst rows = cursor.toArray<RowType>();\r\n\r\n// Iterate cursor\r\nfor (const row of cursor) {\r\n  // Process row\r\n}\r\n\r\n// Transactions (synchronous)\r\nthis.ctx.storage.transactionSync(() => {\r\n  this.sql.exec('INSERT INTO table1 ...');\r\n  this.sql.exec('UPDATE table2 ...');\r\n  // All or nothing\r\n});\r\n```\r\n\r\n**CRITICAL SQL Rules:**\r\n- ✅ Always use **parameterized queries** with `?` placeholders\r\n- ✅ Create indexes for frequently queried columns\r\n- ✅ Use transactions for multi-statement operations\r\n- ❌ Don't access the hidden `__cf_kv` table (used internally for KV API)\r\n- ❌ Don't enable SQLite on existing deployed KV-backed DOs (not supported)\r\n\r\n### Key-Value API\r\n\r\nAvailable on **both SQLite and KV backends** via `ctx.storage`:\r\n\r\n```typescript\r\nimport { DurableObject } from 'cloudflare:workers';\r\n\r\nexport class MyDurableObject extends DurableObject {\r\n  async increment(): Promise<number> {\r\n    // Get value\r\n    let count = await this.ctx.storage.get<number>('count') || 0;\r\n\r\n    // Increment\r\n    count += 1;\r\n\r\n    // Put value back\r\n    await this.ctx.storage.put('count', count);\r\n\r\n    return count;\r\n  }\r\n\r\n  async batchOperations(): Promise<void> {\r\n    // Get multiple keys\r\n    const map = await this.ctx.storage.get<number>(['key1', 'key2', 'key3']);\r\n\r\n    // Put multiple keys\r\n    await this.ctx.storage.put({\r\n      key1: 'value1',\r\n      key2: 'value2',\r\n      key3: 'value3',\r\n    });\r\n\r\n    // Delete key\r\n    await this.ctx.storage.delete('key1');\r\n\r\n    // Delete multiple keys\r\n    await this.ctx.storage.delete(['key2', 'key3']);\r\n  }\r\n\r\n  async listKeys(): Promise<string[]> {\r\n    // List all keys\r\n    const map = await this.ctx.storage.list();\r\n    return Array.from(map.keys());\r\n\r\n    // List with prefix\r\n    const mapWithPrefix = await this.ctx.storage.list({\r\n      prefix: 'user:',\r\n      limit: 100,\r\n    });\r\n  }\r\n\r\n  async deleteAllStorage(): Promise<void> {\r\n    // Delete alarm first (if set)\r\n    await this.ctx.storage.deleteAlarm();\r\n\r\n    // Delete all storage (DO will cease to exist after shutdown)\r\n    await this.ctx.storage.deleteAll();\r\n  }\r\n}\r\n```\r\n\r\n**KV API Methods:**\r\n\r\n```typescript\r\n// Get single value\r\nconst value = await this.ctx.storage.get<T>('key');\r\n\r\n// Get multiple values (returns Map)\r\nconst map = await this.ctx.storage.get<T>(['key1', 'key2']);\r\n\r\n// Put single value\r\nawait this.ctx.storage.put('key', value);\r\n\r\n// Put multiple values\r\nawait this.ctx.storage.put({ key1: value1, key2: value2 });\r\n\r\n// Delete single key\r\nawait this.ctx.storage.delete('key');\r\n\r\n// Delete multiple keys\r\nawait this.ctx.storage.delete(['key1', 'key2']);\r\n\r\n// List keys\r\nconst map = await this.ctx.storage.list<T>({\r\n  prefix: 'user:',\r\n  limit: 100,\r\n  reverse: false\r\n});\r\n\r\n// Delete all (atomic on SQLite, may be partial on KV backend)\r\nawait this.ctx.storage.deleteAll();\r\n\r\n// Transactions (async)\r\nawait this.ctx.storage.transaction(async (txn) => {\r\n  await txn.put('key1', value1);\r\n  await txn.put('key2', value2);\r\n  // All or nothing\r\n});\r\n```\r\n\r\n**Storage Limits:**\r\n- **SQLite backend**: Up to **1GB** storage per DO instance\r\n- **KV backend**: Up to **128MB** storage per DO instance\r\n\r\n---"
  }
}