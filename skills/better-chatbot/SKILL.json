{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/AGENTS.md",
      "references/CONTRIBUTING.md",
      "references/example-reference.md"
    ]
  },
  "content": "**Status**: Production Ready\r\n**Last Updated**: 2025-11-04 (v2.1.0 - Added extension points + UX patterns)\r\n**Dependencies**: None (references better-chatbot project)\r\n**Latest Versions**: Next.js 15.3.2, Vercel AI SDK 5.0.82, Better Auth 1.3.34, Drizzle ORM 0.41.0\r\n\r\n---\r\n\r\n\r\n### Repository Pattern Architecture\r\n\r\n**Location**: `src/lib/db/`\r\n\r\n**Structure**:\r\n```\r\ndb/\r\n├── repository.ts          → Single import point\r\n├── pg/\r\n│   ├── db.pg.ts          → Drizzle connection\r\n│   ├── schema.pg.ts      → Table definitions\r\n│   └── repositories/     → Feature queries\r\n└── migrations/           → Drizzle migrations\r\n```\r\n\r\n**Philosophy**: Abstract DB behind repository interfaces\r\n\r\n### Interface-First Design\r\n\r\n**Pattern**:\r\n```typescript\r\n// 1. Define interface in src/types/[domain].ts\r\nexport type ChatRepository = {\r\n  insertThread(thread: Omit<ChatThread, \"createdAt\">): Promise<ChatThread>;\r\n  selectThread(id: string): Promise<ChatThread | null>;\r\n  selectThreadDetails(id: string): Promise<ThreadDetails | null>;\r\n};\r\n\r\n// 2. Implement in src/lib/db/pg/repositories/[domain]-repository.pg.ts\r\nexport const pgChatRepository: ChatRepository = {\r\n  selectThreadDetails: async (id: string) => {\r\n    const [thread] = await db\r\n      .select()\r\n      .from(ChatThreadTable)\r\n      .leftJoin(UserTable, eq(ChatThreadTable.userId, UserTable.id))\r\n      .where(eq(ChatThreadTable.id, id));\r\n\r\n    if (!thread) return null;\r\n\r\n    const messages = await pgChatRepository.selectMessagesByThreadId(id);\r\n\r\n    return {\r\n      id: thread.chat_thread.id,\r\n      title: thread.chat_thread.title,\r\n      userId: thread.chat_thread.userId,\r\n      createdAt: thread.chat_thread.createdAt,\r\n      userPreferences: thread.user?.preferences,\r\n      messages,\r\n    };\r\n  },\r\n};\r\n\r\n// 3. Export from src/lib/db/repository.ts\r\nexport const chatRepository = pgChatRepository;\r\n```\r\n\r\n**Why**:\r\n- Easy to swap implementations (pg → sqlite)\r\n- Testable without database\r\n- Consistent API across codebase\r\n\r\n### Query Optimization Strategies\r\n\r\n**1. Indexes on Foreign Keys**:\r\n```typescript\r\nexport const ChatThreadTable = pgTable(\"chat_thread\", {\r\n  id: uuid(\"id\").primaryKey(),\r\n  userId: uuid(\"user_id\").references(() => UserTable.id),\r\n}, (table) => ({\r\n  userIdIdx: index(\"chat_thread_user_id_idx\").on(table.userId),\r\n}));\r\n```\r\n\r\n**2. Selective Loading**:\r\n```typescript\r\n// Load minimal data\r\nselectThread(id) → { id, title, userId, createdAt }\r\n\r\n// Load full data when needed\r\nselectThreadDetails(id) → { ...thread, messages, userPreferences }\r\n```\r\n\r\n**3. SQL Aggregation**:\r\n```typescript\r\n// Get threads with last message timestamp\r\nconst threadsWithActivity = await db\r\n  .select({\r\n    threadId: ChatThreadTable.id,\r\n    lastMessageAt: sql<string>`MAX(${ChatMessageTable.createdAt})`,\r\n  })\r\n  .from(ChatThreadTable)\r\n  .leftJoin(ChatMessageTable, eq(ChatThreadTable.id, ChatMessageTable.threadId))\r\n  .groupBy(ChatThreadTable.id)\r\n  .orderBy(desc(sql`last_message_at`));\r\n```\r\n\r\n### Schema Evolution Workflow\r\n\r\n```bash\r\nexport const NewTable = pgTable(\"new_table\", { ... });\r\n\r\npnpm db:generate\r\n\r\npnpm db:migrate\r\n\r\n\r\n### Core Commands\r\n\r\n```bash\r\npnpm dev                    # Start dev server\r\npnpm build                  # Production build\r\npnpm start                  # Start production server\r\npnpm lint:fix               # Auto-fix linting issues\r\n\r\npnpm db:generate            # Generate migrations\r\npnpm db:migrate             # Run migrations\r\npnpm db:push                # Push schema changes\r\npnpm db:studio              # Open Drizzle Studio\r\n\r\npnpm test                   # Run Vitest unit tests\r\npnpm test:e2e               # Full Playwright E2E suite\r\npnpm test:e2e:first-user    # First-user signup + admin role tests\r\npnpm test:e2e:standard      # Standard tests (skip first-user)\r\npnpm test:e2e:ui            # Interactive Playwright UI\r\n\r\n\r\n### Unit Tests (Vitest)\r\n\r\n- **Collocated** with source code (`*.test.ts`)\r\n- **Coverage**: Happy path + one failure mode minimum\r\n- **Example**:\r\n  ```typescript\r\n  // src/lib/utils.test.ts\r\n  import { describe, it, expect } from 'vitest'\r\n  import { formatDate } from './utils'\r\n\r\n  describe('formatDate', () => {\r\n    it('formats ISO date correctly', () => {\r\n      expect(formatDate('2025-01-01')).toBe('January 1, 2025')\r\n    })\r\n\r\n    it('handles invalid date', () => {\r\n      expect(formatDate('invalid')).toBe('Invalid Date')\r\n    })\r\n  })\r\n  ```\r\n\r\n### E2E Tests (Playwright)\r\n\r\n**Special orchestration** for multi-user and first-user scenarios:\r\n\r\n```bash\r\npnpm test:e2e:first-user\r\n\r\npnpm test:e2e:standard\r\n\r\n\r\n### Before Starting\r\n\r\n**Major changes require discussion first**:\r\n- New UI components\r\n- New API endpoints\r\n- External service integrations\r\n- Breaking changes\r\n\r\n**No prior approval needed**:\r\n- Bug fixes\r\n- Documentation improvements\r\n- Minor refactoring\r\n\r\n### Pull Request Standards\r\n\r\n**Title format** (Conventional Commits):\r\n```\r\nfeat: Add realtime voice chat\r\nfix: Resolve MCP tool streaming error\r\nchore: Update dependencies\r\ndocs: Add OAuth setup guide\r\n```\r\n\r\n**Prefixes**: `feat:`, `fix:`, `chore:`, `docs:`, `style:`, `refactor:`, `test:`, `perf:`, `build:`\r\n\r\n**Visual documentation required**:\r\n- Before/after screenshots for UI changes\r\n- Screen recordings for interactive features\r\n- Mobile + desktop views for responsive updates\r\n\r\n**Description should explain**:\r\n1. What changed\r\n2. Why it changed\r\n3. How you tested it\r\n\r\n### Pre-Submission Checklist\r\n\r\n```bash\r\n\r\nThis skill prevents **8** documented issues:\r\n\r\n### Issue #1: Forgetting Auth Checks in Server Actions\r\n\r\n**Error**: Unauthorized users accessing protected actions\r\n**Why It Happens**: Manual auth implementation is inconsistent\r\n**Prevention**: Use `validatedActionWithUser` or `validatedActionWithAdminPermission`\r\n\r\n```typescript\r\n// ❌ BAD: Manual auth check\r\nexport async function updateProfile(data: ProfileData) {\r\n  const session = await getSession()\r\n  if (!session) throw new Error(\"Unauthorized\")\r\n  // ... rest of logic\r\n}\r\n\r\n// ✅ GOOD: Use validator\r\nexport const updateProfile = validatedActionWithUser(\r\n  profileSchema,\r\n  async (data, formData, user) => {\r\n    // user is guaranteed to exist, auto-error handling\r\n  }\r\n)\r\n```\r\n\r\n### Issue #2: Tool Type Mismatches\r\n\r\n**Error**: Runtime type errors when executing tools\r\n**Why It Happens**: Not checking tool type before execution\r\n**Prevention**: Use branded type tags for runtime narrowing\r\n\r\n```typescript\r\n// ❌ BAD: Assuming tool type\r\nconst result = await executeMcpTool(tool)\r\n\r\n// ✅ GOOD: Check tool type\r\nif (VercelAIMcpToolTag.isMaybe(tool)) {\r\n  const result = await executeMcpTool(tool)\r\n} else if (VercelAIWorkflowToolTag.isMaybe(tool)) {\r\n  const result = await executeWorkflowTool(tool)\r\n}\r\n```\r\n\r\n### Issue #3: FormData Parsing Errors\r\n\r\n**Error**: Inconsistent error handling for form submissions\r\n**Why It Happens**: Manual FormData parsing with ad-hoc validation\r\n**Prevention**: Validators handle parsing automatically\r\n\r\n```typescript\r\n// ❌ BAD: Manual parsing\r\nconst name = formData.get(\"name\") as string\r\nif (!name) throw new Error(\"Name required\")\r\n\r\n// ✅ GOOD: Validator with Zod\r\nconst schema = z.object({ name: z.string().min(1) })\r\nexport const action = validatedAction(schema, async (data) => {\r\n  // data.name is validated and typed\r\n})\r\n```\r\n\r\n### Issue #4: Cross-Field Validation Issues\r\n\r\n**Error**: Password mismatch validation not working\r\n**Why It Happens**: Separate validation for related fields\r\n**Prevention**: Use Zod `superRefine`\r\n\r\n```typescript\r\n// ❌ BAD: Separate checks\r\nif (data.password !== data.confirmPassword) { /* error */ }\r\n\r\n// ✅ GOOD: Zod superRefine\r\nconst schema = z.object({\r\n  password: z.string(),\r\n  confirmPassword: z.string()\r\n}).superRefine((data, ctx) => {\r\n  if (data.password !== data.confirmPassword) {\r\n    ctx.addIssue({\r\n      path: [\"confirmPassword\"],\r\n      message: \"Passwords must match\"\r\n    })\r\n  }\r\n})\r\n```\r\n\r\n### Issue #5: Workflow State Inconsistency\r\n\r\n**Error**: Zustand state updates not triggering re-renders\r\n**Why It Happens**: Deep mutation of nested workflow state\r\n**Prevention**: Use shallow updates\r\n\r\n```typescript\r\n// ❌ BAD: Deep mutation\r\nstore.workflow.nodes[0].status = \"complete\"\r\n\r\n// ✅ GOOD: Shallow update\r\nset(state => ({\r\n  workflow: {\r\n    ...state.workflow,\r\n    nodes: state.workflow.nodes.map((node, i) =>\r\n      i === 0 ? { ...node, status: \"complete\" } : node\r\n    )\r\n  }\r\n}))\r\n```\r\n\r\n### Issue #6: Missing E2E Test Setup\r\n\r\n**Error**: E2E tests failing on clean database\r\n**Why It Happens**: Running standard tests before first-user setup\r\n**Prevention**: Use correct test commands\r\n\r\n```bash\r\npnpm test:e2e:standard\r\n\r\npnpm test:e2e\r\n```\r\n\r\n### Issue #7: Environment Config Mistakes\r\n\r\n**Error**: Missing required environment variables causing crashes\r\n**Why It Happens**: Not copying `.env.example` to `.env`\r\n**Prevention**: Auto-generated `.env` on `pnpm i`\r\n\r\n```bash\r\npnpm i\r\n\r\n```\r\n\r\n### Issue #8: Incorrect Commit Message Format\r\n\r\n**Error**: CI/CD failures due to non-conventional commit format\r\n**Why It Happens**: Not following Conventional Commits standard\r\n**Prevention**: Use prefix + colon format\r\n\r\n```bash\r\ngit commit -m \"added feature\"\r\ngit commit -m \"fix bug\"",
  "name": "better-chatbot",
  "id": "better-chatbot",
  "sections": {
    "Dependencies": "**Required**:\r\n- next@15.3.2 - Framework\r\n- ai@5.0.82 - Vercel AI SDK\r\n- better-auth@1.3.34 - Authentication\r\n- drizzle-orm@0.41.0 - Database ORM\r\n- @modelcontextprotocol/sdk@1.20.2 - MCP support\r\n- zod@3.24.2 - Validation\r\n- zustand@5.0.3 - State management\r\n\r\n**Testing**:\r\n- vitest@3.2.4 - Unit tests\r\n- @playwright/test@1.56.1 - E2E tests\r\n\r\n---",
    "Contribution Guidelines": "pnpm check           # Lint + type-check + tests\r\npnpm test:e2e        # E2E tests (if applicable)\r\n```\r\n\r\n- [ ] Tests added for new features/bug fixes\r\n- [ ] Visual documentation included (if UI change)\r\n- [ ] Conventional Commit title\r\n- [ ] Description explains what, why, testing\r\n\r\n---",
    "Complete Setup Checklist": "When contributing to better-chatbot:\r\n\r\n- [ ] Fork and clone repository\r\n- [ ] Run `pnpm i` (auto-generates `.env`)\r\n- [ ] Configure required env vars (DATABASE_URL, LLM_API_KEY)\r\n- [ ] Run `pnpm dev` and verify it starts\r\n- [ ] Create feature branch\r\n- [ ] Add unit tests for new features\r\n- [ ] Run `pnpm check` before PR\r\n- [ ] Run `pnpm test:e2e` if touching critical flows\r\n- [ ] Include visual docs (screenshots/recordings)\r\n- [ ] Use Conventional Commit title\r\n- [ ] Squash merge when approved\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/AGENTS.md` for detailed guidelines\r\n2. Check `references/CONTRIBUTING.md` for PR process\r\n3. Check official docs: https://github.com/cgoinglove/better-chatbot\r\n4. Ensure PostgreSQL and LLM API key are configured\r\n\r\n---\r\n\r\n**Token Efficiency**: ~60% savings | **Errors Prevented**: 8 | **Production Verified**: Yes",
    "Known Issues Prevention": "git commit -m \"feat: add MCP tool streaming\"\r\ngit commit -m \"fix: resolve auth redirect loop\"\r\n```\r\n\r\n---",
    "Overview": "**better-chatbot** is an open-source AI chatbot platform for individuals and teams, built with Next.js 15 and Vercel AI SDK v5. It combines multi-model AI support (OpenAI, Anthropic, Google, xAI, Ollama, OpenRouter) with advanced features like MCP (Model Context Protocol) tool integration, visual workflow builder, realtime voice assistant, and team collaboration.\r\n\r\n**This skill teaches Claude the project-specific conventions and patterns** used in better-chatbot to ensure contributions follow established standards and avoid common pitfalls.\r\n\r\n---",
    "Production Example": "This skill is based on **better-chatbot** production standards:\r\n- **Live**: https://betterchatbot.vercel.app\r\n- **Tests**: 48+ E2E tests passing\r\n- **Errors**: 0 (all 8 known issues prevented)\r\n- **Validation**: ✅ Multi-user scenarios, workflow execution, MCP tools\r\n\r\n---",
    "Component & Design Philosophy": "### Organization by Feature\r\n\r\n**Location**: `src/components/`\r\n\r\n```\r\ncomponents/\r\n├── ui/              → shadcn/ui primitives\r\n├── layouts/         → App structure\r\n├── agent/           → Agent-specific\r\n├── workflow/        → Workflow editor\r\n├── tool-invocation/ → Tool result rendering\r\n└── *.tsx            → Shared components\r\n```\r\n\r\n**Principle**: Group by feature, not by type\r\n\r\n### Compound Component Pattern\r\n\r\n**Example**: `message.tsx` + `message-parts.tsx`\r\n\r\n**Philosophy**: Break complex components into composable parts\r\n\r\n```typescript\r\n// message.tsx exports multiple related components\r\nexport function PreviewMessage({ message }) { ... }\r\nexport function ErrorMessage({ error }) { ... }\r\n\r\n// message-parts.tsx handles polymorphic content\r\nexport function MessageParts({ parts }) {\r\n  return parts.map(part => {\r\n    if (isToolUIPart(part)) return <ToolInvocation part={part} />;\r\n    if (part.type === 'text') return <Markdown text={part.text} />;\r\n    // ... other types\r\n  });\r\n}\r\n```\r\n\r\n### Client Component Wrapper Pattern\r\n\r\n**Example**: `chat-bot.tsx`\r\n\r\n**Structure**:\r\n```typescript\r\nexport default function ChatBot({ threadId, initialMessages }) {\r\n  // 1. State management (Zustand)\r\n  const [model, toolChoice] = appStore(useShallow(state => [...]));\r\n\r\n  // 2. Vercel AI SDK hook\r\n  const { messages, append, status } = useChat({\r\n    id: threadId,\r\n    initialMessages,\r\n    body: { chatModel: model, toolChoice },\r\n  });\r\n\r\n  // 3. Render orchestration\r\n  return (\r\n    <>\r\n      <ChatGreeting />\r\n      <MessageList messages={messages} />\r\n      <PromptInput onSubmit={append} />\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n**Why**: Top-level orchestrates, delegates rendering to specialized components\r\n\r\n### Tool Result Rendering Separation\r\n\r\n**Key Architecture Decision**:\r\n- Tool **execution** lives in `lib/ai/tools/`\r\n- Tool **rendering** lives in `components/tool-invocation/`\r\n\r\n**Example**:\r\n```typescript\r\n// Server-side (lib/ai/tools/create-table.ts)\r\nexecute: async (params) => \"Success\"\r\n\r\n// Client-side (components/tool-invocation/interactive-table.tsx)\r\nexport function InteractiveTable({ part }) {\r\n  const { columns, data } = part.input;\r\n  return <DataTable columns={columns} data={data} />;\r\n}\r\n```\r\n\r\n**Benefits**:\r\n- Clear separation of concerns\r\n- Easier testing\r\n- Client can be rich/interactive without server complexity\r\n\r\n---",
    "Tool System Deep Dive": "### Three-Tier Tool Architecture\r\n\r\n**Design Goal**: Balance extensibility (MCP), composability (workflows), and batteries-included (default tools)\r\n\r\n```\r\nTier 1: MCP Tools (External)\r\n  ↓ Can be used in\r\nTier 2: Workflow Tools (User-Created)\r\n  ↓ Can be used in\r\nTier 3: Default Tools (Built-In)\r\n```\r\n\r\n### Tier 1: MCP Tools (External Integrations)\r\n\r\n**Location**: `src/lib/ai/mcp/`\r\n\r\n**Philosophy**: Model Context Protocol servers become first-class tools\r\n\r\n**Manager Pattern**:\r\n```typescript\r\n// mcp-manager.ts - Singleton for all MCP clients\r\nexport const mcpClientsManager = globalThis.__mcpClientsManager__;\r\n\r\n// API:\r\nmcpClientsManager.init()              // Initialize configured servers\r\nmcpClientsManager.getClients()        // Get connected clients\r\nmcpClientsManager.tools()             // Get all tools as Vercel AI SDK tools\r\nmcpClientsManager.toolCall(serverId, toolName, args)  // Execute tool\r\n```\r\n\r\n**Why Global Singleton?**\r\n- Next.js dev hot-reloading → reconnecting MCP servers on every change is expensive\r\n- Persists across HMR updates\r\n- Production: only one instance needed\r\n\r\n**Tool Wrapping**:\r\n```typescript\r\n// MCP tools are tagged with metadata for filtering\r\ntype VercelAIMcpTool = Tool & {\r\n  _mcpServerId: string;\r\n  _originToolName: string;\r\n  _toolName: string; // Transformed for AI SDK\r\n};\r\n\r\n// Branded type for runtime checking\r\nVercelAIMcpToolTag.create(tool)\r\n```\r\n\r\n### Tier 2: Workflow Tools (Visual Composition)\r\n\r\n**Location**: `src/lib/ai/workflow/`\r\n\r\n**Philosophy**: Visual workflows become callable tools via `@workflow_name`\r\n\r\n**Node Types**:\r\n```typescript\r\nenum NodeKind {\r\n  Input = \"input\",      // Entry point\r\n  LLM = \"llm\",          // AI reasoning\r\n  Tool = \"tool\",        // Call MCP/default tools\r\n  Http = \"http\",        // HTTP requests\r\n  Template = \"template\",// Text processing\r\n  Condition = \"condition\", // Branching logic\r\n  Output = \"output\",    // Exit point\r\n}\r\n```\r\n\r\n**Execution with Streaming**:\r\n```typescript\r\n// Workflows stream intermediate results\r\nexecutor.subscribe((e) => {\r\n  if (e.eventType == \"NODE_START\") {\r\n    dataStream.write({\r\n      type: \"tool-output-available\",\r\n      toolCallId,\r\n      output: { status: \"running\", node: e.nodeId }\r\n    });\r\n  }\r\n  if (e.eventType == \"NODE_END\") {\r\n    dataStream.write({\r\n      type: \"tool-output-available\",\r\n      toolCallId,\r\n      output: { status: \"complete\", result: e.result }\r\n    });\r\n  }\r\n});\r\n```\r\n\r\n**Key Feature**: Live progress updates in chat UI\r\n\r\n### Tier 3: Default Tools (Built-In Capabilities)\r\n\r\n**Location**: `src/lib/ai/tools/`\r\n\r\n**Categories**:\r\n```typescript\r\nexport const APP_DEFAULT_TOOL_KIT = {\r\n  [AppDefaultToolkit.Visualization]: {\r\n    CreatePieChart, CreateBarChart, CreateLineChart,\r\n    CreateTable, CreateTimeline\r\n  },\r\n  [AppDefaultToolkit.WebSearch]: {\r\n    WebSearch, WebContent\r\n  },\r\n  [AppDefaultToolkit.Http]: {\r\n    Http\r\n  },\r\n  [AppDefaultToolkit.Code]: {\r\n    JavascriptExecution, PythonExecution\r\n  },\r\n};\r\n```\r\n\r\n**Tool Implementation Pattern**:\r\n```typescript\r\n// Execution returns \"Success\", rendering happens client-side\r\nexport const createTableTool = createTool({\r\n  description: \"Create an interactive table...\",\r\n  inputSchema: z.object({\r\n    title: z.string(),\r\n    columns: z.array(...),\r\n    data: z.array(...)\r\n  }),\r\n  execute: async () => \"Success\"\r\n});\r\n\r\n// Client-side rendering in components/tool-invocation/\r\nexport function InteractiveTable({ part }) {\r\n  const args = part.input;\r\n  return <DataTable columns={args.columns} data={args.data} />;\r\n}\r\n```\r\n\r\n**Why Separation?**\r\n- Server: Pure data/business logic\r\n- Client: Rich visualization/interaction\r\n- Easier testing, better performance\r\n\r\n### Tool Lifecycle\r\n\r\n```\r\n1. Request → /api/chat/route.ts\r\n2. Parse mentions (@tool, @workflow, @agent)\r\n3. Load tools based on mentions/permissions:\r\n   - loadMcpTools() → filters by mentions or allowedMcpServers\r\n   - loadWorkFlowTools() → converts workflows to tools\r\n   - loadAppDefaultTools() → filters default toolkits\r\n4. Merge all tools into single Record<string, Tool>\r\n5. Handle toolChoice mode:\r\n   - \"manual\" → LLM proposes, user confirms\r\n   - \"auto\" → full execution\r\n   - \"none\" → no tools loaded\r\n6. Pass tools to streamText()\r\n7. Stream results back\r\n```\r\n\r\n### Convention-Based Extension\r\n\r\n**Adding a new tool type is simple**:\r\n1. Add enum to `AppDefaultToolkit`\r\n2. Implement tool with `createTool()`\r\n3. Add to `APP_DEFAULT_TOOL_KIT`\r\n4. Tool automatically available via `@toolname`\r\n\r\n---",
    "Server Action Validators & Coding Standards": "### Server Action Validators (`lib/action-utils.ts`)\r\n\r\nCentralized pattern for validated, permission-gated server actions:\r\n\r\n```typescript\r\n// Pattern 1: Simple validation\r\nvalidatedAction(schema, async (data, formData) => { ... })\r\n\r\n// Pattern 2: With user context (auto-auth, auto-error handling)\r\nvalidatedActionWithUser(schema, async (data, formData, user) => { ... })\r\n\r\n// Pattern 3: Permission-based (admin, user-manage)\r\nvalidatedActionWithAdminPermission(schema, async (data, formData, session) => { ... })\r\n```\r\n\r\n**Prevents**:\r\n- Forgetting auth checks ✓\r\n- Inconsistent validation ✓\r\n- FormData parsing errors ✓\r\n- Non-standard error responses ✓\r\n\r\n**2. Tool Abstraction System**\r\nUnified interface for multiple tool types using branded type tags:\r\n\r\n```typescript\r\n// Branded types for runtime type narrowing\r\nVercelAIMcpToolTag.create(tool)        // Brand as MCP tool\r\nVercelAIWorkflowToolTag.isMaybe(tool)  // Check if Workflow tool\r\n\r\n// Single handler for multiple tool types\r\nif (VercelAIWorkflowToolTag.isMaybe(tool)) {\r\n  // Workflow-specific logic\r\n} else if (VercelAIMcpToolTag.isMaybe(tool)) {\r\n  // MCP-specific logic\r\n}\r\n```\r\n\r\n**Tool Types**:\r\n- **MCP Tools**: Model Context Protocol integrations\r\n- **Workflow Tools**: Visual DAG-based workflows\r\n- **Default Tools**: Built-in capabilities (search, code execution, etc.)\r\n\r\n**3. Workflow Execution Engine**\r\nDAG-based workflow system with real-time streaming:\r\n- Streams node execution progress via `dataStream.write()`\r\n- Tracks: status, input/output, errors, timing\r\n- Token optimization: history stored without detailed results\r\n\r\n**4. State Management**\r\nZustand stores with shallow comparison for workflows and app config.\r\n\r\n---",
    "Development Workflow": "pnpm check                  # Run lint + type-check + tests\r\n```\r\n\r\n### Environment Setup\r\n\r\n- Copy `.env.example` to `.env` (auto-generated on `pnpm i`)\r\n- Required: PostgreSQL connection, at least one LLM API key\r\n- Optional: OAuth providers (Google, GitHub, Microsoft), Redis, Vercel Blob\r\n\r\n### Branch Strategy\r\n\r\n- **Main**: Production-ready code\r\n- **Feature branches**: `feat/feature-name` or `fix/bug-name`\r\n- **Squash merge**: Single commit per PR for clean history\r\n\r\n---",
    "API Architecture & Design Patterns": "### Route Structure Philosophy\r\n\r\n**Convention**: RESTful resources with Next.js App Router conventions\r\n\r\n```\r\n/api/[resource]/route.ts         → GET/POST collection endpoints\r\n/api/[resource]/[id]/route.ts    → GET/PUT/DELETE item endpoints\r\n/api/[resource]/actions.ts       → Server actions (mutations)\r\n```\r\n\r\n### Standard Route Handler Pattern\r\n\r\n**Location**: `src/app/api/`\r\n\r\n**Template structure**:\r\n```typescript\r\nexport async function POST(request: Request) {\r\n  try {\r\n    // 1. Parse and validate request body with Zod\r\n    const json = await request.json();\r\n    const parsed = zodSchema.parse(json);\r\n\r\n    // 2. Check authentication\r\n    const session = await getSession();\r\n    if (!session?.user.id) return new Response(\"Unauthorized\", { status: 401 });\r\n\r\n    // 3. Check authorization (ownership/permissions)\r\n    if (resource.userId !== session.user.id) return new Response(\"Forbidden\", { status: 403 });\r\n\r\n    // 4. Load/compose dependencies (tools, context, etc.)\r\n    const tools = await loadMcpTools({ mentions, allowedMcpServers });\r\n\r\n    // 5. Execute with streaming if applicable\r\n    const stream = createUIMessageStream({ execute: async ({ writer }) => { ... } });\r\n\r\n    // 6. Return response\r\n    return createUIMessageStreamResponse({ stream });\r\n  } catch (error) {\r\n    logger.error(error);\r\n    return Response.json({ message: error.message }, { status: 500 });\r\n  }\r\n}\r\n```\r\n\r\n### Shared Business Logic Pattern\r\n\r\n**Key Insight**: Extract complex orchestration logic into shared utilities\r\n\r\n**Example**: `src/app/api/chat/shared.chat.ts`\r\n\r\nThis file demonstrates how to handle:\r\n- Tool loading (`loadMcpTools`, `loadWorkFlowTools`, `loadAppDefaultTools`)\r\n- Filtering and composition (`filterMCPToolsByMentions`, `excludeToolExecution`)\r\n- System prompt building (`mergeSystemPrompt`)\r\n- Manual tool execution handling\r\n\r\n**Pattern**:\r\n```typescript\r\n// Shared utility function\r\nexport const loadMcpTools = (opt?) =>\r\n  safe(() => mcpClientsManager.tools())\r\n    .map((tools) => {\r\n      if (opt?.mentions?.length) {\r\n        return filterMCPToolsByMentions(tools, opt.mentions);\r\n      }\r\n      return filterMCPToolsByAllowedMCPServers(tools, opt?.allowedMcpServers);\r\n    })\r\n    .orElse({} as Record<string, VercelAIMcpTool>);\r\n\r\n// Used in multiple routes\r\n// - /api/chat/route.ts\r\n// - /api/chat/temporary/route.ts\r\n// - /api/workflow/[id]/execute/route.ts\r\n```\r\n\r\n**Why**: DRY principle, single source of truth, consistent behavior\r\n\r\n### Defensive Programming with safe()\r\n\r\n**Library**: `ts-safe` for functional error handling\r\n\r\n**Philosophy**: Never crash the chat - degrade features gracefully\r\n\r\n```typescript\r\n// Returns empty object on failure, chat continues\r\nconst MCP_TOOLS = await safe()\r\n  .map(errorIf(() => !isToolCallAllowed && \"Not allowed\"))\r\n  .map(() => loadMcpTools({ mentions, allowedMcpServers }))\r\n  .orElse({});  // Graceful fallback\r\n```\r\n\r\n### Streaming-First Architecture\r\n\r\n**Pattern**: Use Vercel AI SDK streaming utilities\r\n\r\n```typescript\r\n// In route handler\r\nconst stream = createUIMessageStream({\r\n  execute: async ({ writer }) => {\r\n    // Stream intermediate results\r\n    writer.write({ type: \"text\", content: \"Processing...\" });\r\n\r\n    // Execute with streaming\r\n    const result = await streamText({\r\n      model,\r\n      messages,\r\n      tools,\r\n      onChunk: (chunk) => writer.write({ type: \"text-delta\", delta: chunk })\r\n    });\r\n\r\n    return { output: result };\r\n  }\r\n});\r\n\r\nreturn createUIMessageStreamResponse({ stream });\r\n```\r\n\r\n**Why**: Live feedback, better UX, handles long-running operations\r\n\r\n---",
    "UX Patterns & @Mention System": "### The @Mention Philosophy\r\n\r\n**Core Design Principle**: Every feature is instantly accessible via `@mentions` - no digging through menus.\r\n\r\n**Why This Matters**: Users can compose features on-the-fly without context switching.\r\n\r\n### Three Types of @Mentions\r\n\r\n#### 1. @tool (Default Tools)\r\n**Format**: `@tool(\"tool_name\")`\r\n\r\n**Examples**:\r\n```\r\n@tool(\"web-search\") find recent AI papers\r\n@tool(\"create-table\") show sales data\r\n@tool(\"python-execution\") calculate fibonacci\r\n```\r\n\r\n**How It Works**:\r\n- Parsed from message on server\r\n- Loads corresponding tools from `APP_DEFAULT_TOOL_KIT`\r\n- LLM decides when to invoke based on prompt\r\n\r\n**Use Case**: Built-in capabilities (search, visualization, code execution)\r\n\r\n#### 2. @mcp (MCP Server Tools)\r\n**Format**: `@mcp(\"server_name\")` or specific tool `@mcp(\"server_name:tool_name\")`\r\n\r\n**Examples**:\r\n```\r\n@mcp(\"github\") create an issue in my repo\r\n@mcp(\"playwright\") navigate to google.com\r\n@mcp(\"slack:send-message\") post update to #general\r\n```\r\n\r\n**How It Works**:\r\n- Mentions filter which MCP servers/tools to load\r\n- Reduces token usage (only relevant tools sent to LLM)\r\n- MCP manager handles connection and execution\r\n\r\n**Use Case**: External integrations (GitHub, Slack, databases, etc.)\r\n\r\n#### 3. @workflow (Custom Workflows)\r\n**Format**: `@workflow(\"workflow_name\")`\r\n\r\n**Examples**:\r\n```\r\n@workflow(\"customer-onboarding\") process new signup\r\n@workflow(\"data-pipeline\") transform and analyze CSV\r\n```\r\n\r\n**How It Works**:\r\n- Workflows are converted to callable tools\r\n- LLM sees workflow as a single tool with description\r\n- Execution streams intermediate node results\r\n\r\n**Use Case**: Multi-step automations, business processes\r\n\r\n#### 4. @agent (Agent Personas)\r\n**Format**: Select agent from dropdown (not typed in message)\r\n\r\n**How It Works**:\r\n- Agent's `instructions.mentions` auto-inject tools/workflows\r\n- System prompt prepended to conversation\r\n- Presets can override model/temperature\r\n\r\n**Use Case**: Role-specific contexts (coding assistant, data analyst, etc.)\r\n\r\n### Tool Choice Modes\r\n\r\n**Context**: User selects mode from dropdown\r\n\r\n#### Auto Mode (Default)\r\n- LLM can invoke tools autonomously\r\n- Multiple tool calls per message\r\n- Best for: Automation, workflows, exploration\r\n\r\n**Example Flow**:\r\n```\r\nUser: @tool(\"web-search\") find AI news, then @tool(\"create-table\") summarize\r\n→ LLM searches → formats results → creates table → returns message\r\n```\r\n\r\n#### Manual Mode\r\n- LLM proposes tool calls, waits for user approval\r\n- User sees \"Tool: web-search\" with args, clicks \"Execute\"\r\n- Best for: Sensitive operations, learning, debugging\r\n\r\n**Example Flow**:\r\n```\r\nUser: @mcp(\"github\") create issue\r\n→ LLM proposes: create_issue(repo=\"...\", title=\"...\", body=\"...\")\r\n→ User reviews and clicks \"Execute\"\r\n→ Tool runs → result shown\r\n```\r\n\r\n#### None Mode\r\n- No tools loaded (text-only conversation)\r\n- Reduces latency and token usage\r\n- Best for: Brainstorming, explanations, simple queries\r\n\r\n### Preset System\r\n\r\n**What Are Presets?**\r\n- Quick configurations for common scenarios\r\n- Stored per-user\r\n- Can override: model, temperature, toolChoice, allowed MCP servers\r\n\r\n**Example Use Cases**:\r\n```\r\nPreset: \"Quick Chat\"\r\n- Model: GPT-4o-mini (fast)\r\n- Tools: None\r\n- Use for: Rapid Q&A\r\n\r\nPreset: \"Research Assistant\"\r\n- Model: Claude Sonnet 4.5\r\n- Tools: @tool(\"web-search\"), @mcp(\"wikipedia\")\r\n- Use for: Deep research\r\n\r\nPreset: \"Code Review\"\r\n- Model: GPT-5\r\n- Tools: @mcp(\"github\"), @tool(\"python-execution\")\r\n- Use for: Reviewing PRs with tests\r\n```\r\n\r\n**How To Create**:\r\n1. Configure chat (model, tools, settings)\r\n2. Click \"Save as Preset\"\r\n3. Name it\r\n4. Select from dropdown in future chats\r\n\r\n### User Journey Examples\r\n\r\n#### Beginner: First-Time User\r\n```\r\n1. Start chat (no @mentions) → Default tools available\r\n2. Ask: \"Search for news about AI\"\r\n3. LLM automatically uses @tool(\"web-search\")\r\n4. User sees: Search results → Formatted answer\r\n5. Learns: Tools work automatically in Auto mode\r\n```\r\n\r\n#### Intermediate: Using Workflows\r\n```\r\n1. Create workflow in Workflow Builder:\r\n   Input → Web Search → LLM Summary → Output\r\n2. Save as \"research-workflow\"\r\n3. In chat: \"@workflow('research-workflow') AI trends 2025\"\r\n4. Sees: Live progress per node\r\n5. Gets: Formatted research report\r\n```\r\n\r\n#### Advanced: Agent + MCP + Workflows\r\n```\r\n1. Create agent \"DevOps Assistant\"\r\n2. Agent instructions include: @mcp(\"github\"), @workflow(\"deploy-pipeline\")\r\n3. Select agent from dropdown\r\n4. Chat: \"Deploy latest commit to staging\"\r\n5. Agent: Uses GitHub MCP → triggers deploy workflow → monitors → reports\r\n```\r\n\r\n### Design Patterns Developers Should Follow\r\n\r\n**1. Discoverability**\r\n- Every tool should have clear description (shown in LLM context)\r\n- Use semantic names (`create-table` not `tool-42`)\r\n\r\n**2. Composability**\r\n- Tools should be single-purpose\r\n- Workflows compose tools\r\n- Agents compose workflows + tools + context\r\n\r\n**3. Progressive Disclosure**\r\n- Beginners: Auto mode, no @mentions (use defaults)\r\n- Intermediate: Explicit @tool/@mcp mentions\r\n- Advanced: Workflows, agents, presets\r\n\r\n**4. Feedback**\r\n- Streaming for long operations\r\n- Progress updates for workflows\r\n- Clear error messages with solutions\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ Use `validatedActionWithUser` or `validatedActionWithAdminPermission` for server actions\r\n✅ Check tool types with branded type tags before execution\r\n✅ Use Zod `superRefine` for cross-field validation\r\n✅ Add unit tests (happy path + one failure mode)\r\n✅ Run `pnpm check` before PR submission\r\n✅ Include visual documentation for UI changes\r\n✅ Use Conventional Commit format for PR titles\r\n✅ Run E2E tests when touching critical flows\r\n\r\n### Never Do\r\n\r\n❌ Implement server actions without auth validators\r\n❌ Assume tool type without runtime check\r\n❌ Parse FormData manually (use validators)\r\n❌ Mutate Zustand state directly (use shallow updates)\r\n❌ Skip first-user tests on clean database\r\n❌ Commit without running `pnpm check`\r\n❌ Submit PR without visual docs (if UI change)\r\n❌ Use non-conventional commit format\r\n\r\n---",
    "Project Architecture": "### Directory Structure\r\n\r\n```\r\nbetter-chatbot/\r\n├── src/\r\n│   ├── app/                    # Next.js App Router + API routes\r\n│   │   ├── api/[resource]/     # RESTful API organized by domain\r\n│   │   ├── (auth)/             # Auth route group\r\n│   │   ├── (chat)/             # Chat UI route group\r\n│   │   └── store/              # Zustand stores\r\n│   ├── components/             # UI components by domain\r\n│   │   ├── layouts/\r\n│   │   ├── agent/\r\n│   │   ├── chat/\r\n│   │   └── export/\r\n│   ├── lib/                    # Core logic and utilities\r\n│   │   ├── action-utils.ts     # Server action validators (CRITICAL)\r\n│   │   ├── ai/                 # AI integration (models, tools, MCP, speech)\r\n│   │   ├── db/                 # Database (Drizzle ORM + repositories)\r\n│   │   ├── validations/        # Zod schemas\r\n│   │   └── [domain]/           # Domain-specific helpers\r\n│   ├── hooks/                  # Custom React hooks\r\n│   │   ├── queries/            # Data fetching hooks\r\n│   │   └── use-*.ts\r\n│   └── types/                  # TypeScript types by domain\r\n├── tests/                      # E2E tests (Playwright)\r\n├── docs/                       # Setup guides and tips\r\n├── docker/                     # Docker configs\r\n└── drizzle/                    # Database migrations\r\n```\r\n\r\n---",
    "Testing Patterns": "pnpm test:e2e\r\n```\r\n\r\n**Test project dependencies** ensure sequenced execution:\r\n1. Clean database\r\n2. Run first-user signup + role verification\r\n3. Run standard multi-user tests\r\n\r\n**Shared auth states** across test runs to avoid re-login.\r\n\r\n**Seed/cleanup scripts** for deterministic testing.\r\n\r\n---",
    "Practical Templates": "### Template: Adding a New Default Tool\r\n\r\n```typescript\r\n// 1. Define in lib/ai/tools/[category]/[tool-name].ts\r\nimport { tool as createTool } from \"ai\";\r\nimport { z } from \"zod\";\r\n\r\nexport const myNewTool = createTool({\r\n  description: \"Clear description for LLM to understand when to use this\",\r\n  inputSchema: z.object({\r\n    param: z.string().describe(\"What this parameter does\"),\r\n  }),\r\n  execute: async (params) => {\r\n    // For visualization tools: return \"Success\"\r\n    // For data tools: return actual data\r\n    return \"Success\";\r\n  },\r\n});\r\n\r\n// 2. Add to lib/ai/tools/tool-kit.ts\r\nimport { DefaultToolName } from \"./index\";\r\nimport { myNewTool } from \"./[category]/[tool-name]\";\r\n\r\nexport enum DefaultToolName {\r\n  // ... existing\r\n  MyNewTool = \"my_new_tool\",\r\n}\r\n\r\nexport const APP_DEFAULT_TOOL_KIT = {\r\n  [AppDefaultToolkit.MyCategory]: {\r\n    [DefaultToolName.MyNewTool]: myNewTool,\r\n  },\r\n};\r\n\r\n// 3. Create rendering in components/tool-invocation/my-tool-invocation.tsx\r\nexport function MyToolInvocation({ part }: { part: ToolUIPart }) {\r\n  const args = part.input as z.infer<typeof myNewTool.inputSchema>;\r\n  return <div>{/* Render based on args */}</div>;\r\n}\r\n\r\n// 4. Add to components/tool-invocation/index.tsx switch\r\nif (toolName === DefaultToolName.MyTool) {\r\n  return <MyToolInvocation part={part} />;\r\n}\r\n```\r\n\r\n### Template: Adding a New API Route\r\n\r\n```typescript\r\n// src/app/api/[resource]/route.ts\r\nimport { getSession } from \"auth/server\";\r\nimport { [resource]Repository } from \"lib/db/repository\";\r\nimport { z } from \"zod\";\r\n\r\nconst querySchema = z.object({\r\n  limit: z.coerce.number().default(10),\r\n});\r\n\r\nexport async function GET(request: Request) {\r\n  // 1. Auth check\r\n  const session = await getSession();\r\n  if (!session?.user.id) {\r\n    return new Response(\"Unauthorized\", { status: 401 });\r\n  }\r\n\r\n  // 2. Parse & validate\r\n  try {\r\n    const url = new URL(request.url);\r\n    const params = querySchema.parse(Object.fromEntries(url.searchParams));\r\n\r\n    // 3. Use repository\r\n    const data = await [resource]Repository.selectByUserId(\r\n      session.user.id,\r\n      params.limit\r\n    );\r\n\r\n    return Response.json(data);\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return Response.json(\r\n        { error: \"Invalid params\", details: error.message },\r\n        { status: 400 }\r\n      );\r\n    }\r\n    console.error(\"Failed:\", error);\r\n    return new Response(\"Internal Server Error\", { status: 500 });\r\n  }\r\n}\r\n\r\nexport async function POST(request: Request) {\r\n  const session = await getSession();\r\n  if (!session?.user.id) {\r\n    return new Response(\"Unauthorized\", { status: 401 });\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n    const data = createSchema.parse(body);\r\n\r\n    const item = await [resource]Repository.insert({\r\n      ...data,\r\n      userId: session.user.id,\r\n    });\r\n\r\n    return Response.json(item);\r\n  } catch (error) {\r\n    if (error instanceof z.ZodError) {\r\n      return Response.json({ error: \"Invalid input\" }, { status: 400 });\r\n    }\r\n    return Response.json({ error: \"Internal error\" }, { status: 500 });\r\n  }\r\n}\r\n```\r\n\r\n### Template: Adding a New Repository\r\n\r\n```typescript\r\n// 1. Define interface in src/types/[domain].ts\r\nexport type MyRepository = {\r\n  selectById(id: string): Promise<MyType | null>;\r\n  selectByUserId(userId: string, limit?: number): Promise<MyType[]>;\r\n  insert(data: InsertType): Promise<MyType>;\r\n  update(id: string, data: Partial<InsertType>): Promise<MyType>;\r\n  delete(id: string): Promise<void>;\r\n};\r\n\r\n// 2. Add table to src/lib/db/pg/schema.pg.ts\r\nexport const MyTable = pgTable(\"my_table\", {\r\n  id: uuid(\"id\").primaryKey().defaultRandom(),\r\n  userId: uuid(\"user_id\").references(() => UserTable.id).notNull(),\r\n  name: text(\"name\").notNull(),\r\n  createdAt: timestamp(\"created_at\").defaultNow().notNull(),\r\n}, (table) => ({\r\n  userIdIdx: index(\"my_table_user_id_idx\").on(table.userId),\r\n}));\r\n\r\n// 3. Implement in src/lib/db/pg/repositories/my-repository.pg.ts\r\nimport { pgDb as db } from \"../db.pg\";\r\nimport { MyTable } from \"../schema.pg\";\r\nimport { eq, desc } from \"drizzle-orm\";\r\n\r\nexport const pgMyRepository: MyRepository = {\r\n  selectById: async (id) => {\r\n    const [result] = await db\r\n      .select()\r\n      .from(MyTable)\r\n      .where(eq(MyTable.id, id));\r\n    return result ?? null;\r\n  },\r\n\r\n  selectByUserId: async (userId, limit = 10) => {\r\n    return await db\r\n      .select()\r\n      .from(MyTable)\r\n      .where(eq(MyTable.userId, userId))\r\n      .orderBy(desc(MyTable.createdAt))\r\n      .limit(limit);\r\n  },\r\n\r\n  insert: async (data) => {\r\n    const [result] = await db\r\n      .insert(MyTable)\r\n      .values(data)\r\n      .returning();\r\n    return result;\r\n  },\r\n\r\n  update: async (id, data) => {\r\n    const [result] = await db\r\n      .update(MyTable)\r\n      .set(data)\r\n      .where(eq(MyTable.id, id))\r\n      .returning();\r\n    return result;\r\n  },\r\n\r\n  delete: async (id) => {\r\n    await db.delete(MyTable).where(eq(MyTable.id, id));\r\n  },\r\n};\r\n\r\n// 4. Export from src/lib/db/repository.ts\r\nexport { pgMyRepository as myRepository } from \"./pg/repositories/my-repository.pg\";\r\n\r\n// 5. Generate and run migration\r\n// pnpm db:generate\r\n// pnpm db:migrate\r\n```\r\n\r\n---",
    "Extension Points Reference": "**Quick lookup: \"I want to add X\" → \"Modify Y file\"**\r\n\r\n| Want to add... | Extend/Modify... | File Location | Notes |\r\n|----------------|------------------|---------------|-------|\r\n| **New default tool** | `AppDefaultToolkit` enum + `APP_DEFAULT_TOOL_KIT` | `lib/ai/tools/tool-kit.ts` | Add tool implementation in `lib/ai/tools/[category]/` + rendering in `components/tool-invocation/` |\r\n| **New tool category** | `AppDefaultToolkit` enum | `lib/ai/tools/index.ts` | Creates new toolkit group (e.g., Visualization, WebSearch) |\r\n| **New workflow node type** | `NodeKind` enum + executor + validator | `lib/ai/workflow/workflow.interface.ts` + `executor/node-executor.ts` + `validator/node-validate.ts` | Also add UI config in `components/workflow/node-config/` |\r\n| **New API endpoint** | Create route handler | `src/app/api/[resource]/route.ts` | Follow standard pattern: auth → validation → repository → response |\r\n| **New server action** | Use `validatedActionWithUser` | `src/app/api/[resource]/actions.ts` | Import from `lib/action-utils.ts` |\r\n| **New database table** | Add to schema + repository | `lib/db/pg/schema.pg.ts` + `lib/db/pg/repositories/[name]-repository.pg.ts` | Then `pnpm db:generate` and `pnpm db:migrate` |\r\n| **New UI component** | Create in domain folder | `src/components/[domain]/[name].tsx` | Use shadcn/ui primitives from `components/ui/` |\r\n| **New React hook** | Create with `use-` prefix | `src/hooks/use-[name].ts` or `src/hooks/queries/use-[name].ts` | Data fetching hooks go in `queries/` subfolder |\r\n| **New Zod schema** | Add to validations | `src/lib/validations/[domain].ts` | Use `z.infer<typeof schema>` for TypeScript types |\r\n| **New AI provider** | Add to providers registry | `lib/ai/providers.ts` | Use `createOpenAI`, `createAnthropic`, etc. from AI SDK |\r\n| **New MCP server** | Configure via UI | Settings → MCP Servers | No code changes needed (file or DB storage) |\r\n| **New agent template** | Create via UI | Agents page | Combine tools/workflows/prompts |\r\n| **New permission type** | Add to permissions enum | `lib/auth/permissions.ts` | Use in `validatedActionWithAdminPermission` |\r\n| **New E2E test** | Add test file | `tests/[feature].spec.ts` | Use Playwright, follow existing patterns |\r\n| **New system prompt** | Add to prompts | `lib/ai/prompts.ts` | Use `mergeSystemPrompt` for composition |\r\n\r\n### Common Development Flows\r\n\r\n**Adding a Feature End-to-End**:\r\n```\r\n1. Define types (src/types/[domain].ts)\r\n2. Create Zod schema (lib/validations/[domain].ts)\r\n3. Add DB table + repository (lib/db/pg/)\r\n4. Create API route (app/api/[resource]/route.ts)\r\n5. Create UI component (components/[domain]/)\r\n6. Create data hook (hooks/queries/use-[resource].ts)\r\n7. Add E2E test (tests/[feature].spec.ts)\r\n8. Run: pnpm check && pnpm test:e2e\r\n```\r\n\r\n**Adding a Tool End-to-End**:\r\n```\r\n1. Implement tool (lib/ai/tools/[category]/[name].ts)\r\n2. Add to toolkit (lib/ai/tools/tool-kit.ts)\r\n3. Create rendering component (components/tool-invocation/[name].tsx)\r\n4. Add to tool invocation switch (components/tool-invocation/index.tsx)\r\n5. Test with @toolname mention in chat\r\n```\r\n\r\n**Adding a Workflow Node End-to-End**:\r\n```\r\n1. Add NodeKind enum (lib/ai/workflow/workflow.interface.ts)\r\n2. Define node data type (same file)\r\n3. Add executor (lib/ai/workflow/executor/node-executor.ts)\r\n4. Add validator (lib/ai/workflow/validator/node-validate.ts)\r\n5. Create UI config (components/workflow/node-config/[name]-node.tsx)\r\n6. Test in workflow builder\r\n```\r\n\r\n---",
    "Coding Standards": "### Naming Conventions\r\n\r\n| Type | Convention | Example |\r\n|------|------------|---------|\r\n| Components | PascalCase | `ChatBot.tsx`, `WorkflowBuilder.tsx` |\r\n| Component files | kebab-case or PascalCase | `chat-bot.tsx`, `ChatBot.tsx` |\r\n| Hooks | camelCase with `use-` prefix | `use-chat-bot.ts`, `use-workflow.ts` |\r\n| Utilities | camelCase | `action-utils.ts`, `shared.chat.ts` |\r\n| API routes | Next.js convention | `src/app/api/[resource]/route.ts` |\r\n| Types | Domain suffix | `chat.ts`, `mcp.ts`, `workflow.ts` |\r\n\r\n### TypeScript Standards\r\n\r\n- **Strict TypeScript** throughout (no implicit any)\r\n- **Zod for validation AND type inference**:\r\n  ```typescript\r\n  const schema = z.object({ name: z.string() })\r\n  type SchemaType = z.infer<typeof schema>\r\n  ```\r\n- **Custom type tags** for runtime type narrowing (see Tool Abstraction)\r\n- **Types organized by domain** in `src/types/`\r\n\r\n### Code Quality\r\n\r\n- **Line width**: 80 characters\r\n- **Indentation**: 2 spaces\r\n- **Formatter**: Biome 1.9.4\r\n- **Linter**: Biome (no ESLint)\r\n- **Validation**: Zod everywhere (forms, API, dynamic config)\r\n\r\n### Error Handling\r\n\r\n- **Enum error types** for specific errors:\r\n  ```typescript\r\n  enum UpdateUserPasswordError {\r\n    INVALID_CURRENT_PASSWORD = \"invalid_current_password\",\r\n    PASSWORD_MISMATCH = \"password_mismatch\"\r\n  }\r\n  ```\r\n- **Cross-field validation** with Zod `superRefine`:\r\n  ```typescript\r\n  .superRefine((data, ctx) => {\r\n    if (data.password !== data.confirmPassword) {\r\n      ctx.addIssue({ path: [\"confirmPassword\"], message: \"Passwords must match\" })\r\n    }\r\n  })\r\n  ```\r\n\r\n---",
    "Official Documentation": "- **better-chatbot**: https://github.com/cgoinglove/better-chatbot\r\n- **Next.js**: https://nextjs.org/docs\r\n- **Vercel AI SDK**: https://sdk.vercel.ai/docs\r\n- **Better Auth**: https://www.better-auth.com/docs\r\n- **Drizzle ORM**: https://orm.drizzle.team/docs\r\n- **Playwright**: https://playwright.dev/docs/intro\r\n- **Live Demo**: https://betterchatbot.vercel.app\r\n\r\n---",
    "Common Patterns": "### Pattern 1: Server Action with User Context\r\n\r\n```typescript\r\nimport { validatedActionWithUser } from \"@/lib/action-utils\"\r\nimport { z } from \"zod\"\r\n\r\nconst updateProfileSchema = z.object({\r\n  name: z.string().min(1),\r\n  email: z.string().email()\r\n})\r\n\r\nexport const updateProfile = validatedActionWithUser(\r\n  updateProfileSchema,\r\n  async (data, formData, user) => {\r\n    // user is guaranteed authenticated\r\n    // data is validated and typed\r\n    await db.update(users).set(data).where(eq(users.id, user.id))\r\n    return { success: true }\r\n  }\r\n)\r\n```\r\n\r\n**When to use**: Any server action that requires authentication\r\n\r\n### Pattern 2: Tool Type Checking\r\n\r\n```typescript\r\nimport { VercelAIMcpToolTag, VercelAIWorkflowToolTag } from \"@/lib/ai/tools\"\r\n\r\nasync function executeTool(tool: unknown) {\r\n  if (VercelAIMcpToolTag.isMaybe(tool)) {\r\n    return await executeMcpTool(tool)\r\n  } else if (VercelAIWorkflowToolTag.isMaybe(tool)) {\r\n    return await executeWorkflowTool(tool)\r\n  } else {\r\n    return await executeDefaultTool(tool)\r\n  }\r\n}\r\n```\r\n\r\n**When to use**: Handling multiple tool types in unified interface\r\n\r\n### Pattern 3: Workflow State Updates\r\n\r\n```typescript\r\nimport { useWorkflowStore } from \"@/app/store/workflow\"\r\n\r\n// In component:\r\nconst updateNodeStatus = useWorkflowStore(state => state.updateNodeStatus)\r\n\r\n// In store:\r\nupdateNodeStatus: (nodeId, status) =>\r\n  set(state => ({\r\n    workflow: {\r\n      ...state.workflow,\r\n      nodes: state.workflow.nodes.map(node =>\r\n        node.id === nodeId ? { ...node, status } : node\r\n      )\r\n    }\r\n  }))\r\n```\r\n\r\n**When to use**: Updating nested Zustand state without mutation\r\n\r\n---",
    "Using Bundled Resources": "### References (references/)\r\n\r\n- `references/AGENTS.md` - Full repository guidelines (loaded when detailed structure questions arise)\r\n- `references/CONTRIBUTING.md` - Complete contribution process (loaded when PR standards questions arise)\r\n\r\n**When Claude should load these**: When user asks about detailed better-chatbot conventions, asks \"what are the full guidelines?\", or needs comprehensive contribution workflow details.\r\n\r\n---",
    "Architectural Principles": "### 1. Progressive Enhancement\r\n\r\nFeatures build in layers:\r\n\r\n```\r\nBase Layer: Chat + LLM\r\n    ↓\r\nTool Layer: Default + MCP\r\n    ↓\r\nComposition Layer: Workflows (tools as nodes)\r\n    ↓\r\nPersonalization Layer: Agents (workflows + prompts)\r\n```\r\n\r\n**Evidence**:\r\n- Agents can have `instructions.mentions` (inject tools/workflows)\r\n- Workflows can call MCP + default tools\r\n- Chat API composes all three tiers\r\n\r\n**User Journey**:\r\n1. Start with default tools (no setup)\r\n2. Add MCP servers for specialized needs\r\n3. Combine into workflows for automation\r\n4. Package into agents for personas\r\n\r\n### 2. Convention Over Configuration\r\n\r\n**New Tool?**\r\n- Add to `AppDefaultToolkit` enum → auto-available\r\n\r\n**New Workflow Node?**\r\n- Add to `NodeKind` enum → executor handles it\r\n\r\n**New MCP Server?**\r\n- Just configure via UI → manager handles lifecycle\r\n\r\n### 3. Defensive Programming\r\n\r\n**Use `safe()` everywhere**:\r\n```typescript\r\nconst tools = await safe(() => loadMcpTools())\r\n  .orElse({});  // Returns default on failure\r\n```\r\n\r\n**Philosophy**: Never crash the chat - degrade gracefully\r\n\r\n### 4. Streaming-First\r\n\r\n**Evidence**:\r\n- Chat API uses `createUIMessageStream()`\r\n- Workflow execution streams intermediate steps\r\n- Tool calls stream progress updates\r\n\r\n**Why**: Live feedback, better UX, handles long operations\r\n\r\n### 5. Type-Driven Development\r\n\r\n**Pattern**:\r\n```typescript\r\n// Zod defines runtime validation AND TypeScript types\r\nconst schema = z.object({ name: z.string() });\r\ntype SchemaType = z.infer<typeof schema>;\r\n\r\n// Discriminated unions for polymorphic data\r\ntype WorkflowNodeData =\r\n  | { kind: \"input\"; ... }\r\n  | { kind: \"llm\"; ... }\r\n  | { kind: \"tool\"; ... };\r\n\r\n// Brand types for runtime checking\r\nVercelAIMcpToolTag.isMaybe(tool)\r\n```\r\n\r\n---",
    "Database & Repository Patterns": "pnpm db:studio\r\n```\r\n\r\n---"
  }
}