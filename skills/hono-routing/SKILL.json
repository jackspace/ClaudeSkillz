{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/middleware-catalog.md",
      "references/rpc-guide.md",
      "references/top-errors.md",
      "references/validation-libraries.md"
    ]
  },
  "content": "**Status**: Production Ready ✅\r\n**Last Updated**: 2025-10-22\r\n**Dependencies**: None (framework-agnostic)\r\n**Latest Versions**: hono@4.10.2, zod@4.1.12, valibot@1.1.0, @hono/zod-validator@0.7.4, @hono/valibot-validator@0.5.3\r\n\r\n---",
  "name": "hono-routing",
  "id": "hono-routing",
  "sections": {
    "Production Example": "This skill is validated across multiple runtime environments:\r\n\r\n- **Cloudflare Workers**: Routing, middleware, RPC patterns\r\n- **Deno**: All validation libraries tested\r\n- **Bun**: Performance benchmarks completed\r\n- **Node.js**: Full test suite passing\r\n\r\nAll patterns in this skill have been validated in production.\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/top-errors.md` first\r\n2. Verify all steps in the setup process\r\n3. Ensure `await next()` is called in middleware\r\n4. Ensure RPC routes use `const route = app.get(...)` pattern\r\n5. Check official docs: https://hono.dev",
    "Reference Documentation": "For deeper understanding, see:\r\n\r\n- **middleware-catalog.md** - Complete built-in Hono middleware reference\r\n- **validation-libraries.md** - Zod vs Valibot vs Typia vs ArkType comparison\r\n- **rpc-guide.md** - RPC pattern deep dive, performance optimization\r\n- **top-errors.md** - Common Hono errors with solutions\r\n\r\n---",
    "Configuration Files Reference": "### package.json (Full Example)\r\n\r\n```json\r\n{\r\n  \"name\": \"hono-app\",\r\n  \"version\": \"1.0.0\",\r\n  \"type\": \"module\",\r\n  \"scripts\": {\r\n    \"dev\": \"tsx watch src/index.ts\",\r\n    \"build\": \"tsc\",\r\n    \"start\": \"node dist/index.js\"\r\n  },\r\n  \"dependencies\": {\r\n    \"hono\": \"^4.10.2\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"typescript\": \"^5.9.0\",\r\n    \"tsx\": \"^4.19.0\",\r\n    \"@types/node\": \"^22.10.0\"\r\n  }\r\n}\r\n```\r\n\r\n### package.json with Validation (Zod)\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"hono\": \"^4.10.2\",\r\n    \"zod\": \"^4.1.12\",\r\n    \"@hono/zod-validator\": \"^0.7.4\"\r\n  }\r\n}\r\n```\r\n\r\n### package.json with Validation (Valibot)\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"hono\": \"^4.10.2\",\r\n    \"valibot\": \"^1.1.0\",\r\n    \"@hono/valibot-validator\": \"^0.5.3\"\r\n  }\r\n}\r\n```\r\n\r\n### package.json with All Validators\r\n\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"hono\": \"^4.10.2\",\r\n    \"zod\": \"^4.1.12\",\r\n    \"valibot\": \"^1.1.0\",\r\n    \"@hono/zod-validator\": \"^0.7.4\",\r\n    \"@hono/valibot-validator\": \"^0.5.3\",\r\n    \"@hono/typia-validator\": \"^0.1.2\",\r\n    \"@hono/arktype-validator\": \"^2.0.1\"\r\n  }\r\n}\r\n```\r\n\r\n### tsconfig.json\r\n\r\n```json\r\n{\r\n  \"compilerOptions\": {\r\n    \"target\": \"ES2022\",\r\n    \"module\": \"ES2022\",\r\n    \"lib\": [\"ES2022\"],\r\n    \"moduleResolution\": \"bundler\",\r\n    \"resolveJsonModule\": true,\r\n    \"allowJs\": true,\r\n    \"checkJs\": false,\r\n    \"strict\": true,\r\n    \"esModuleInterop\": true,\r\n    \"skipLibCheck\": true,\r\n    \"forceConsistentCasingInFileNames\": true,\r\n    \"isolatedModules\": true,\r\n    \"outDir\": \"./dist\"\r\n  },\r\n  \"include\": [\"src/**/*\"],\r\n  \"exclude\": [\"node_modules\"]\r\n}\r\n```\r\n\r\n---",
    "Quick Start (15 Minutes)": "### 1. Install Hono\r\n\r\n```bash\r\nnpm install hono@4.10.2\r\n```\r\n\r\n**Why Hono:**\r\n- **Fast**: Built on Web Standards, runs on any JavaScript runtime\r\n- **Lightweight**: ~10KB, no dependencies\r\n- **Type-safe**: Full TypeScript support with type inference\r\n- **Flexible**: Works on Cloudflare Workers, Deno, Bun, Node.js, Vercel\r\n\r\n### 2. Create Basic App\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\n\r\nconst app = new Hono()\r\n\r\napp.get('/', (c) => {\r\n  return c.json({ message: 'Hello Hono!' })\r\n})\r\n\r\nexport default app\r\n```\r\n\r\n**CRITICAL:**\r\n- Use `c.json()`, `c.text()`, `c.html()` for responses\r\n- Return the response (don't use `res.send()` like Express)\r\n- Export app for runtime (Cloudflare Workers, Deno, Bun, Node.js)\r\n\r\n### 3. Add Request Validation\r\n\r\n```bash\r\nnpm install zod@4.1.12 @hono/zod-validator@0.7.4\r\n```\r\n\r\n```typescript\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { z } from 'zod'\r\n\r\nconst schema = z.object({\r\n  name: z.string(),\r\n  age: z.number(),\r\n})\r\n\r\napp.post('/user', zValidator('json', schema), (c) => {\r\n  const data = c.req.valid('json')\r\n  return c.json({ success: true, data })\r\n})\r\n```\r\n\r\n**Why Validation:**\r\n- Type-safe request data\r\n- Automatic error responses\r\n- Runtime validation, not just TypeScript\r\n\r\n---",
    "Dependencies (Latest Verified 2025-10-22)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"hono\": \"^4.10.2\"\r\n  },\r\n  \"optionalDependencies\": {\r\n    \"zod\": \"^4.1.12\",\r\n    \"valibot\": \"^1.1.0\",\r\n    \"@hono/zod-validator\": \"^0.7.4\",\r\n    \"@hono/valibot-validator\": \"^0.5.3\",\r\n    \"@hono/typia-validator\": \"^0.1.2\",\r\n    \"@hono/arktype-validator\": \"^2.0.1\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"typescript\": \"^5.9.0\"\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ **Call `await next()` in middleware** - Required for middleware chain execution\r\n✅ **Return Response from handlers** - Use `c.json()`, `c.text()`, `c.html()`\r\n✅ **Use `c.req.valid()` after validation** - Type-safe validated data\r\n✅ **Export route types for RPC** - `export type AppType = typeof route`\r\n✅ **Throw HTTPException for client errors** - 400, 401, 403, 404 errors\r\n✅ **Use `onError` for global error handling** - Centralized error responses\r\n✅ **Define Variables type for c.set/c.get** - Type-safe context variables\r\n✅ **Use const route = app.get(...)** - Required for RPC type inference\r\n\r\n### Never Do\r\n\r\n❌ **Forget `await next()` in middleware** - Breaks middleware chain\r\n❌ **Use `res.send()` like Express** - Not compatible with Hono\r\n❌ **Access request data without validation** - Use validators for type safety\r\n❌ **Export entire app for large RPC** - Slow type inference, export specific routes\r\n❌ **Use plain throw new Error()** - Use HTTPException instead\r\n❌ **Skip onError handler** - Leads to inconsistent error responses\r\n❌ **Use c.set/c.get without Variables type** - Loses type safety\r\n\r\n---",
    "The 6-Part Hono Mastery Guide": "### Part 1: Routing Patterns\r\n\r\n#### Basic Routes\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\n\r\nconst app = new Hono()\r\n\r\n// GET request\r\napp.get('/posts', (c) => c.json({ posts: [] }))\r\n\r\n// POST request\r\napp.post('/posts', (c) => c.json({ created: true }))\r\n\r\n// PUT request\r\napp.put('/posts/:id', (c) => c.json({ updated: true }))\r\n\r\n// DELETE request\r\napp.delete('/posts/:id', (c) => c.json({ deleted: true }))\r\n\r\n// Multiple methods\r\napp.on(['GET', 'POST'], '/multi', (c) => c.text('GET or POST'))\r\n\r\n// All methods\r\napp.all('/catch-all', (c) => c.text('Any method'))\r\n```\r\n\r\n**Key Points:**\r\n- Always return a Response (c.json, c.text, c.html, etc.)\r\n- Routes are matched in order (first match wins)\r\n- Use specific routes before wildcard routes\r\n\r\n#### Route Parameters\r\n\r\n```typescript\r\n// Single parameter\r\napp.get('/users/:id', (c) => {\r\n  const id = c.req.param('id')\r\n  return c.json({ userId: id })\r\n})\r\n\r\n// Multiple parameters\r\napp.get('/posts/:postId/comments/:commentId', (c) => {\r\n  const { postId, commentId } = c.req.param()\r\n  return c.json({ postId, commentId })\r\n})\r\n\r\n// Optional parameters (using wildcards)\r\napp.get('/files/*', (c) => {\r\n  const path = c.req.param('*')\r\n  return c.json({ filePath: path })\r\n})\r\n```\r\n\r\n**CRITICAL:**\r\n- `c.req.param('name')` returns single parameter\r\n- `c.req.param()` returns all parameters as object\r\n- Parameters are always strings (cast to number if needed)\r\n\r\n#### Query Parameters\r\n\r\n```typescript\r\napp.get('/search', (c) => {\r\n  // Single query param\r\n  const q = c.req.query('q')\r\n\r\n  // Multiple query params\r\n  const { page, limit } = c.req.query()\r\n\r\n  // Query param array (e.g., ?tag=js&tag=ts)\r\n  const tags = c.req.queries('tag')\r\n\r\n  return c.json({ q, page, limit, tags })\r\n})\r\n```\r\n\r\n**Best Practice:**\r\n- Use validation for query params (see Part 4)\r\n- Provide defaults for optional params\r\n- Parse numbers/booleans from query strings\r\n\r\n#### Wildcard Routes\r\n\r\n```typescript\r\n// Match any path after /api/\r\napp.get('/api/*', (c) => {\r\n  const path = c.req.param('*')\r\n  return c.json({ catchAll: path })\r\n})\r\n\r\n// Named wildcard\r\napp.get('/files/:filepath{.+}', (c) => {\r\n  const filepath = c.req.param('filepath')\r\n  return c.json({ file: filepath })\r\n})\r\n```\r\n\r\n#### Route Grouping (Sub-apps)\r\n\r\n```typescript\r\n// Create sub-app\r\nconst api = new Hono()\r\n\r\napi.get('/users', (c) => c.json({ users: [] }))\r\napi.get('/posts', (c) => c.json({ posts: [] }))\r\n\r\n// Mount sub-app\r\nconst app = new Hono()\r\napp.route('/api', api)\r\n\r\n// Result: /api/users, /api/posts\r\n```\r\n\r\n**Why Group Routes:**\r\n- Organize large applications\r\n- Share middleware for specific routes\r\n- Better code structure and maintainability\r\n\r\n---\r\n\r\n### Part 2: Middleware Composition\r\n\r\n#### Middleware Flow\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\n\r\nconst app = new Hono()\r\n\r\n// Global middleware (runs for all routes)\r\napp.use('*', async (c, next) => {\r\n  console.log(`[${c.req.method}] ${c.req.url}`)\r\n  await next() // CRITICAL: Must call next()\r\n  console.log('Response sent')\r\n})\r\n\r\n// Route-specific middleware\r\napp.use('/admin/*', async (c, next) => {\r\n  // Auth check\r\n  const token = c.req.header('Authorization')\r\n  if (!token) {\r\n    return c.json({ error: 'Unauthorized' }, 401)\r\n  }\r\n  await next()\r\n})\r\n\r\napp.get('/admin/dashboard', (c) => {\r\n  return c.json({ message: 'Admin Dashboard' })\r\n})\r\n```\r\n\r\n**CRITICAL:**\r\n- **Always call `await next()`** in middleware\r\n- Middleware runs BEFORE the handler\r\n- Return early to prevent handler execution\r\n- Check `c.error` AFTER `next()` for error handling\r\n\r\n#### Built-in Middleware\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\nimport { logger } from 'hono/logger'\r\nimport { cors } from 'hono/cors'\r\nimport { prettyJSON } from 'hono/pretty-json'\r\nimport { compress } from 'hono/compress'\r\nimport { cache } from 'hono/cache'\r\n\r\nconst app = new Hono()\r\n\r\n// Request logging\r\napp.use('*', logger())\r\n\r\n// CORS\r\napp.use('/api/*', cors({\r\n  origin: 'https://example.com',\r\n  allowMethods: ['GET', 'POST', 'PUT', 'DELETE'],\r\n  allowHeaders: ['Content-Type', 'Authorization'],\r\n}))\r\n\r\n// Pretty JSON (dev only)\r\napp.use('*', prettyJSON())\r\n\r\n// Compression (gzip/deflate)\r\napp.use('*', compress())\r\n\r\n// Cache responses\r\napp.use(\r\n  '/static/*',\r\n  cache({\r\n    cacheName: 'my-app',\r\n    cacheControl: 'max-age=3600',\r\n  })\r\n)\r\n```\r\n\r\n**Built-in Middleware Reference**: See `references/middleware-catalog.md`\r\n\r\n#### Middleware Chaining\r\n\r\n```typescript\r\n// Multiple middleware in sequence\r\napp.get(\r\n  '/protected',\r\n  authMiddleware,\r\n  rateLimitMiddleware,\r\n  (c) => {\r\n    return c.json({ data: 'Protected data' })\r\n  }\r\n)\r\n\r\n// Middleware factory pattern\r\nconst authMiddleware = async (c, next) => {\r\n  const token = c.req.header('Authorization')\r\n  if (!token) {\r\n    throw new HTTPException(401, { message: 'Unauthorized' })\r\n  }\r\n\r\n  // Set user in context\r\n  c.set('user', { id: 1, name: 'Alice' })\r\n\r\n  await next()\r\n}\r\n\r\nconst rateLimitMiddleware = async (c, next) => {\r\n  // Rate limit logic\r\n  await next()\r\n}\r\n```\r\n\r\n**Why Chain Middleware:**\r\n- Separation of concerns\r\n- Reusable across routes\r\n- Clear execution order\r\n\r\n#### Custom Middleware\r\n\r\n```typescript\r\n// Timing middleware\r\nconst timing = async (c, next) => {\r\n  const start = Date.now()\r\n  await next()\r\n  const elapsed = Date.now() - start\r\n  c.res.headers.set('X-Response-Time', `${elapsed}ms`)\r\n}\r\n\r\n// Request ID middleware\r\nconst requestId = async (c, next) => {\r\n  const id = crypto.randomUUID()\r\n  c.set('requestId', id)\r\n  await next()\r\n  c.res.headers.set('X-Request-ID', id)\r\n}\r\n\r\n// Error logging middleware\r\nconst errorLogger = async (c, next) => {\r\n  await next()\r\n  if (c.error) {\r\n    console.error('Error:', c.error)\r\n    // Send to error tracking service\r\n  }\r\n}\r\n\r\napp.use('*', timing)\r\napp.use('*', requestId)\r\napp.use('*', errorLogger)\r\n```\r\n\r\n**Best Practices:**\r\n- Keep middleware focused (single responsibility)\r\n- Use `c.set()` to share data between middleware\r\n- Check `c.error` AFTER `next()` for error handling\r\n- Return early to short-circuit execution\r\n\r\n---\r\n\r\n### Part 3: Type-Safe Context Extension\r\n\r\n#### Using c.set() and c.get()\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\n\r\ntype Bindings = {\r\n  DATABASE_URL: string\r\n}\r\n\r\ntype Variables = {\r\n  user: {\r\n    id: number\r\n    name: string\r\n  }\r\n  requestId: string\r\n}\r\n\r\nconst app = new Hono<{ Bindings: Bindings; Variables: Variables }>()\r\n\r\n// Middleware sets variables\r\napp.use('*', async (c, next) => {\r\n  c.set('requestId', crypto.randomUUID())\r\n  await next()\r\n})\r\n\r\napp.use('/api/*', async (c, next) => {\r\n  c.set('user', { id: 1, name: 'Alice' })\r\n  await next()\r\n})\r\n\r\n// Route accesses variables\r\napp.get('/api/profile', (c) => {\r\n  const user = c.get('user') // Type-safe!\r\n  const requestId = c.get('requestId') // Type-safe!\r\n\r\n  return c.json({ user, requestId })\r\n})\r\n```\r\n\r\n**CRITICAL:**\r\n- Define `Variables` type for type-safe `c.get()`\r\n- Define `Bindings` type for environment variables (Cloudflare Workers)\r\n- `c.set()` in middleware, `c.get()` in handlers\r\n\r\n#### Custom Context Extension\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\nimport type { Context } from 'hono'\r\n\r\ntype Env = {\r\n  Variables: {\r\n    logger: {\r\n      info: (message: string) => void\r\n      error: (message: string) => void\r\n    }\r\n  }\r\n}\r\n\r\nconst app = new Hono<Env>()\r\n\r\n// Create logger middleware\r\napp.use('*', async (c, next) => {\r\n  const logger = {\r\n    info: (msg: string) => console.log(`[INFO] ${msg}`),\r\n    error: (msg: string) => console.error(`[ERROR] ${msg}`),\r\n  }\r\n\r\n  c.set('logger', logger)\r\n  await next()\r\n})\r\n\r\napp.get('/', (c) => {\r\n  const logger = c.get('logger')\r\n  logger.info('Hello from route')\r\n\r\n  return c.json({ message: 'Hello' })\r\n})\r\n```\r\n\r\n**Advanced Pattern**: See `templates/context-extension.ts`\r\n\r\n---\r\n\r\n### Part 4: Request Validation\r\n\r\n#### Validation with Zod\r\n\r\n```bash\r\nnpm install zod@4.1.12 @hono/zod-validator@0.7.4\r\n```\r\n\r\n```typescript\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { z } from 'zod'\r\n\r\n// Define schema\r\nconst userSchema = z.object({\r\n  name: z.string().min(1).max(100),\r\n  email: z.string().email(),\r\n  age: z.number().int().min(18).optional(),\r\n})\r\n\r\n// Validate JSON body\r\napp.post('/users', zValidator('json', userSchema), (c) => {\r\n  const data = c.req.valid('json') // Type-safe!\r\n  return c.json({ success: true, data })\r\n})\r\n\r\n// Validate query params\r\nconst searchSchema = z.object({\r\n  q: z.string(),\r\n  page: z.string().transform((val) => parseInt(val, 10)),\r\n  limit: z.string().transform((val) => parseInt(val, 10)).optional(),\r\n})\r\n\r\napp.get('/search', zValidator('query', searchSchema), (c) => {\r\n  const { q, page, limit } = c.req.valid('query')\r\n  return c.json({ q, page, limit })\r\n})\r\n\r\n// Validate route params\r\nconst idSchema = z.object({\r\n  id: z.string().uuid(),\r\n})\r\n\r\napp.get('/users/:id', zValidator('param', idSchema), (c) => {\r\n  const { id } = c.req.valid('param')\r\n  return c.json({ userId: id })\r\n})\r\n\r\n// Validate headers\r\nconst headerSchema = z.object({\r\n  'authorization': z.string().startsWith('Bearer '),\r\n  'content-type': z.string(),\r\n})\r\n\r\napp.post('/auth', zValidator('header', headerSchema), (c) => {\r\n  const headers = c.req.valid('header')\r\n  return c.json({ authenticated: true })\r\n})\r\n```\r\n\r\n**CRITICAL:**\r\n- **Always use `c.req.valid()`** after validation (type-safe)\r\n- Validation targets: `json`, `query`, `param`, `header`, `form`, `cookie`\r\n- Use `z.transform()` to convert strings to numbers/dates\r\n- Validation errors return 400 automatically\r\n\r\n#### Custom Validation Hooks\r\n\r\n```typescript\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { HTTPException } from 'hono/http-exception'\r\n\r\nconst schema = z.object({\r\n  name: z.string(),\r\n  age: z.number(),\r\n})\r\n\r\n// Custom error handler\r\napp.post(\r\n  '/users',\r\n  zValidator('json', schema, (result, c) => {\r\n    if (!result.success) {\r\n      // Custom error response\r\n      return c.json(\r\n        {\r\n          error: 'Validation failed',\r\n          issues: result.error.issues,\r\n        },\r\n        400\r\n      )\r\n    }\r\n  }),\r\n  (c) => {\r\n    const data = c.req.valid('json')\r\n    return c.json({ success: true, data })\r\n  }\r\n)\r\n\r\n// Throw HTTPException\r\napp.post(\r\n  '/users',\r\n  zValidator('json', schema, (result, c) => {\r\n    if (!result.success) {\r\n      throw new HTTPException(400, { cause: result.error })\r\n    }\r\n  }),\r\n  (c) => {\r\n    const data = c.req.valid('json')\r\n    return c.json({ success: true, data })\r\n  }\r\n)\r\n```\r\n\r\n#### Validation with Valibot\r\n\r\n```bash\r\nnpm install valibot@1.1.0 @hono/valibot-validator@0.5.3\r\n```\r\n\r\n```typescript\r\nimport { vValidator } from '@hono/valibot-validator'\r\nimport * as v from 'valibot'\r\n\r\nconst schema = v.object({\r\n  name: v.string(),\r\n  age: v.number(),\r\n})\r\n\r\napp.post('/users', vValidator('json', schema), (c) => {\r\n  const data = c.req.valid('json')\r\n  return c.json({ success: true, data })\r\n})\r\n```\r\n\r\n**Zod vs Valibot**: See `references/validation-libraries.md`\r\n\r\n#### Validation with Typia\r\n\r\n```bash\r\nnpm install typia @hono/typia-validator@0.1.2\r\n```\r\n\r\n```typescript\r\nimport { typiaValidator } from '@hono/typia-validator'\r\nimport typia from 'typia'\r\n\r\ninterface User {\r\n  name: string\r\n  age: number\r\n}\r\n\r\nconst validate = typia.createValidate<User>()\r\n\r\napp.post('/users', typiaValidator('json', validate), (c) => {\r\n  const data = c.req.valid('json')\r\n  return c.json({ success: true, data })\r\n})\r\n```\r\n\r\n**Why Typia:**\r\n- Fastest validation (compile-time)\r\n- No runtime schema definition\r\n- AOT (Ahead-of-Time) compilation\r\n\r\n#### Validation with ArkType\r\n\r\n```bash\r\nnpm install arktype @hono/arktype-validator@2.0.1\r\n```\r\n\r\n```typescript\r\nimport { arktypeValidator } from '@hono/arktype-validator'\r\nimport { type } from 'arktype'\r\n\r\nconst schema = type({\r\n  name: 'string',\r\n  age: 'number',\r\n})\r\n\r\napp.post('/users', arktypeValidator('json', schema), (c) => {\r\n  const data = c.req.valid('json')\r\n  return c.json({ success: true, data })\r\n})\r\n```\r\n\r\n**Comparison**: See `references/validation-libraries.md` for detailed comparison\r\n\r\n---\r\n\r\n### Part 5: Typed Routes (RPC)\r\n\r\n#### Why RPC?\r\n\r\nHono's RPC feature allows **type-safe client/server communication** without manual API type definitions. The client infers types directly from the server routes.\r\n\r\n#### Server-Side Setup\r\n\r\n```typescript\r\n// app.ts\r\nimport { Hono } from 'hono'\r\nimport { zValidator } from '@hono/zod-validator'\r\nimport { z } from 'zod'\r\n\r\nconst app = new Hono()\r\n\r\nconst schema = z.object({\r\n  name: z.string(),\r\n  age: z.number(),\r\n})\r\n\r\n// Define route and export type\r\nconst route = app.post(\r\n  '/users',\r\n  zValidator('json', schema),\r\n  (c) => {\r\n    const data = c.req.valid('json')\r\n    return c.json({ success: true, data }, 201)\r\n  }\r\n)\r\n\r\n// Export app type for RPC client\r\nexport type AppType = typeof route\r\n\r\n// OR export entire app\r\n// export type AppType = typeof app\r\n\r\nexport default app\r\n```\r\n\r\n**CRITICAL:**\r\n- **Must use `const route = app.get(...)` for RPC type inference**\r\n- Export `typeof route` or `typeof app`\r\n- Don't use anonymous route definitions\r\n\r\n#### Client-Side Setup\r\n\r\n```typescript\r\n// client.ts\r\nimport { hc } from 'hono/client'\r\nimport type { AppType } from './app'\r\n\r\nconst client = hc<AppType>('http://localhost:8787')\r\n\r\n// Type-safe API call\r\nconst res = await client.users.$post({\r\n  json: {\r\n    name: 'Alice',\r\n    age: 30,\r\n  },\r\n})\r\n\r\n// Response is typed!\r\nconst data = await res.json() // { success: boolean, data: { name: string, age: number } }\r\n```\r\n\r\n**Why RPC:**\r\n- ✅ Full type inference (request + response)\r\n- ✅ No manual type definitions\r\n- ✅ Compile-time error checking\r\n- ✅ Auto-complete in IDE\r\n\r\n#### RPC with Multiple Routes\r\n\r\n```typescript\r\n// Server\r\nconst app = new Hono()\r\n\r\nconst getUsers = app.get('/users', (c) => {\r\n  return c.json({ users: [] })\r\n})\r\n\r\nconst createUser = app.post(\r\n  '/users',\r\n  zValidator('json', userSchema),\r\n  (c) => {\r\n    const data = c.req.valid('json')\r\n    return c.json({ success: true, data }, 201)\r\n  }\r\n)\r\n\r\nconst getUser = app.get('/users/:id', (c) => {\r\n  const id = c.req.param('id')\r\n  return c.json({ id, name: 'Alice' })\r\n})\r\n\r\n// Export combined type\r\nexport type AppType = typeof getUsers | typeof createUser | typeof getUser\r\n\r\n// Client\r\nconst client = hc<AppType>('http://localhost:8787')\r\n\r\n// GET /users\r\nconst usersRes = await client.users.$get()\r\n\r\n// POST /users\r\nconst createRes = await client.users.$post({\r\n  json: { name: 'Alice', age: 30 },\r\n})\r\n\r\n// GET /users/:id\r\nconst userRes = await client.users[':id'].$get({\r\n  param: { id: '123' },\r\n})\r\n```\r\n\r\n#### RPC Performance Optimization\r\n\r\n**Problem**: Large apps with many routes cause slow type inference\r\n\r\n**Solution**: Export specific route groups instead of entire app\r\n\r\n```typescript\r\n// ❌ Slow: Export entire app\r\nexport type AppType = typeof app\r\n\r\n// ✅ Fast: Export specific routes\r\nconst userRoutes = app.get('/users', ...).post('/users', ...)\r\nexport type UserRoutes = typeof userRoutes\r\n\r\nconst postRoutes = app.get('/posts', ...).post('/posts', ...)\r\nexport type PostRoutes = typeof postRoutes\r\n\r\n// Client imports specific routes\r\nimport type { UserRoutes } from './app'\r\nconst userClient = hc<UserRoutes>('http://localhost:8787')\r\n```\r\n\r\n**Deep Dive**: See `references/rpc-guide.md`\r\n\r\n---\r\n\r\n### Part 6: Error Handling\r\n\r\n#### HTTPException\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\nimport { HTTPException } from 'hono/http-exception'\r\n\r\nconst app = new Hono()\r\n\r\napp.get('/users/:id', (c) => {\r\n  const id = c.req.param('id')\r\n\r\n  // Throw HTTPException for client errors\r\n  if (!id) {\r\n    throw new HTTPException(400, { message: 'ID is required' })\r\n  }\r\n\r\n  // With custom response\r\n  if (id === 'invalid') {\r\n    const res = new Response('Custom error body', { status: 400 })\r\n    throw new HTTPException(400, { res })\r\n  }\r\n\r\n  return c.json({ id })\r\n})\r\n```\r\n\r\n**CRITICAL:**\r\n- Use HTTPException for **expected errors** (400, 401, 403, 404)\r\n- Don't use for **unexpected errors** (500) - use `onError` instead\r\n- HTTPException stops execution immediately\r\n\r\n#### Global Error Handler (onError)\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\nimport { HTTPException } from 'hono/http-exception'\r\n\r\nconst app = new Hono()\r\n\r\n// Custom error handler\r\napp.onError((err, c) => {\r\n  // Handle HTTPException\r\n  if (err instanceof HTTPException) {\r\n    return err.getResponse()\r\n  }\r\n\r\n  // Handle unexpected errors\r\n  console.error('Unexpected error:', err)\r\n\r\n  return c.json(\r\n    {\r\n      error: 'Internal Server Error',\r\n      message: err.message,\r\n    },\r\n    500\r\n  )\r\n})\r\n\r\napp.get('/error', (c) => {\r\n  throw new Error('Something went wrong!')\r\n})\r\n```\r\n\r\n**Why onError:**\r\n- Centralized error handling\r\n- Consistent error responses\r\n- Error logging and tracking\r\n\r\n#### Middleware Error Checking\r\n\r\n```typescript\r\napp.use('*', async (c, next) => {\r\n  await next()\r\n\r\n  // Check for errors after handler\r\n  if (c.error) {\r\n    console.error('Error in route:', c.error)\r\n    // Send to error tracking service\r\n  }\r\n})\r\n```\r\n\r\n#### Not Found Handler\r\n\r\n```typescript\r\napp.notFound((c) => {\r\n  return c.json({ error: 'Not Found' }, 404)\r\n})\r\n```\r\n\r\n#### Error Handling Best Practices\r\n\r\n```typescript\r\nimport { Hono } from 'hono'\r\nimport { HTTPException } from 'hono/http-exception'\r\n\r\nconst app = new Hono()\r\n\r\n// Validation errors\r\napp.post('/users', zValidator('json', schema), (c) => {\r\n  // zValidator automatically returns 400 on validation failure\r\n  const data = c.req.valid('json')\r\n  return c.json({ data })\r\n})\r\n\r\n// Authorization errors\r\napp.use('/admin/*', async (c, next) => {\r\n  const token = c.req.header('Authorization')\r\n  if (!token) {\r\n    throw new HTTPException(401, { message: 'Unauthorized' })\r\n  }\r\n  await next()\r\n})\r\n\r\n// Not found errors\r\napp.get('/users/:id', async (c) => {\r\n  const id = c.req.param('id')\r\n  const user = await db.getUser(id)\r\n\r\n  if (!user) {\r\n    throw new HTTPException(404, { message: 'User not found' })\r\n  }\r\n\r\n  return c.json({ user })\r\n})\r\n\r\n// Server errors\r\napp.get('/data', async (c) => {\r\n  try {\r\n    const data = await fetchExternalAPI()\r\n    return c.json({ data })\r\n  } catch (error) {\r\n    // Let onError handle it\r\n    throw error\r\n  }\r\n})\r\n\r\n// Global error handler\r\napp.onError((err, c) => {\r\n  if (err instanceof HTTPException) {\r\n    return err.getResponse()\r\n  }\r\n\r\n  console.error('Unexpected error:', err)\r\n  return c.json({ error: 'Internal Server Error' }, 500)\r\n})\r\n\r\n// 404 handler\r\napp.notFound((c) => {\r\n  return c.json({ error: 'Not Found' }, 404)\r\n})\r\n```\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **8** documented issues:\r\n\r\n### Issue #1: RPC Type Inference Slow\r\n**Error**: IDE becomes slow with many routes\r\n**Source**: [hono/docs/guides/rpc](https://hono.dev/docs/guides/rpc)\r\n**Why It Happens**: Complex type instantiation from `typeof app` with many routes\r\n**Prevention**: Export specific route groups instead of entire app\r\n\r\n```typescript\r\n// ❌ Slow\r\nexport type AppType = typeof app\r\n\r\n// ✅ Fast\r\nconst userRoutes = app.get(...).post(...)\r\nexport type UserRoutes = typeof userRoutes\r\n```\r\n\r\n### Issue #2: Middleware Response Not Typed in RPC\r\n**Error**: Middleware responses not inferred by RPC client\r\n**Source**: [honojs/hono#2719](https://github.com/honojs/hono/issues/2719)\r\n**Why It Happens**: RPC mode doesn't infer middleware responses by default\r\n**Prevention**: Export specific route types that include middleware\r\n\r\n```typescript\r\nconst route = app.get(\r\n  '/data',\r\n  myMiddleware,\r\n  (c) => c.json({ data: 'value' })\r\n)\r\nexport type AppType = typeof route\r\n```\r\n\r\n### Issue #3: Validation Hook Confusion\r\n**Error**: Different validator libraries have different hook patterns\r\n**Source**: Context7 research\r\n**Why It Happens**: Each validator (@hono/zod-validator, @hono/valibot-validator, etc.) has slightly different APIs\r\n**Prevention**: This skill provides consistent patterns for all validators\r\n\r\n### Issue #4: HTTPException Misuse\r\n**Error**: Throwing plain Error instead of HTTPException\r\n**Source**: Official docs\r\n**Why It Happens**: Developers familiar with Express use `throw new Error()`\r\n**Prevention**: Always use `HTTPException` for client errors (400-499)\r\n\r\n```typescript\r\n// ❌ Wrong\r\nthrow new Error('Unauthorized')\r\n\r\n// ✅ Correct\r\nthrow new HTTPException(401, { message: 'Unauthorized' })\r\n```\r\n\r\n### Issue #5: Context Type Safety Lost\r\n**Error**: `c.set()` and `c.get()` without type inference\r\n**Source**: Official docs\r\n**Why It Happens**: Not defining `Variables` type in Hono generic\r\n**Prevention**: Always define Variables type\r\n\r\n```typescript\r\ntype Variables = {\r\n  user: { id: number; name: string }\r\n}\r\n\r\nconst app = new Hono<{ Variables: Variables }>()\r\n```\r\n\r\n### Issue #6: Missing Error Check After Middleware\r\n**Error**: Errors in handlers not caught\r\n**Source**: Official docs\r\n**Why It Happens**: Not checking `c.error` after `await next()`\r\n**Prevention**: Check `c.error` in middleware\r\n\r\n```typescript\r\napp.use('*', async (c, next) => {\r\n  await next()\r\n  if (c.error) {\r\n    console.error('Error:', c.error)\r\n  }\r\n})\r\n```\r\n\r\n### Issue #7: Direct Request Access Without Validation\r\n**Error**: Accessing `c.req.param()` or `c.req.query()` without validation\r\n**Source**: Best practices\r\n**Why It Happens**: Developers skip validation for speed\r\n**Prevention**: Always use validators and `c.req.valid()`\r\n\r\n```typescript\r\n// ❌ Wrong\r\nconst id = c.req.param('id') // string, no validation\r\n\r\n// ✅ Correct\r\napp.get('/users/:id', zValidator('param', idSchema), (c) => {\r\n  const { id } = c.req.valid('param') // validated UUID\r\n})\r\n```\r\n\r\n### Issue #8: Incorrect Middleware Order\r\n**Error**: Middleware executing in wrong order\r\n**Source**: Official docs\r\n**Why It Happens**: Misunderstanding middleware chain execution\r\n**Prevention**: Remember middleware runs top-to-bottom, `await next()` runs handler, then bottom-to-top\r\n\r\n```typescript\r\napp.use('*', async (c, next) => {\r\n  console.log('1: Before handler')\r\n  await next()\r\n  console.log('4: After handler')\r\n})\r\n\r\napp.use('*', async (c, next) => {\r\n  console.log('2: Before handler')\r\n  await next()\r\n  console.log('3: After handler')\r\n})\r\n\r\napp.get('/', (c) => {\r\n  console.log('Handler')\r\n  return c.json({})\r\n})\r\n\r\n// Output: 1, 2, Handler, 3, 4\r\n```\r\n\r\n---",
    "File Templates": "All templates are available in the `templates/` directory:\r\n\r\n- **routing-patterns.ts** - Route params, query params, wildcards, grouping\r\n- **middleware-composition.ts** - Middleware chaining, built-in middleware\r\n- **validation-zod.ts** - Zod validation with custom hooks\r\n- **validation-valibot.ts** - Valibot validation\r\n- **rpc-pattern.ts** - Type-safe RPC client/server\r\n- **error-handling.ts** - HTTPException, onError, custom errors\r\n- **context-extension.ts** - c.set/c.get, custom context types\r\n- **package.json** - All dependencies\r\n\r\nCopy these files to your project and customize as needed.\r\n\r\n---",
    "Official Documentation": "- **Hono**: https://hono.dev\r\n- **Hono Routing**: https://hono.dev/docs/api/routing\r\n- **Hono Middleware**: https://hono.dev/docs/guides/middleware\r\n- **Hono Validation**: https://hono.dev/docs/guides/validation\r\n- **Hono RPC**: https://hono.dev/docs/guides/rpc\r\n- **Hono Context**: https://hono.dev/docs/api/context\r\n- **Context7 Library ID**: `/llmstxt/hono_dev_llms-full_txt`\r\n\r\n---"
  }
}