{
  "description": "\"Cheminformatics toolkit for fine-grained molecular control. SMILES/SDF parsing, descriptors (MW, LogP, TPSA), fingerprints, substructure search, 2D/3D generation, similarity, reactions. For standard workflows with simpler interface, use datamol (wrapper around RDKit). Use rdkit for advanced control, custom sanitization, specialized algorithms.\"",
  "references": {
    "files": [
      "references/api_reference.md",
      "references/descriptors_reference.md",
      "references/smarts_patterns.md"
    ]
  },
  "content": "### 1. Molecular I/O and Creation\r\n\r\n**Reading Molecules:**\r\n\r\nRead molecular structures from various formats:\r\n\r\n```python\r\nfrom rdkit import Chem\r\n\r\nmol = Chem.MolFromSmiles('Cc1ccccc1')  # Returns Mol object or None\r\n\r\nmol = Chem.MolFromMolFile('path/to/file.mol')\r\n\r\nmol = Chem.MolFromMolBlock(mol_block_string)\r\n\r\nmol = Chem.MolFromInchi('InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H')\r\n```\r\n\r\n**Writing Molecules:**\r\n\r\nConvert molecules to text representations:\r\n\r\n```python\r\nsmiles = Chem.MolToSmiles(mol)\r\n\r\nmol_block = Chem.MolToMolBlock(mol)\r\n\r\ninchi = Chem.MolToInchi(mol)\r\n```\r\n\r\n**Batch Processing:**\r\n\r\nFor processing multiple molecules, use Supplier/Writer objects:\r\n\r\n```python\r\nsuppl = Chem.SDMolSupplier('molecules.sdf')\r\nfor mol in suppl:\r\n    if mol is not None:  # Check for parsing errors\r\n        # Process molecule\r\n        pass\r\n\r\nsuppl = Chem.SmilesMolSupplier('molecules.smi', titleLine=False)\r\n\r\nwith gzip.open('molecules.sdf.gz') as f:\r\n    suppl = Chem.ForwardSDMolSupplier(f)\r\n    for mol in suppl:\r\n        # Process molecule\r\n        pass\r\n\r\nsuppl = Chem.MultithreadedSDMolSupplier('molecules.sdf')\r\n\r\nwriter = Chem.SDWriter('output.sdf')\r\nfor mol in molecules:\r\n    writer.write(mol)\r\nwriter.close()\r\n```\r\n\r\n**Important Notes:**\r\n- All `MolFrom*` functions return `None` on failure with error messages\r\n- Always check for `None` before processing molecules\r\n- Molecules are automatically sanitized on import (validates valence, perceives aromaticity)\r\n\r\n### 2. Molecular Sanitization and Validation\r\n\r\nRDKit automatically sanitizes molecules during parsing, executing 13 steps including valence checking, aromaticity perception, and chirality assignment.\r\n\r\n**Sanitization Control:**\r\n\r\n```python\r\nmol = Chem.MolFromSmiles('C1=CC=CC=C1', sanitize=False)\r\n\r\nChem.SanitizeMol(mol)\r\n\r\nproblems = Chem.DetectChemistryProblems(mol)\r\nfor problem in problems:\r\n    print(problem.GetType(), problem.Message())\r\n\r\nfrom rdkit.Chem import rdMolStandardize\r\nChem.SanitizeMol(mol, sanitizeOps=Chem.SANITIZE_ALL ^ Chem.SANITIZE_PROPERTIES)\r\n```\r\n\r\n**Common Sanitization Issues:**\r\n- Atoms with explicit valence exceeding maximum allowed will raise exceptions\r\n- Invalid aromatic rings will cause kekulization errors\r\n- Radical electrons may not be properly assigned without explicit specification\r\n\r\n### 3. Molecular Analysis and Properties\r\n\r\n**Accessing Molecular Structure:**\r\n\r\n```python\r\nfor atom in mol.GetAtoms():\r\n    print(atom.GetSymbol(), atom.GetIdx(), atom.GetDegree())\r\n\r\nfor bond in mol.GetBonds():\r\n    print(bond.GetBeginAtomIdx(), bond.GetEndAtomIdx(), bond.GetBondType())\r\n\r\nring_info = mol.GetRingInfo()\r\nring_info.NumRings()\r\nring_info.AtomRings()  # Returns tuples of atom indices\r\n\r\natom = mol.GetAtomWithIdx(0)\r\natom.IsInRing()\r\natom.IsInRingSize(6)  # Check for 6-membered rings\r\n\r\nfrom rdkit.Chem import GetSymmSSSR\r\nrings = GetSymmSSSR(mol)\r\n```\r\n\r\n**Stereochemistry:**\r\n\r\n```python\r\nfrom rdkit.Chem import FindMolChiralCenters\r\nchiral_centers = FindMolChiralCenters(mol, includeUnassigned=True)\r\n\r\nfrom rdkit.Chem import AssignStereochemistryFrom3D\r\nAssignStereochemistryFrom3D(mol)\r\n\r\nbond = mol.GetBondWithIdx(0)\r\nstereo = bond.GetStereo()  # STEREONONE, STEREOZ, STEREOE, etc.\r\n```\r\n\r\n**Fragment Analysis:**\r\n\r\n```python\r\nfrags = Chem.GetMolFrags(mol, asMols=True)\r\n\r\nfrom rdkit.Chem import FragmentOnBonds\r\nfrag_mol = FragmentOnBonds(mol, [bond_idx1, bond_idx2])\r\n\r\nfrom rdkit.Chem.Scaffolds import MurckoScaffold\r\nscaffold = MurckoScaffold.GetScaffoldForMol(mol)\r\n```\r\n\r\n### 4. Molecular Descriptors and Properties\r\n\r\n**Basic Descriptors:**\r\n\r\n```python\r\nfrom rdkit.Chem import Descriptors\r\n\r\nmw = Descriptors.MolWt(mol)\r\nexact_mw = Descriptors.ExactMolWt(mol)\r\n\r\nlogp = Descriptors.MolLogP(mol)\r\n\r\ntpsa = Descriptors.TPSA(mol)\r\n\r\nhbd = Descriptors.NumHDonors(mol)\r\nhba = Descriptors.NumHAcceptors(mol)\r\n\r\nrot_bonds = Descriptors.NumRotatableBonds(mol)\r\n\r\naromatic_rings = Descriptors.NumAromaticRings(mol)\r\n```\r\n\r\n**Batch Descriptor Calculation:**\r\n\r\n```python\r\nall_descriptors = Descriptors.CalcMolDescriptors(mol)\r\n\r\ndescriptor_names = [desc[0] for desc in Descriptors._descList]\r\n```\r\n\r\n**Lipinski's Rule of Five:**\r\n\r\n```python\r\nmw = Descriptors.MolWt(mol) <= 500\r\nlogp = Descriptors.MolLogP(mol) <= 5\r\nhbd = Descriptors.NumHDonors(mol) <= 5\r\nhba = Descriptors.NumHAcceptors(mol) <= 10\r\n\r\nis_drug_like = mw and logp and hbd and hba\r\n```\r\n\r\n### 5. Fingerprints and Molecular Similarity\r\n\r\n**Fingerprint Types:**\r\n\r\n```python\r\nfrom rdkit.Chem import AllChem, RDKFingerprint\r\nfrom rdkit.Chem.AtomPairs import Pairs, Torsions\r\nfrom rdkit.Chem import MACCSkeys\r\n\r\nfp = Chem.RDKFingerprint(mol)\r\n\r\nfp = AllChem.GetMorganFingerprint(mol, radius=2)\r\nfp_bits = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, nBits=2048)\r\n\r\nfp = MACCSkeys.GenMACCSKeys(mol)\r\n\r\nfp = Pairs.GetAtomPairFingerprint(mol)\r\n\r\nfp = Torsions.GetTopologicalTorsionFingerprint(mol)\r\n\r\nfrom rdkit.Avalon import pyAvalonTools\r\nfp = pyAvalonTools.GetAvalonFP(mol)\r\n```\r\n\r\n**Similarity Calculation:**\r\n\r\n```python\r\nfrom rdkit import DataStructs\r\n\r\nfp1 = AllChem.GetMorganFingerprintAsBitVect(mol1, radius=2)\r\nfp2 = AllChem.GetMorganFingerprintAsBitVect(mol2, radius=2)\r\nsimilarity = DataStructs.TanimotoSimilarity(fp1, fp2)\r\n\r\nsimilarities = DataStructs.BulkTanimotoSimilarity(fp1, [fp2, fp3, fp4])\r\n\r\ndice = DataStructs.DiceSimilarity(fp1, fp2)\r\ncosine = DataStructs.CosineSimilarity(fp1, fp2)\r\n```\r\n\r\n**Clustering and Diversity:**\r\n\r\n```python\r\nfrom rdkit.ML.Cluster import Butina\r\n\r\ndists = []\r\nfps = [AllChem.GetMorganFingerprintAsBitVect(mol, 2) for mol in mols]\r\nfor i in range(len(fps)):\r\n    sims = DataStructs.BulkTanimotoSimilarity(fps[i], fps[:i])\r\n    dists.extend([1-sim for sim in sims])\r\n\r\nclusters = Butina.ClusterData(dists, len(fps), distThresh=0.3, isDistData=True)\r\n```\r\n\r\n### 6. Substructure Searching and SMARTS\r\n\r\n**Basic Substructure Matching:**\r\n\r\n```python\r\nquery = Chem.MolFromSmarts('[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1')  # Benzene ring\r\n\r\nhas_match = mol.HasSubstructMatch(query)\r\n\r\nmatches = mol.GetSubstructMatches(query)\r\n\r\nmatch = mol.GetSubstructMatch(query)\r\n```\r\n\r\n**Common SMARTS Patterns:**\r\n\r\n```python\r\nprimary_alcohol = Chem.MolFromSmarts('[CH2][OH1]')\r\n\r\ncarboxylic_acid = Chem.MolFromSmarts('C(=O)[OH]')\r\n\r\namide = Chem.MolFromSmarts('C(=O)N')\r\n\r\naromatic_n = Chem.MolFromSmarts('[nR]')  # Aromatic nitrogen in ring\r\n\r\nmacrocycle = Chem.MolFromSmarts('[r{12-}]')\r\n```\r\n\r\n**Matching Rules:**\r\n- Unspecified properties in query match any value in target\r\n- Hydrogens are ignored unless explicitly specified\r\n- Charged query atom won't match uncharged target atom\r\n- Aromatic query atom won't match aliphatic target atom (unless query is generic)\r\n\r\n### 7. Chemical Reactions\r\n\r\n**Reaction SMARTS:**\r\n\r\n```python\r\nfrom rdkit.Chem import AllChem\r\n\r\nrxn = AllChem.ReactionFromSmarts('[C:1]=[O:2]>>[C:1][O:2]')  # Ketone reduction\r\n\r\nreactants = (mol1,)\r\nproducts = rxn.RunReactants(reactants)\r\n\r\nfor product_set in products:\r\n    for product in product_set:\r\n        # Sanitize product\r\n        Chem.SanitizeMol(product)\r\n```\r\n\r\n**Reaction Features:**\r\n- Atom mapping preserves specific atoms between reactants and products\r\n- Dummy atoms in products are replaced by corresponding reactant atoms\r\n- \"Any\" bonds inherit bond order from reactants\r\n- Chirality preserved unless explicitly changed\r\n\r\n**Reaction Similarity:**\r\n\r\n```python\r\nfp = AllChem.CreateDifferenceFingerprintForReaction(rxn)\r\n\r\nsimilarity = DataStructs.TanimotoSimilarity(fp1, fp2)\r\n```\r\n\r\n### 8. 2D and 3D Coordinate Generation\r\n\r\n**2D Coordinate Generation:**\r\n\r\n```python\r\nfrom rdkit.Chem import AllChem\r\n\r\nAllChem.Compute2DCoords(mol)\r\n\r\ntemplate = Chem.MolFromSmiles('c1ccccc1')\r\nAllChem.Compute2DCoords(template)\r\nAllChem.GenerateDepictionMatching2DStructure(mol, template)\r\n```\r\n\r\n**3D Coordinate Generation and Conformers:**\r\n\r\n```python\r\nAllChem.EmbedMolecule(mol, randomSeed=42)\r\n\r\nconf_ids = AllChem.EmbedMultipleConfs(mol, numConfs=10, randomSeed=42)\r\n\r\nAllChem.UFFOptimizeMolecule(mol)  # UFF force field\r\nAllChem.MMFFOptimizeMolecule(mol)  # MMFF94 force field\r\n\r\nfor conf_id in conf_ids:\r\n    AllChem.MMFFOptimizeMolecule(mol, confId=conf_id)\r\n\r\nfrom rdkit.Chem import AllChem\r\nrms = AllChem.GetConformerRMS(mol, conf_id1, conf_id2)\r\n\r\nAllChem.AlignMol(probe_mol, ref_mol)\r\n```\r\n\r\n**Constrained Embedding:**\r\n\r\n```python\r\nAllChem.ConstrainedEmbed(mol, core_mol)\r\n```\r\n\r\n### 9. Molecular Visualization\r\n\r\n**Basic Drawing:**\r\n\r\n```python\r\nfrom rdkit.Chem import Draw\r\n\r\nimg = Draw.MolToImage(mol, size=(300, 300))\r\nimg.save('molecule.png')\r\n\r\nDraw.MolToFile(mol, 'molecule.png')\r\n\r\nmols = [mol1, mol2, mol3, mol4]\r\nimg = Draw.MolsToGridImage(mols, molsPerRow=2, subImgSize=(200, 200))\r\n```\r\n\r\n**Highlighting Substructures:**\r\n\r\n```python\r\nquery = Chem.MolFromSmarts('c1ccccc1')\r\nmatch = mol.GetSubstructMatch(query)\r\n\r\nimg = Draw.MolToImage(mol, highlightAtoms=match)\r\n\r\nhighlight_colors = {atom_idx: (1, 0, 0) for atom_idx in match}  # Red\r\nimg = Draw.MolToImage(mol, highlightAtoms=match,\r\n                      highlightAtomColors=highlight_colors)\r\n```\r\n\r\n**Customizing Visualization:**\r\n\r\n```python\r\nfrom rdkit.Chem.Draw import rdMolDraw2D\r\n\r\ndrawer = rdMolDraw2D.MolDraw2DCairo(300, 300)\r\nopts = drawer.drawOptions()\r\n\r\nopts.addAtomIndices = True\r\nopts.addStereoAnnotation = True\r\nopts.bondLineWidth = 2\r\n\r\ndrawer.DrawMolecule(mol)\r\ndrawer.FinishDrawing()\r\n\r\nwith open('molecule.png', 'wb') as f:\r\n    f.write(drawer.GetDrawingText())\r\n```\r\n\r\n**Jupyter Notebook Integration:**\r\n\r\n```python\r\nfrom rdkit.Chem.Draw import IPythonConsole\r\n\r\nIPythonConsole.ipython_useSVG = True  # Use SVG instead of PNG\r\nIPythonConsole.molSize = (300, 300)   # Default size\r\n\r\nmol  # Shows molecule image\r\n```\r\n\r\n**Visualizing Fingerprint Bits:**\r\n\r\n```python\r\nfrom rdkit.Chem import Draw\r\n\r\nbit_info = {}\r\nfp = AllChem.GetMorganFingerprintAsBitVect(mol, radius=2, bitInfo=bit_info)\r\n\r\nimg = Draw.DrawMorganBit(mol, bit_id, bit_info)\r\n```\r\n\r\n### 10. Molecular Modification\r\n\r\n**Adding/Removing Hydrogens:**\r\n\r\n```python\r\nmol_h = Chem.AddHs(mol)\r\n\r\nmol = Chem.RemoveHs(mol_h)\r\n```\r\n\r\n**Kekulization and Aromaticity:**\r\n\r\n```python\r\nChem.Kekulize(mol)\r\n\r\nChem.SetAromaticity(mol)\r\n```\r\n\r\n**Replacing Substructures:**\r\n\r\n```python\r\nquery = Chem.MolFromSmarts('c1ccccc1')  # Benzene\r\nreplacement = Chem.MolFromSmiles('C1CCCCC1')  # Cyclohexane\r\n\r\nnew_mol = Chem.ReplaceSubstructs(mol, query, replacement)[0]\r\n```\r\n\r\n**Neutralizing Charges:**\r\n\r\n```python\r\nfrom rdkit.Chem.MolStandardize import rdMolStandardize\r\n\r\nuncharger = rdMolStandardize.Uncharger()\r\nmol_neutral = uncharger.uncharge(mol)\r\n```\r\n\r\n### 11. Working with Molecular Hashes and Standardization\r\n\r\n**Molecular Hashing:**\r\n\r\n```python\r\nfrom rdkit.Chem import rdMolHash\r\n\r\nscaffold_hash = rdMolHash.MolHash(mol, rdMolHash.HashFunction.MurckoScaffold)\r\n\r\ncanonical_hash = rdMolHash.MolHash(mol, rdMolHash.HashFunction.CanonicalSmiles)\r\n\r\nregio_hash = rdMolHash.MolHash(mol, rdMolHash.HashFunction.Regioisomer)\r\n```\r\n\r\n**Randomized SMILES:**\r\n\r\n```python\r\nfrom rdkit.Chem import MolToRandomSmilesVect\r\n\r\nrandom_smiles = MolToRandomSmilesVect(mol, numSmiles=10, randomSeed=42)\r\n```\r\n\r\n### 12. Pharmacophore and 3D Features\r\n\r\n**Pharmacophore Features:**\r\n\r\n```python\r\nfrom rdkit.Chem import ChemicalFeatures\r\nfrom rdkit import RDConfig\r\nimport os\r\n\r\nfdef_path = os.path.join(RDConfig.RDDataDir, 'BaseFeatures.fdef')\r\nfactory = ChemicalFeatures.BuildFeatureFactory(fdef_path)\r\n\r\n\r\n### Error Handling\r\n\r\nAlways check for `None` when parsing molecules:\r\n\r\n```python\r\nmol = Chem.MolFromSmiles(smiles)\r\nif mol is None:\r\n    print(f\"Failed to parse: {smiles}\")\r\n    continue\r\n```\r\n\r\n### Performance Optimization\r\n\r\n**Use binary formats for storage:**\r\n\r\n```python\r\nimport pickle\r\n\r\nwith open('molecules.pkl', 'wb') as f:\r\n    pickle.dump(mols, f)\r\n\r\nwith open('molecules.pkl', 'rb') as f:\r\n    mols = pickle.load(f)\r\n```\r\n\r\n**Use bulk operations:**\r\n\r\n```python\r\nfps = [AllChem.GetMorganFingerprintAsBitVect(mol, 2) for mol in mols]\r\n\r\nsimilarities = DataStructs.BulkTanimotoSimilarity(fps[0], fps[1:])\r\n```\r\n\r\n### Thread Safety\r\n\r\nRDKit operations are generally thread-safe for:\r\n- Molecule I/O (SMILES, mol blocks)\r\n- Coordinate generation\r\n- Fingerprinting and descriptors\r\n- Substructure searching\r\n- Reactions\r\n- Drawing\r\n\r\n**Not thread-safe:** MolSuppliers when accessed concurrently.\r\n\r\n### Memory Management\r\n\r\nFor large datasets:\r\n\r\n```python\r\nwith open('large.sdf') as f:\r\n    suppl = Chem.ForwardSDMolSupplier(f)\r\n    for mol in suppl:\r\n        # Process one molecule at a time\r\n        pass",
  "name": "rdkit",
  "id": "scientific-pkg-rdkit",
  "sections": {
    "Common Pitfalls": "1. **Forgetting to check for None:** Always validate molecules after parsing\r\n2. **Sanitization failures:** Use `DetectChemistryProblems()` to debug\r\n3. **Missing hydrogens:** Use `AddHs()` when calculating properties that depend on hydrogen\r\n4. **2D vs 3D:** Generate appropriate coordinates before visualization or 3D analysis\r\n5. **SMARTS matching rules:** Remember that unspecified properties match anything\r\n6. **Thread safety with MolSuppliers:** Don't share supplier objects across threads",
    "Overview": "RDKit is a comprehensive cheminformatics library providing Python APIs for molecular analysis and manipulation. This skill provides guidance for reading/writing molecular structures, calculating descriptors, fingerprinting, substructure searching, chemical reactions, 2D/3D coordinate generation, and molecular visualization. Use this skill for drug discovery, computational chemistry, and cheminformatics research tasks.",
    "Best Practices": "suppl = Chem.MultithreadedSDMolSupplier('large.sdf', numWriterThreads=4)\r\n```",
    "Resources": "### references/\r\n\r\nThis skill includes detailed API reference documentation:\r\n\r\n- `api_reference.md` - Comprehensive listing of RDKit modules, functions, and classes organized by functionality\r\n- `descriptors_reference.md` - Complete list of available molecular descriptors with descriptions\r\n- `smarts_patterns.md` - Common SMARTS patterns for functional groups and structural features\r\n\r\nLoad these references when needing specific API details, parameter information, or pattern examples.\r\n\r\n### scripts/\r\n\r\nExample scripts for common RDKit workflows:\r\n\r\n- `molecular_properties.py` - Calculate comprehensive molecular properties and descriptors\r\n- `similarity_search.py` - Perform fingerprint-based similarity screening\r\n- `substructure_filter.py` - Filter molecules by substructure patterns\r\n\r\nThese scripts can be executed directly or used as templates for custom workflows.",
    "Core Capabilities": "features = factory.GetFeaturesForMol(mol)\r\n\r\nfor feat in features:\r\n    print(feat.GetFamily(), feat.GetType(), feat.GetAtomIds())\r\n```",
    "Common Workflows": "### Drug-likeness Analysis\r\n\r\n```python\r\nfrom rdkit import Chem\r\nfrom rdkit.Chem import Descriptors\r\n\r\ndef analyze_druglikeness(smiles):\r\n    mol = Chem.MolFromSmiles(smiles)\r\n    if mol is None:\r\n        return None\r\n\r\n    # Calculate Lipinski descriptors\r\n    results = {\r\n        'MW': Descriptors.MolWt(mol),\r\n        'LogP': Descriptors.MolLogP(mol),\r\n        'HBD': Descriptors.NumHDonors(mol),\r\n        'HBA': Descriptors.NumHAcceptors(mol),\r\n        'TPSA': Descriptors.TPSA(mol),\r\n        'RotBonds': Descriptors.NumRotatableBonds(mol)\r\n    }\r\n\r\n    # Check Lipinski's Rule of Five\r\n    results['Lipinski'] = (\r\n        results['MW'] <= 500 and\r\n        results['LogP'] <= 5 and\r\n        results['HBD'] <= 5 and\r\n        results['HBA'] <= 10\r\n    )\r\n\r\n    return results\r\n```\r\n\r\n### Similarity Screening\r\n\r\n```python\r\nfrom rdkit import Chem\r\nfrom rdkit.Chem import AllChem\r\nfrom rdkit import DataStructs\r\n\r\ndef similarity_screen(query_smiles, database_smiles, threshold=0.7):\r\n    query_mol = Chem.MolFromSmiles(query_smiles)\r\n    query_fp = AllChem.GetMorganFingerprintAsBitVect(query_mol, 2)\r\n\r\n    hits = []\r\n    for idx, smiles in enumerate(database_smiles):\r\n        mol = Chem.MolFromSmiles(smiles)\r\n        if mol:\r\n            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2)\r\n            sim = DataStructs.TanimotoSimilarity(query_fp, fp)\r\n            if sim >= threshold:\r\n                hits.append((idx, smiles, sim))\r\n\r\n    return sorted(hits, key=lambda x: x[2], reverse=True)\r\n```\r\n\r\n### Substructure Filtering\r\n\r\n```python\r\nfrom rdkit import Chem\r\n\r\ndef filter_by_substructure(smiles_list, pattern_smarts):\r\n    query = Chem.MolFromSmarts(pattern_smarts)\r\n\r\n    hits = []\r\n    for smiles in smiles_list:\r\n        mol = Chem.MolFromSmiles(smiles)\r\n        if mol and mol.HasSubstructMatch(query):\r\n            hits.append(smiles)\r\n\r\n    return hits\r\n```"
  }
}