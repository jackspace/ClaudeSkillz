{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/common-errors.md",
      "references/example-reference.md",
      "references/naming-strategies.md",
      "references/persistence-guide.md",
      "references/session-management.md"
    ]
  },
  "content": "**Status**: Production Ready (Open Beta)\r\n**Last Updated**: 2025-10-29\r\n**Dependencies**: `cloudflare-worker-base`, `cloudflare-durable-objects` (recommended for understanding)\r\n**Latest Versions**: `@cloudflare/sandbox@0.4.12`, Docker image: `cloudflare/sandbox:0.4.12`\r\n\r\n---\r\n\r\n\r\n### wrangler.jsonc (Full Example)\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-sandbox-app\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-29\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n\r\n  \"containers\": [{\r\n    \"class_name\": \"Sandbox\",\r\n    \"image\": \"cloudflare/sandbox:0.4.12\",\r\n    \"instance_type\": \"lite\"\r\n  }],\r\n\r\n  \"durable_objects\": {\r\n    \"bindings\": [{\r\n      \"class_name\": \"Sandbox\",\r\n      \"name\": \"Sandbox\"\r\n    }]\r\n  },\r\n\r\n  \"migrations\": [{\r\n    \"tag\": \"v1\",\r\n    \"new_sqlite_classes\": [\"Sandbox\"]\r\n  }],\r\n\r\n  \"env\": {\r\n    \"ANTHROPIC_API_KEY\": {\r\n      \"description\": \"Optional: For AI features\"\r\n    }\r\n  },\r\n\r\n  \"observability\": {\r\n    \"enabled\": true\r\n  }\r\n}\r\n```\r\n\r\n**Why these settings:**\r\n- `nodejs_compat`: Required for SDK to work\r\n- `containers.image`: Specific version ensures consistency\r\n- `instance_type: \"lite\"`: Smallest instance, upgrade to \"large\" for more resources\r\n- `migrations`: Registers Sandbox Durable Object class\r\n- `observability`: Enable logging for debugging\r\n\r\n### Dockerfile (Optional - For Local Dev)\r\n\r\nOnly needed if extending base image:\r\n\r\n```dockerfile\r\nFROM cloudflare/sandbox:0.4.12\r\n\r\nRUN apt-get update && apt-get install -y \\\r\n    ffmpeg \\\r\n    imagemagick \\\r\n    && rm -rf /var/lib/apt/lists/*\r\n\r\n\r\n### Scripts (scripts/)\r\n\r\n- `setup-sandbox-binding.sh` - Interactive wrangler.jsonc configuration\r\n- `test-sandbox.ts` - Validation script to test sandbox setup\r\n\r\n**Example Usage:**\r\n```bash\r\n./scripts/setup-sandbox-binding.sh",
  "name": "cloudflare-sandbox",
  "id": "cloudflare-sandbox",
  "sections": {
    "Critical Container Lifecycle (Most Important Section!)": "### Container States\r\n\r\n```\r\n┌─────────┐  First request  ┌────────┐  ~10 min idle  ┌──────┐\r\n│ Not     │ ───────────────>│ Active │ ─────────────> │ Idle │\r\n│ Created │                 │        │                │      │\r\n└─────────┘                 └───┬────┘                └──┬───┘\r\n                                │ ^                      │\r\n                                │ │ New request          │\r\n                                │ └──────────────────────┘\r\n                                │                         │\r\n                                ▼                         ▼\r\n                            Files persist          ALL FILES DELETED\r\n                            Processes run          ALL PROCESSES KILLED\r\n                            State maintained       ALL STATE RESET\r\n```\r\n\r\n### The #1 Gotcha: Ephemeral by Default\r\n\r\n**While Container is Active** (~10 min after last request):\r\n- ✅ Files in `/workspace`, `/tmp`, `/home` persist\r\n- ✅ Background processes keep running\r\n- ✅ Shell environment variables remain\r\n- ✅ Session working directories preserved\r\n\r\n**When Container Goes Idle** (after inactivity):\r\n- ❌ **ALL files deleted** (entire filesystem reset)\r\n- ❌ **ALL processes terminated**\r\n- ❌ **ALL shell state lost**\r\n- ⚠️  Next request creates **fresh container from scratch**\r\n\r\n**This is NOT like a traditional server**. Sandboxes are ephemeral by design.\r\n\r\n### Handling Persistence\r\n\r\n**For Important Data**: Use external storage\r\n```typescript\r\n// Save to R2 before container goes idle\r\nawait sandbox.writeFile('/workspace/data.txt', content);\r\nconst fileData = await sandbox.readFile('/workspace/data.txt');\r\nawait env.R2.put('backup/data.txt', fileData);\r\n\r\n// Restore on next request\r\nconst restored = await env.R2.get('backup/data.txt');\r\nif (restored) {\r\n  await sandbox.writeFile('/workspace/data.txt', await restored.text());\r\n}\r\n```\r\n\r\n**For Build Artifacts**: Accept ephemerality or use caching\r\n```typescript\r\n// Check if setup needed (handles cold starts)\r\nconst exists = await sandbox.readdir('/workspace/project').catch(() => null);\r\nif (!exists) {\r\n  await sandbox.gitCheckout(repoUrl, '/workspace/project');\r\n  await sandbox.exec('npm install', { cwd: '/workspace/project' });\r\n}\r\n// Now safe to run build\r\nawait sandbox.exec('npm run build', { cwd: '/workspace/project' });\r\n```\r\n\r\n---",
    "Complete Setup Checklist": "- [ ] `npm install @cloudflare/sandbox@latest`\r\n- [ ] Add `nodejs_compat` to compatibility_flags\r\n- [ ] Add containers configuration with correct image version\r\n- [ ] Add Durable Objects binding\r\n- [ ] Add migrations for Sandbox class\r\n- [ ] Export Sandbox class in Worker: `export { Sandbox } from '@cloudflare/sandbox'`\r\n- [ ] Docker Desktop running (local dev only)\r\n- [ ] Test with simple exec command\r\n- [ ] Verify exit codes are being checked\r\n- [ ] Implement cleanup for ephemeral sandboxes\r\n- [ ] Test cold start behavior\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/common-errors.md` for specific error solutions\r\n2. Verify all steps in wrangler.jsonc configuration\r\n3. Check official docs: https://developers.cloudflare.com/sandbox/\r\n4. Ensure Docker is running for local development\r\n5. Confirm package version matches Docker image version",
    "Known Issues Prevention": "This skill prevents **10** documented issues:\r\n\r\n### Issue #1: Missing nodejs_compat Flag\r\n**Error**: `ReferenceError: fetch is not defined` or `Buffer is not defined`\r\n**Source**: https://developers.cloudflare.com/sandbox/get-started/\r\n**Why It Happens**: SDK requires Node.js APIs not available in standard Workers\r\n**Prevention**: Add `\"compatibility_flags\": [\"nodejs_compat\"]` to wrangler.jsonc\r\n\r\n### Issue #2: Missing Migrations\r\n**Error**: `Error: Class 'Sandbox' not found`\r\n**Source**: https://developers.cloudflare.com/durable-objects/\r\n**Why It Happens**: Durable Objects must be registered via migrations\r\n**Prevention**: Include migrations array in wrangler.jsonc\r\n\r\n### Issue #3: Assuming File Persistence\r\n**Error**: Files disappear after inactivity\r\n**Source**: https://developers.cloudflare.com/sandbox/concepts/sandboxes/\r\n**Why It Happens**: Containers go idle after ~10 min, all state reset\r\n**Prevention**: Use external storage (R2/KV) or check existence on each request\r\n\r\n### Issue #4: Session Directory Confusion\r\n**Error**: Commands execute in wrong directory\r\n**Source**: https://developers.cloudflare.com/sandbox/concepts/sessions/\r\n**Why It Happens**: Each exec() uses new session unless explicitly specified\r\n**Prevention**: Create session with `createSession()`, pass to all related commands\r\n\r\n### Issue #5: Ignoring Exit Codes\r\n**Error**: Assuming command succeeded when it failed\r\n**Source**: Shell best practices\r\n**Why It Happens**: Not checking `result.success` or `result.exitCode`\r\n**Prevention**: Always check: `if (!result.success) throw new Error(result.stderr)`\r\n\r\n### Issue #6: Not Handling Cold Starts\r\n**Error**: Commands fail because dependencies aren't installed\r\n**Source**: https://developers.cloudflare.com/sandbox/concepts/sandboxes/\r\n**Why It Happens**: Container resets after idle period\r\n**Prevention**: Check if setup needed before running commands\r\n\r\n### Issue #7: Docker Not Running (Local Dev)\r\n**Error**: `Failed to build container` during local development\r\n**Source**: https://developers.cloudflare.com/sandbox/get-started/\r\n**Why It Happens**: Local dev requires Docker daemon\r\n**Prevention**: Ensure Docker Desktop is running before `npm run dev`\r\n\r\n### Issue #8: Version Mismatch (Package vs Docker Image)\r\n**Error**: API methods not available or behaving unexpectedly\r\n**Source**: GitHub issues\r\n**Why It Happens**: npm package version doesn't match Docker image version\r\n**Prevention**: Keep `@cloudflare/sandbox` package and `cloudflare/sandbox` image in sync\r\n\r\n### Issue #9: Not Cleaning Up Ephemeral Sandboxes\r\n**Error**: Resource exhaustion, unexpected costs\r\n**Source**: Resource management best practices\r\n**Why It Happens**: Creating sandboxes without destroying them\r\n**Prevention**: `await sandbox.destroy()` in finally block for temp sandboxes\r\n\r\n### Issue #10: Command Injection Vulnerability\r\n**Error**: Security breach from unsanitized user input\r\n**Source**: Security best practices\r\n**Why It Happens**: Passing user input directly to `exec()`\r\n**Prevention**: Use code interpreter API or validate/sanitize input thoroughly\r\n\r\n---",
    "Core API Reference": "### Getting a Sandbox\r\n\r\n```typescript\r\nimport { getSandbox } from '@cloudflare/sandbox';\r\n\r\nconst sandbox = getSandbox(env.Sandbox, 'unique-sandbox-id');\r\n// Creates new sandbox if doesn't exist, or gets existing one\r\n```\r\n\r\n### Executing Commands\r\n\r\n```typescript\r\n// Basic execution\r\nconst result = await sandbox.exec('python3 script.py');\r\nconsole.log(result.stdout);   // Standard output\r\nconsole.log(result.stderr);   // Standard error\r\nconsole.log(result.exitCode); // Exit code (0 = success)\r\nconsole.log(result.success);  // Boolean (exitCode === 0)\r\n\r\n// With options\r\nconst result = await sandbox.exec('npm install', {\r\n  cwd: '/workspace/project',        // Working directory\r\n  timeout: 120000,                   // Timeout in ms (default: 30s)\r\n  session: sessionId,                // Session ID\r\n  env: { NODE_ENV: 'production' }   // Environment variables\r\n});\r\n\r\n// Always check exit codes!\r\nif (!result.success) {\r\n  throw new Error(`Command failed: ${result.stderr}`);\r\n}\r\n```\r\n\r\n### File Operations\r\n\r\n```typescript\r\n// Write file\r\nawait sandbox.writeFile('/workspace/data.txt', 'content');\r\n\r\n// Read file\r\nconst content = await sandbox.readFile('/workspace/data.txt');\r\n\r\n// Create directory\r\nawait sandbox.mkdir('/workspace/project', { recursive: true });\r\n\r\n// List directory\r\nconst files = await sandbox.readdir('/workspace');\r\nconsole.log(files); // ['data.txt', 'project']\r\n\r\n// Delete file/directory\r\nawait sandbox.rm('/workspace/data.txt');\r\nawait sandbox.rm('/workspace/project', { recursive: true });\r\n```\r\n\r\n### Git Operations\r\n\r\n```typescript\r\n// Clone repository (optimized, faster than exec('git clone'))\r\nawait sandbox.gitCheckout(\r\n  'https://github.com/user/repo',\r\n  '/workspace/repo'\r\n);\r\n\r\n// Now use standard git commands\r\nawait sandbox.exec('git status', { cwd: '/workspace/repo' });\r\nawait sandbox.exec('git diff', { cwd: '/workspace/repo' });\r\n```\r\n\r\n### Code Interpreter (Jupyter-like)\r\n\r\n```typescript\r\n// Create Python context\r\nconst ctx = await sandbox.createCodeContext({ language: 'python' });\r\n\r\n// Execute code - last expression auto-returned\r\nconst result = await sandbox.runCode(`\r\nimport pandas as pd\r\ndf = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\r\ndf['a'].sum()  # This value is automatically returned\r\n`, { context: ctx });\r\n\r\nconsole.log(result.results[0].text); // \"6\"\r\nconsole.log(result.logs); // Output from print() statements\r\nconsole.log(result.error); // Any errors\r\n```\r\n\r\n### Background Processes\r\n\r\n```typescript\r\n// Start long-running process\r\nconst proc = await sandbox.spawn('python server.py');\r\nconsole.log(proc.pid);\r\n\r\n// Check if still running\r\nconst running = await sandbox.isProcessRunning(proc.pid);\r\n\r\n// Kill process\r\nawait sandbox.killProcess(proc.pid);\r\n```\r\n\r\n### Cleanup\r\n\r\n```typescript\r\n// Destroy sandbox permanently\r\nawait sandbox.destroy();\r\n// All files deleted, container removed, cannot be recovered\r\n```\r\n\r\n---",
    "Package Versions (Verified 2025-10-29)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"@cloudflare/sandbox\": \"^0.4.12\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"wrangler\": \"^3.80.0\",\r\n    \"@cloudflare/workers-types\": \"^4.20241106.0\"\r\n  }\r\n}\r\n```\r\n\r\n**Docker Image**: `cloudflare/sandbox:0.4.12`\r\n\r\n---",
    "Sandbox Naming Strategies": "### Per-User Sandboxes (Persistent Workspace)\r\n\r\n```typescript\r\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}`);\r\n```\r\n\r\n**Pros**: User's work persists while actively using (10 min idle time)\r\n**Cons**: Geographic lock-in (first request determines location)\r\n**Use Cases**: Interactive notebooks, IDEs, persistent workspaces\r\n\r\n### Per-Session Sandboxes (Fresh Each Time)\r\n\r\n```typescript\r\nconst sandboxId = `session-${Date.now()}-${crypto.randomUUID()}`;\r\nconst sandbox = getSandbox(env.Sandbox, sandboxId);\r\n// Always destroy after use\r\nawait sandbox.destroy();\r\n```\r\n\r\n**Pros**: Clean environment, no state pollution\r\n**Cons**: No persistence between requests\r\n**Use Cases**: One-shot code execution, CI/CD, testing\r\n\r\n### Per-Task Sandboxes (Idempotent & Traceable)\r\n\r\n```typescript\r\nconst sandbox = getSandbox(env.Sandbox, `build-${repoName}-${commitSha}`);\r\n```\r\n\r\n**Pros**: Reproducible, debuggable, cacheable\r\n**Cons**: Need explicit cleanup strategy\r\n**Use Cases**: Build systems, data pipelines, automated workflows\r\n\r\n---",
    "Troubleshooting": "### Problem: \"Class 'Sandbox' not found\"\r\n**Solution**: Add migrations to wrangler.jsonc and ensure `export { Sandbox }` in Worker\r\n\r\n### Problem: Files disappear after some time\r\n**Solution**: Container goes idle after ~10 min. Use R2/KV for persistence or rebuild environment\r\n\r\n### Problem: Commands execute in wrong directory\r\n**Solution**: Create session with `createSession()`, pass sessionId to all related commands\r\n\r\n### Problem: Docker error during local dev\r\n**Solution**: Ensure Docker Desktop is running before `npm run dev`\r\n\r\n### Problem: \"fetch is not defined\"\r\n**Solution**: Add `\"compatibility_flags\": [\"nodejs_compat\"]` to wrangler.jsonc\r\n\r\n---",
    "Critical Rules": "### Always Do\r\n\r\n✅ **Check exit codes** - `if (!result.success) { handle error }`\r\n✅ **Use sessions for multi-step workflows** - Preserve working directory\r\n✅ **Handle cold starts** - Check if files exist before assuming they're there\r\n✅ **Set timeouts** - Prevent hanging on long operations\r\n✅ **Destroy ephemeral sandboxes** - Cleanup temp/session-based sandboxes\r\n✅ **Use external storage for persistence** - R2/KV/D1 for important data\r\n✅ **Validate user input** - Sanitize before exec() to prevent command injection\r\n✅ **Export Sandbox class** - `export { Sandbox } from '@cloudflare/sandbox'`\r\n\r\n### Never Do\r\n\r\n❌ **Assume files persist after idle** - Container resets after ~10 min\r\n❌ **Ignore exit codes** - Always check `result.success` or `result.exitCode`\r\n❌ **Chain commands without sessions** - `cd /dir` then `ls` won't work\r\n❌ **Execute unsanitized user input** - Use code interpreter or validate thoroughly\r\n❌ **Forget nodejs_compat flag** - Required in wrangler.jsonc\r\n❌ **Skip migrations** - Durable Objects need migration entries\r\n❌ **Use .workers.dev for preview URLs** - Need custom domain\r\n❌ **Create unlimited sandboxes** - Destroy ephemeral ones to avoid leaks\r\n\r\n---",
    "Official Documentation": "- **Cloudflare Sandboxes**: https://developers.cloudflare.com/sandbox/\r\n- **Architecture Guide**: https://developers.cloudflare.com/sandbox/concepts/architecture/\r\n- **API Reference**: https://developers.cloudflare.com/sandbox/api-reference/\r\n- **Durable Objects**: https://developers.cloudflare.com/durable-objects/\r\n- **GitHub SDK**: https://github.com/cloudflare/sandbox-sdk\r\n\r\n---",
    "Advanced Topics": "### Geographic Distribution\r\n\r\nFirst request to a sandbox ID determines its geographic location (via Durable Objects).\r\n\r\n**For Global Apps**:\r\n```typescript\r\n// Option 1: Multiple sandboxes per user (better latency)\r\nconst region = request.cf?.colo || 'default';\r\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}-${region}`);\r\n\r\n// Option 2: Single sandbox (simpler, higher latency for distant users)\r\nconst sandbox = getSandbox(env.Sandbox, `user-${userId}`);\r\n```\r\n\r\n### Error Handling Strategy\r\n\r\n```typescript\r\nasync function safeSandboxExec(\r\n  sandbox: Sandbox,\r\n  cmd: string,\r\n  options?: any\r\n) {\r\n  try {\r\n    const result = await sandbox.exec(cmd, {\r\n      ...options,\r\n      timeout: options?.timeout || 30000\r\n    });\r\n\r\n    if (!result.success) {\r\n      console.error(`Command failed: ${cmd}`, {\r\n        exitCode: result.exitCode,\r\n        stderr: result.stderr\r\n      });\r\n\r\n      return {\r\n        success: false,\r\n        error: result.stderr,\r\n        exitCode: result.exitCode\r\n      };\r\n    }\r\n\r\n    return {\r\n      success: true,\r\n      output: result.stdout,\r\n      exitCode: 0\r\n    };\r\n  } catch (error) {\r\n    console.error(`Sandbox error:`, error);\r\n    return {\r\n      success: false,\r\n      error: error.message,\r\n      exitCode: -1\r\n    };\r\n  }\r\n}\r\n```\r\n\r\n### Security Hardening\r\n\r\n```typescript\r\n// Input validation\r\nfunction sanitizeCommand(input: string): string {\r\n  const dangerous = ['rm -rf', '$(', '`', '&&', '||', ';', '|'];\r\n  for (const pattern of dangerous) {\r\n    if (input.includes(pattern)) {\r\n      throw new Error(`Dangerous pattern detected: ${pattern}`);\r\n    }\r\n  }\r\n  return input;\r\n}\r\n\r\n// Use code interpreter instead of direct exec for untrusted code\r\nasync function executeUntrustedCode(code: string, sandbox: Sandbox) {\r\n  const ctx = await sandbox.createCodeContext({ language: 'python' });\r\n  return await sandbox.runCode(code, { context: ctx, timeout: 10000 });\r\n}\r\n```\r\n\r\n---",
    "Dependencies": "**Required**:\r\n- `@cloudflare/sandbox@0.4.12` - Sandbox SDK\r\n- `wrangler@latest` - Deployment CLI\r\n- Docker Desktop - Local development only\r\n\r\n**Optional**:\r\n- `@anthropic-ai/sdk` - For AI features\r\n- `@cloudflare/workers-types` - TypeScript types\r\n\r\n---",
    "Common Patterns": "### Pattern 1: One-Shot Code Execution\r\n\r\n```typescript\r\nexport default {\r\n  async fetch(request: Request, env: Env) {\r\n    const { code, language } = await request.json();\r\n\r\n    // Create ephemeral sandbox\r\n    const sandboxId = `exec-${Date.now()}-${crypto.randomUUID()}`;\r\n    const sandbox = getSandbox(env.Sandbox, sandboxId);\r\n\r\n    try {\r\n      // Create code context\r\n      const ctx = await sandbox.createCodeContext({ language });\r\n\r\n      // Execute code safely\r\n      const result = await sandbox.runCode(code, {\r\n        context: ctx,\r\n        timeout: 10000\r\n      });\r\n\r\n      return Response.json({\r\n        result: result.results?.[0]?.text,\r\n        logs: result.logs,\r\n        error: result.error\r\n      });\r\n    } finally {\r\n      // Always cleanup\r\n      await sandbox.destroy();\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**When to use**: API endpoints for code execution, code playgrounds, learning platforms\r\n\r\n### Pattern 2: Persistent User Workspace\r\n\r\n```typescript\r\nexport default {\r\n  async fetch(request: Request, env: Env) {\r\n    const userId = request.headers.get('X-User-ID');\r\n    const { command, sessionId: existingSession } = await request.json();\r\n\r\n    // User-specific sandbox (persists while active)\r\n    const sandbox = getSandbox(env.Sandbox, `user-${userId}`);\r\n\r\n    // Get or create session\r\n    let sessionId = existingSession;\r\n    if (!sessionId) {\r\n      sessionId = await sandbox.createSession();\r\n    }\r\n\r\n    // Execute command in persistent context\r\n    const result = await sandbox.exec(command, {\r\n      session: sessionId,\r\n      timeout: 30000\r\n    });\r\n\r\n    return Response.json({\r\n      sessionId, // Return for next request\r\n      output: result.stdout,\r\n      error: result.stderr,\r\n      success: result.success\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n**When to use**: Interactive coding environments, notebooks, IDEs, development workspaces\r\n\r\n### Pattern 3: CI/CD Build Pipeline\r\n\r\n```typescript\r\nasync function runBuild(repoUrl: string, commit: string, env: Env) {\r\n  const sandboxId = `build-${repoUrl.split('/').pop()}-${commit}`;\r\n  const sandbox = getSandbox(env.Sandbox, sandboxId);\r\n\r\n  try {\r\n    // Clone repository\r\n    await sandbox.gitCheckout(repoUrl, '/workspace/repo');\r\n\r\n    // Checkout specific commit\r\n    await sandbox.exec(`git checkout ${commit}`, {\r\n      cwd: '/workspace/repo'\r\n    });\r\n\r\n    // Install dependencies\r\n    const install = await sandbox.exec('npm install', {\r\n      cwd: '/workspace/repo',\r\n      timeout: 180000 // 3 minutes\r\n    });\r\n\r\n    if (!install.success) {\r\n      throw new Error(`Install failed: ${install.stderr}`);\r\n    }\r\n\r\n    // Run build\r\n    const build = await sandbox.exec('npm run build', {\r\n      cwd: '/workspace/repo',\r\n      timeout: 300000 // 5 minutes\r\n    });\r\n\r\n    if (!build.success) {\r\n      throw new Error(`Build failed: ${build.stderr}`);\r\n    }\r\n\r\n    // Save artifacts to R2\r\n    const dist = await sandbox.exec('tar -czf dist.tar.gz dist', {\r\n      cwd: '/workspace/repo'\r\n    });\r\n    const artifact = await sandbox.readFile('/workspace/repo/dist.tar.gz');\r\n    await env.R2.put(`builds/${commit}.tar.gz`, artifact);\r\n\r\n    return { success: true, artifactKey: `builds/${commit}.tar.gz` };\r\n  } finally {\r\n    // Optional: Keep sandbox for debugging or destroy\r\n    // await sandbox.destroy();\r\n  }\r\n}\r\n```\r\n\r\n**When to use**: Build systems, testing pipelines, deployment automation\r\n\r\n### Pattern 4: AI Agent with Claude Code\r\n\r\n```typescript\r\nasync function runClaudeCodeOnRepo(\r\n  repoUrl: string,\r\n  task: string,\r\n  env: Env\r\n): Promise<{ diff: string; logs: string }> {\r\n  const sandboxId = `claude-${Date.now()}`;\r\n  const sandbox = getSandbox(env.Sandbox, sandboxId);\r\n\r\n  try {\r\n    // Clone repository\r\n    await sandbox.gitCheckout(repoUrl, '/workspace/repo');\r\n\r\n    // Run Claude Code CLI with secure environment injection\r\n    // ⚠️ SECURITY: Use env option instead of shell export to prevent key exposure in logs\r\n    const result = await sandbox.exec(\r\n      `claude -p \"${task}\" --permission-mode acceptEdits`,\r\n      {\r\n        cwd: '/workspace/repo',\r\n        timeout: 300000, // 5 minutes\r\n        env: {\r\n          ANTHROPIC_API_KEY: env.ANTHROPIC_API_KEY\r\n        }\r\n      }\r\n    );\r\n\r\n    // Get diff of changes\r\n    const diff = await sandbox.exec('git diff', {\r\n      cwd: '/workspace/repo'\r\n    });\r\n\r\n    return {\r\n      diff: diff.stdout,\r\n      logs: result.stdout\r\n    };\r\n  } finally {\r\n    await sandbox.destroy();\r\n  }\r\n}\r\n```\r\n\r\n**When to use**: Automated code refactoring, code generation, AI-powered development\r\n\r\n---",
    "Production Example": "This skill is based on official Cloudflare tutorials:\r\n- **Claude Code Integration**: https://developers.cloudflare.com/sandbox/tutorials/claude-code/\r\n- **AI Code Executor**: https://developers.cloudflare.com/sandbox/tutorials/ai-code-executor/\r\n- **Build Time**: ~15 min (setup) + ~5 min (first deploy)\r\n- **Errors**: 0 (all 10 known issues prevented)\r\n- **Validation**: ✅ Tested with Python, Node.js, Git, background processes, sessions\r\n\r\n---",
    "Architecture (Understanding the 3-Layer Model)": "### How Sandboxes Work\r\n\r\n```\r\n┌─────────────────────────────────────────┐\r\n│  Your Worker (Layer 1)                  │\r\n│  - Handles HTTP requests                │\r\n│  - Calls getSandbox()                   │\r\n│  - Uses sandbox.exec(), writeFile(), etc│\r\n└──────────────┬──────────────────────────┘\r\n               │ RPC via Durable Object\r\n┌──────────────▼──────────────────────────┐\r\n│  Durable Object (Layer 2)               │\r\n│  - Routes by sandbox ID                 │\r\n│  - Maintains persistent identity        │\r\n│  - Geographic stickiness                │\r\n└──────────────┬──────────────────────────┘\r\n               │ Container API\r\n┌──────────────▼──────────────────────────┐\r\n│  Ubuntu Container (Layer 3)             │\r\n│  - Full Linux environment               │\r\n│  - Python 3.11, Node 20, Git, etc.      │\r\n│  - Filesystem: /workspace, /tmp, /home  │\r\n│  - Process isolation (VM-based)         │\r\n└─────────────────────────────────────────┘\r\n```\r\n\r\n**Key Insight**: Workers handle API logic (fast), Durable Objects route requests (persistent identity), Containers execute code (full capabilities).\r\n\r\n---",
    "Quick Start (15 Minutes)": "### 1. Install SDK and Setup Wrangler\r\n\r\n```bash\r\nnpm install @cloudflare/sandbox@latest\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"name\": \"my-sandbox-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n  \"containers\": [{\r\n    \"class_name\": \"Sandbox\",\r\n    \"image\": \"cloudflare/sandbox:0.4.12\",\r\n    \"instance_type\": \"lite\"\r\n  }],\r\n  \"durable_objects\": {\r\n    \"bindings\": [{\r\n      \"class_name\": \"Sandbox\",\r\n      \"name\": \"Sandbox\"\r\n    }]\r\n  },\r\n  \"migrations\": [{\r\n    \"tag\": \"v1\",\r\n    \"new_sqlite_classes\": [\"Sandbox\"]\r\n  }]\r\n}\r\n```\r\n\r\n**Why this matters:**\r\n- `nodejs_compat` enables Node.js APIs required by SDK\r\n- `containers` defines the Ubuntu container image\r\n- `durable_objects` binding enables persistent routing\r\n- `migrations` registers the Sandbox class\r\n\r\n### 2. Create Your First Sandbox Worker\r\n\r\n```typescript\r\nimport { getSandbox, type Sandbox } from '@cloudflare/sandbox';\r\nexport { Sandbox } from '@cloudflare/sandbox';\r\n\r\ntype Env = {\r\n  Sandbox: DurableObjectNamespace<Sandbox>;\r\n};\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    // Get sandbox instance (creates if doesn't exist)\r\n    const sandbox = getSandbox(env.Sandbox, 'my-first-sandbox');\r\n\r\n    // Execute Python code\r\n    const result = await sandbox.exec('python3 -c \"print(2 + 2)\"');\r\n\r\n    return Response.json({\r\n      output: result.stdout,\r\n      success: result.success,\r\n      exitCode: result.exitCode\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n**CRITICAL:**\r\n- **MUST export** `{ Sandbox }` from `@cloudflare/sandbox` in your Worker\r\n- Sandbox ID determines routing (same ID = same container)\r\n- First request creates container (~2-3 min cold start)\r\n- Subsequent requests are fast (<1s)\r\n\r\n### 3. Deploy and Test\r\n\r\n```bash\r\nnpm run deploy\r\ncurl https://your-worker.workers.dev\r\n```\r\n\r\nExpected output:\r\n```json\r\n{\r\n  \"output\": \"4\\n\",\r\n  \"success\": true,\r\n  \"exitCode\": 0\r\n}\r\n```\r\n\r\n---",
    "Configuration Files Reference": "EXPOSE 8080\r\n```\r\n\r\n---",
    "Using Bundled Resources": "npx tsx scripts/test-sandbox.ts\r\n```\r\n\r\n### References (references/)\r\n\r\n- `references/persistence-guide.md` - Deep dive on container lifecycle and persistence\r\n- `references/session-management.md` - Advanced session patterns and best practices\r\n- `references/common-errors.md` - Complete list of errors with solutions\r\n- `references/naming-strategies.md` - Choosing sandbox IDs for different use cases\r\n\r\n**When Claude should load these**:\r\n- Load `persistence-guide.md` when debugging state issues or cold starts\r\n- Load `session-management.md` when building multi-step workflows or chat agents\r\n- Load `common-errors.md` when encountering specific errors\r\n- Load `naming-strategies.md` when designing sandbox architecture\r\n\r\n---",
    "Session Management (Game-Changer for Chat Agents)": "### What Are Sessions?\r\n\r\nSessions are **bash shell contexts** within one sandbox. Think terminal tabs.\r\n\r\n**Key Properties**:\r\n- Each session has separate working directory\r\n- Sessions share same filesystem\r\n- Working directory persists across commands in same session\r\n- Perfect for multi-step workflows\r\n\r\n### Pattern: Chat-Based Coding Agent\r\n\r\n```typescript\r\ntype ConversationState = {\r\n  sandboxId: string;\r\n  sessionId: string;\r\n};\r\n\r\n// First message: Create sandbox and session\r\nconst sandboxId = `user-${userId}`;\r\nconst sandbox = getSandbox(env.Sandbox, sandboxId);\r\nconst sessionId = await sandbox.createSession();\r\n\r\n// Store in conversation state (database, KV, etc.)\r\nawait env.KV.put(`conversation:${conversationId}`, JSON.stringify({\r\n  sandboxId,\r\n  sessionId\r\n}));\r\n\r\n// Later messages: Reuse same session\r\nconst state = await env.KV.get(`conversation:${conversationId}`);\r\nconst { sandboxId, sessionId } = JSON.parse(state);\r\nconst sandbox = getSandbox(env.Sandbox, sandboxId);\r\n\r\n// Commands run in same context\r\nawait sandbox.exec('cd /workspace/project', { session: sessionId });\r\nawait sandbox.exec('ls -la', { session: sessionId }); // Still in /workspace/project\r\nawait sandbox.exec('git status', { session: sessionId }); // Still in /workspace/project\r\n```\r\n\r\n### Without Sessions (Common Mistake)\r\n\r\n```typescript\r\n// ❌ WRONG: Each command runs in separate session\r\nawait sandbox.exec('cd /workspace/project');\r\nawait sandbox.exec('ls'); // NOT in /workspace/project (different session)\r\n```\r\n\r\n### Pattern: Parallel Execution\r\n\r\n```typescript\r\nconst session1 = await sandbox.createSession();\r\nconst session2 = await sandbox.createSession();\r\n\r\n// Run different tasks simultaneously\r\nawait Promise.all([\r\n  sandbox.exec('python train_model.py', { session: session1 }),\r\n  sandbox.exec('node generate_reports.js', { session: session2 })\r\n]);\r\n```\r\n\r\n---"
  }
}