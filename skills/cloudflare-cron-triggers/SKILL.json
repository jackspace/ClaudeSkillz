{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/common-patterns.md",
      "references/cron-expressions-reference.md"
    ]
  },
  "content": "**Status**: Production Ready ‚úÖ\r\n**Last Updated**: 2025-10-23\r\n**Dependencies**: cloudflare-worker-base (for Worker setup)\r\n**Latest Versions**: wrangler@4.43.0, @cloudflare/workers-types@4.20251014.0\r\n\r\n---\r\n\r\n\r\n### 1. Add Scheduled Handler to Your Worker\r\n\r\n**src/index.ts:**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void> {\r\n    console.log('Cron job executed at:', new Date(controller.scheduledTime));\r\n    console.log('Triggered by cron:', controller.cron);\r\n\r\n    // Your scheduled task logic here\r\n    await doPeriodicTask(env);\r\n  },\r\n};\r\n```\r\n\r\n**Why this matters:**\r\n- Handler must be named exactly `scheduled` (not `scheduledHandler` or `onScheduled`)\r\n- Must be exported in default export object\r\n- Must use ES modules format (not Service Worker format)\r\n\r\n### 2. Configure Cron Trigger in Wrangler\r\n\r\n**wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-scheduled-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-23\",\r\n  \"triggers\": {\r\n    \"crons\": [\r\n      \"0 * * * *\"  // Every hour at minute 0\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**CRITICAL:**\r\n- Cron expressions use 5 fields: `minute hour day-of-month month day-of-week`\r\n- All times are **UTC only** (no timezone conversion)\r\n- Changes take **up to 15 minutes** to propagate globally\r\n\r\n### 3. Test Locally\r\n\r\n```bash\r\nnpx wrangler dev --test-scheduled\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\r\n\r\n```\r\n\r\n**Testing tips:**\r\n- `/__scheduled` endpoint is only available with `--test-scheduled` flag\r\n- Can pass any cron expression in query parameter\r\n- Python Workers use `/cdn-cgi/handler/scheduled` instead\r\n\r\n### 4. Deploy\r\n\r\n```bash\r\nnpm run deploy\r\n\r\n### Five-Field Format\r\n\r\n```\r\n* * * * *\r\n‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îÇ\r\n‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ Day of Week (0-6, Sunday=0)\r\n‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Month (1-12)\r\n‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Day of Month (1-31)\r\n‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Hour (0-23)\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Minute (0-59)\r\n```\r\n\r\n### Special Characters\r\n\r\n| Character | Meaning | Example |\r\n|-----------|---------|---------|\r\n| `*` | Every | `* * * * *` = every minute |\r\n| `,` | List | `0,30 * * * *` = every hour at :00 and :30 |\r\n| `-` | Range | `0 9-17 * * *` = every hour from 9am-5pm |\r\n| `/` | Step | `*/15 * * * *` = every 15 minutes |\r\n\r\n### Common Patterns\r\n\r\n```bash\r\n* * * * *\r\n\r\n*/5 * * * *\r\n\r\n*/15 * * * *\r\n\r\n0 * * * *\r\n\r\n30 * * * *\r\n\r\n0 */6 * * *\r\n\r\n0 0 * * *\r\n\r\n0 12 * * *\r\n\r\n30 3 * * *\r\n\r\n0 9 * * 1\r\n\r\n0 9 * * 1-5\r\n\r\n0 0 * * 0\r\n\r\n0 0 1 * *\r\n\r\n0 6,18 * * *\r\n\r\n\r\n### Basic Configuration\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-scheduled-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2025-10-23\",\r\n  \"triggers\": {\r\n    \"crons\": [\"0 * * * *\"]\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Multiple Cron Triggers\r\n\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\r\n      \"*/5 * * * *\",     // Every 5 minutes\r\n      \"0 */6 * * *\",     // Every 6 hours\r\n      \"0 2 * * *\",       // Daily at 2am UTC\r\n      \"0 0 * * 1\"        // Weekly on Monday at midnight UTC\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**Limits:**\r\n- Free: 3 cron schedules max\r\n- Paid: Higher limits (check current limits)\r\n\r\n---\r\n\r\n### Environment-Specific Crons\r\n\r\n```jsonc\r\n{\r\n  \"name\": \"my-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"env\": {\r\n    \"dev\": {\r\n      \"triggers\": {\r\n        \"crons\": [\"*/5 * * * *\"]  // Dev: every 5 minutes for testing\r\n      }\r\n    },\r\n    \"staging\": {\r\n      \"triggers\": {\r\n        \"crons\": [\"*/30 * * * *\"]  // Staging: every 30 minutes\r\n      }\r\n    },\r\n    \"production\": {\r\n      \"triggers\": {\r\n        \"crons\": [\"0 * * * *\"]  // Production: hourly\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n**Deploy specific environment:**\r\n\r\n```bash\r\nnpx wrangler deploy --env dev\r\n\r\n\r\n### Local Testing with Wrangler\r\n\r\n```bash\r\nnpx wrangler dev --test-scheduled\r\n```\r\n\r\nThis exposes `/__scheduled` endpoint for triggering scheduled handlers.\r\n\r\n---\r\n\r\n### Trigger Scheduled Handler\r\n\r\n```bash\r\ncurl \"http://localhost:8787/__scheduled\"\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=*/5+*+*+*+*\"\r\n```\r\n\r\n**Note:** Use `+` instead of spaces in URL, or URL-encode properly.\r\n\r\n---\r\n\r\n### Verify Handler Output\r\n\r\n```bash\r\nnpx wrangler dev --test-scheduled\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\r\n```\r\n\r\nOutput appears in `wrangler dev` terminal:\r\n\r\n```\r\n[wrangler:inf] GET /__scheduled?cron=0+*+*+*+* 200 OK (45ms)\r\nCron job executed at: 2025-10-23T15:00:00.000Z\r\nTriggered by cron: 0 * * * *\r\nScheduled task completed successfully\r\n```\r\n\r\n---\r\n\r\n### Test Multiple Cron Expressions\r\n\r\n```bash\r\ncurl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=0+0+*+*+*\"\r\n\r\ncurl \"http://localhost:8787/__scheduled?cron=0+0+*+*+1\"\r\n```\r\n\r\n---\r\n\r\n### Python Workers Testing\r\n\r\n```bash\r\n\r\nThis skill prevents **6** documented issues:\r\n\r\n### Issue #1: Cron Changes Not Propagating\r\n\r\n**Error:** Cron triggers updated in wrangler.jsonc but not executing\r\n\r\n**Source:** [Cloudflare Docs - Cron Triggers](https://developers.cloudflare.com/workers/configuration/cron-triggers/)\r\n\r\n**Why It Happens:**\r\n- Changes to cron triggers take up to **15 minutes** to propagate globally\r\n- Cloudflare network needs time to update edge nodes\r\n- No instant propagation like regular deploys\r\n\r\n**Prevention:**\r\n- Wait 15 minutes after deploy before expecting execution\r\n- Check dashboard: Workers & Pages > [Worker] > Cron Triggers\r\n- Use `wrangler triggers deploy` for trigger-only changes\r\n\r\n```bash\r\nnpx wrangler triggers deploy\r\n\r\n```\r\n\r\n---\r\n\r\n### Issue #2: Handler Does Not Export\r\n\r\n**Error:** `Handler does not export a 'scheduled' method`\r\n\r\n**Source:** Common deployment error\r\n\r\n**Why It Happens:**\r\n- Handler not named exactly `scheduled`\r\n- Handler not exported in default export object\r\n- Using Service Worker format instead of ES modules\r\n\r\n**Prevention:**\r\n\r\n```typescript\r\n// ‚ùå Wrong: Incorrect handler name\r\nexport default {\r\n  async scheduledHandler(controller, env, ctx) { }\r\n};\r\n\r\n// ‚ùå Wrong: Not in default export\r\nexport async function scheduled(controller, env, ctx) { }\r\n\r\n// ‚úÖ Correct: Named 'scheduled' in default export\r\nexport default {\r\n  async scheduled(controller, env, ctx) { }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Issue #3: UTC Timezone Confusion\r\n\r\n**Error:** Cron runs at wrong time\r\n\r\n**Source:** User expectation vs. reality\r\n\r\n**Why It Happens:**\r\n- All cron triggers run on **UTC time only**\r\n- No timezone conversion available\r\n- Users expect local timezone\r\n\r\n**Prevention:**\r\n\r\nConvert your local time to UTC manually:\r\n\r\n```typescript\r\n// Want to run at 9am PST (UTC-8)?\r\n// 9am PST = 5pm UTC (17:00)\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 17 * * *\"]  // 9am PST = 5pm UTC\r\n  }\r\n}\r\n\r\n// Want to run at 6pm EST (UTC-5)?\r\n// 6pm EST = 11pm UTC (23:00)\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 23 * * *\"]  // 6pm EST = 11pm UTC\r\n  }\r\n}\r\n\r\n// Remember: DST changes affect conversion!\r\n// PST is UTC-8, PDT is UTC-7\r\n```\r\n\r\n**Tools:**\r\n- [Time Zone Converter](https://www.timeanddate.com/worldclock/converter.html)\r\n- [Cron Expression Generator](https://crontab.guru/)\r\n\r\n---\r\n\r\n### Issue #4: Invalid Cron Expression\r\n\r\n**Error:** Cron doesn't execute, no error shown\r\n\r\n**Source:** Silent validation failure\r\n\r\n**Why It Happens:**\r\n- Invalid cron syntax silently fails\r\n- Validation happens at deploy, but may not be obvious\r\n- Common mistakes: wrong field order, invalid ranges\r\n\r\n**Prevention:**\r\n\r\n```bash\r\n\"crons\": [\"0 0 * * * *\"]  # Has seconds field - not supported\r\n\r\n\"crons\": [\"65 * * * *\"]  # Minute must be 0-59\r\n\r\n\"crons\": [\"0 0 * * 7\"]  # Day of week is 0-6 (use 0 for Sunday)\r\n\r\n\r\n### Issue: Cron not executing\r\n\r\n**Possible causes:**\r\n1. Changes not propagated yet (wait 15 minutes)\r\n2. Invalid cron expression\r\n3. Handler not exported correctly\r\n4. Worker not deployed\r\n\r\n**Solution:**\r\n\r\n```bash\r\nnpx wrangler deploy\r\n\r\n\r\n\r\n```\r\n\r\n---\r\n\r\n### Issue: Handler executes but fails\r\n\r\n**Possible causes:**\r\n1. Uncaught error in handler\r\n2. CPU time limit exceeded\r\n3. Missing environment bindings\r\n4. Network timeout\r\n\r\n**Solution:**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller, env, ctx) {\r\n    try {\r\n      await yourTask(env);\r\n    } catch (error) {\r\n      // Log detailed error\r\n      console.error('Handler failed:', {\r\n        error: error.message,\r\n        stack: error.stack,\r\n        cron: controller.cron,\r\n        time: new Date(controller.scheduledTime),\r\n      });\r\n\r\n      // Send alert\r\n      ctx.waitUntil(sendAlert(error));\r\n\r\n      // Re-throw to mark as failed\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n```\r\n\r\nCheck logs in dashboard for error details.\r\n\r\n---\r\n\r\n### Issue: Wrong execution time\r\n\r\n**Cause:** UTC vs. local timezone confusion\r\n\r\n**Solution:**\r\n\r\nConvert your desired local time to UTC:\r\n\r\n```typescript\r\n// Want 9am PST (UTC-8)?\r\n// 9am PST = 5pm UTC (17:00)\r\n\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 17 * * *\"]\r\n  }\r\n}\r\n```\r\n\r\n**Tools:**\r\n- [World Clock Converter](https://www.timeanddate.com/worldclock/converter.html)\r\n- Remember DST changes (PST vs PDT)\r\n\r\n---\r\n\r\n### Issue: Local testing not working\r\n\r\n**Possible causes:**\r\n1. Missing `--test-scheduled` flag\r\n2. Wrong endpoint (should be `/__scheduled`)\r\n3. Python Worker (use `/cdn-cgi/handler/scheduled`)\r\n\r\n**Solution:**\r\n\r\n```bash\r\nnpx wrangler dev --test-scheduled",
  "name": "cloudflare-cron-triggers",
  "id": "cloudflare-cron-triggers",
  "sections": {
    "Related Documentation": "- **Cloudflare Cron Triggers**: https://developers.cloudflare.com/workers/configuration/cron-triggers/\r\n- **Scheduled Handler API**: https://developers.cloudflare.com/workers/runtime-apis/handlers/scheduled/\r\n- **Cron Trigger Examples**: https://developers.cloudflare.com/workers/examples/cron-trigger/\r\n- **Multiple Cron Triggers**: https://developers.cloudflare.com/workers/examples/multiple-cron-triggers/\r\n- **Wrangler Triggers Command**: https://developers.cloudflare.com/workers/wrangler/commands/#triggers\r\n- **Workers Pricing**: https://developers.cloudflare.com/workers/platform/pricing/\r\n- **Workflows Integration**: https://developers.cloudflare.com/workflows/\r\n- **Crontab Guru** (validator): https://crontab.guru/\r\n- **Time Zone Converter**: https://www.timeanddate.com/worldclock/converter.html\r\n\r\n---\r\n\r\n**Last Updated**: 2025-10-23\r\n**Version**: 1.0.0\r\n**Maintainer**: Jeremy Dawes | jeremy@jezweb.net",
    "Quick Start (5 Minutes)": "npx wrangler deploy\r\n```\r\n\r\n**After deployment:**\r\n- Changes may take up to 15 minutes to propagate\r\n- Check dashboard: Workers & Pages > [Your Worker] > **Cron Triggers**\r\n- View past executions in **Logs** tab\r\n\r\n---",
    "ScheduledController Interface": "```typescript\r\ninterface ScheduledController {\r\n  readonly cron: string;           // The cron expression that triggered this execution\r\n  readonly type: string;           // Always \"scheduled\"\r\n  readonly scheduledTime: number;  // Unix timestamp (ms) when scheduled\r\n}\r\n```\r\n\r\n### Properties\r\n\r\n#### `controller.cron` (string)\r\n\r\nThe cron expression that triggered this execution.\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    console.log(`Triggered by: ${controller.cron}`);\r\n    // Output: \"Triggered by: 0 * * * *\"\r\n  },\r\n};\r\n```\r\n\r\n**Use case:** Differentiate between multiple cron schedules (see Multiple Cron Triggers pattern).\r\n\r\n#### `controller.type` (string)\r\n\r\nAlways returns `\"scheduled\"` for cron-triggered executions.\r\n\r\n```typescript\r\nif (controller.type === 'scheduled') {\r\n  // This is a cron-triggered execution\r\n}\r\n```\r\n\r\n#### `controller.scheduledTime` (number)\r\n\r\nUnix timestamp (milliseconds since epoch) when this execution was scheduled to run.\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController): Promise<void> {\r\n    const scheduledDate = new Date(controller.scheduledTime);\r\n    console.log(`Scheduled for: ${scheduledDate.toISOString()}`);\r\n    // Output: \"Scheduled for: 2025-10-23T15:00:00.000Z\"\r\n  },\r\n};\r\n```\r\n\r\n**Note:** This is the **scheduled** time, not the actual execution time. Due to system load, actual execution may be slightly delayed (usually <1 second).\r\n\r\n---",
    "Known Issues Prevention": "\"crons\": [\"0 0 * * 0\"]  # Sunday at midnight UTC\r\n```\r\n\r\n**Validation:**\r\n- Use [Crontab Guru](https://crontab.guru/) to validate expressions\r\n- Check wrangler deploy output for errors\r\n- Test locally with `--test-scheduled`\r\n\r\n---\r\n\r\n### Issue #5: Missing ES Modules Format\r\n\r\n**Error:** `Worker must use ES modules format`\r\n\r\n**Source:** Legacy Service Worker format\r\n\r\n**Why It Happens:**\r\n- Scheduled handler requires ES modules format\r\n- Old Service Worker format not supported\r\n- Mixed format in codebase\r\n\r\n**Prevention:**\r\n\r\n```typescript\r\n// ‚ùå Wrong: Service Worker format\r\naddEventListener('scheduled', (event) => {\r\n  event.waitUntil(handleScheduled(event));\r\n});\r\n\r\n// ‚úÖ Correct: ES modules format\r\nexport default {\r\n  async scheduled(controller, env, ctx) {\r\n    await handleScheduled(controller, env, ctx);\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n### Issue #6: CPU Time Limits Exceeded\r\n\r\n**Error:** `CPU time limit exceeded`\r\n\r\n**Source:** Long-running scheduled tasks\r\n\r\n**Why It Happens:**\r\n- Default CPU limit: 30 seconds\r\n- Long-running tasks exceed limit\r\n- No automatic timeout extension\r\n\r\n**Prevention:**\r\n\r\n**Option 1: Increase CPU limit in wrangler.jsonc**\r\n\r\n```jsonc\r\n{\r\n  \"limits\": {\r\n    \"cpu_ms\": 300000  // 5 minutes (max for Standard plan)\r\n  }\r\n}\r\n```\r\n\r\n**Option 2: Use Workflows for long-running tasks**\r\n\r\n```typescript\r\n// Instead of long task in cron:\r\nexport default {\r\n  async scheduled(controller, env, ctx) {\r\n    // Trigger Workflow that can run for hours\r\n    await env.MY_WORKFLOW.create({\r\n      params: { task: 'long-running-job' },\r\n    });\r\n  },\r\n};\r\n```\r\n\r\n**Option 3: Break into smaller chunks**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller, env, ctx) {\r\n    // Process in batches\r\n    const batch = await getNextBatch(env.DB);\r\n\r\n    for (const item of batch) {\r\n      await processItem(item);\r\n    }\r\n\r\n    // If more work, send to Queue for next batch\r\n    const hasMore = await hasMoreWork(env.DB);\r\n    if (hasMore) {\r\n      await env.MY_QUEUE.send({ type: 'continue-processing' });\r\n    }\r\n  },\r\n};\r\n```\r\n\r\n---",
    "Cron Expression Syntax": "*/30 9-17 * * 1-5\r\n```\r\n\r\n**CRITICAL: UTC Timezone Only**\r\n- All cron triggers execute on **UTC time**\r\n- No timezone conversion available\r\n- Convert your local time to UTC manually\r\n- Example: 9am PST = 5pm UTC (next day during DST)\r\n\r\n---",
    "Never Do ‚ùå": "1. **Never assume local timezone** - All crons run on UTC\r\n2. **Never use 6-field cron expressions** - Cloudflare uses 5-field format (no seconds)\r\n3. **Never rely on instant propagation** - Changes take up to 15 minutes\r\n4. **Never use Service Worker format** - Must use ES modules format\r\n5. **Never forget error handling** - Uncaught errors fail silently\r\n6. **Never run CPU-intensive tasks without limit increase** - Default 30s limit\r\n7. **Never use day-of-week 7** - Use 0 for Sunday (0-6 range only)\r\n8. **Never deploy without testing** - Always test with `--test-scheduled` first\r\n9. **Never ignore execution logs** - Dashboard shows past failures\r\n10. **Never hardcode schedules for testing** - Use environment-specific configs\r\n\r\n---",
    "Limits & Pricing": "### Limits\r\n\r\n| Feature | Free Plan | Paid Plan |\r\n|---------|-----------|-----------|\r\n| **Cron triggers per Worker** | 3 | Higher (check docs) |\r\n| **CPU time per execution** | 10 ms (avg) | 30 seconds (default), 5 min (max) |\r\n| **Wall clock time** | 30 seconds | 15 minutes |\r\n| **Memory** | 128 MB | 128 MB |\r\n\r\n### Pricing\r\n\r\nCron triggers use **Standard Workers pricing**:\r\n\r\n- **Workers Paid Plan**: $5/month required\r\n- **Requests**: $0.30 per million requests (after 10M free)\r\n- **CPU Time**: $0.02 per million CPU-ms (after 30M free)\r\n\r\n**Cron execution = 1 request**\r\n\r\n**Example:**\r\n- Cron runs every hour (24 times/day)\r\n- 30 days √ó 24 executions = 720 executions/month\r\n- Average 50ms CPU time per execution\r\n\r\n**Cost:**\r\n- Requests: 720 (well under 10M free)\r\n- CPU time: 720 √ó 50ms = 36,000ms (under 30M free)\r\n- **Total: $5/month (just subscription)**\r\n\r\n**High frequency example:**\r\n- Cron runs every minute (1440 times/day)\r\n- 30 days √ó 1440 = 43,200 executions/month\r\n- Still under free tier limits\r\n- **Total: $5/month**\r\n\r\n---",
    "TypeScript Types": "```typescript\r\n// Scheduled event controller\r\ninterface ScheduledController {\r\n  readonly cron: string;\r\n  readonly type: string;\r\n  readonly scheduledTime: number;\r\n}\r\n\r\n// Execution context\r\ninterface ExecutionContext {\r\n  waitUntil(promise: Promise<any>): void;\r\n  passThroughOnException(): void;\r\n}\r\n\r\n// Scheduled handler\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void>;\r\n}\r\n```\r\n\r\n---",
    "Common Use Cases": "### 1. Database Cleanup\r\n\r\n**Every day at 2am UTC: Delete old records**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    // Delete sessions older than 30 days\r\n    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);\r\n\r\n    await env.DB.prepare('DELETE FROM sessions WHERE created_at < ?')\r\n      .bind(thirtyDaysAgo)\r\n      .run();\r\n\r\n    // Delete soft-deleted users older than 90 days\r\n    const ninetyDaysAgo = Date.now() - (90 * 24 * 60 * 60 * 1000);\r\n\r\n    await env.DB.prepare('DELETE FROM users WHERE deleted_at < ?')\r\n      .bind(ninetyDaysAgo)\r\n      .run();\r\n\r\n    console.log('Database cleanup completed');\r\n  },\r\n};\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 2 * * *\"]  // Daily at 2am UTC\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 2. API Data Collection\r\n\r\n**Every 15 minutes: Fetch data from external API**\r\n\r\n```typescript\r\ninterface Env {\r\n  DB: D1Database;\r\n  API_KEY: string;\r\n}\r\n\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    try {\r\n      // Fetch from external API\r\n      const response = await fetch('https://api.example.com/v1/data', {\r\n        headers: {\r\n          Authorization: `Bearer ${env.API_KEY}`,\r\n        },\r\n      });\r\n\r\n      const data = await response.json();\r\n\r\n      // Store in D1\r\n      for (const item of data.items) {\r\n        await env.DB.prepare(\r\n          'INSERT INTO collected_data (id, value, timestamp) VALUES (?, ?, ?)'\r\n        )\r\n          .bind(item.id, item.value, Date.now())\r\n          .run();\r\n      }\r\n\r\n      console.log(`Collected ${data.items.length} items`);\r\n    } catch (error) {\r\n      console.error('Failed to collect data:', error);\r\n      throw error;  // Mark execution as failed\r\n    }\r\n  },\r\n};\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"*/15 * * * *\"]  // Every 15 minutes\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 3. Daily Reports Generation\r\n\r\n**Every day at 8am UTC: Generate and email report**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {\r\n    // Generate report from database\r\n    const report = await generateDailyReport(env.DB);\r\n\r\n    // Store in R2\r\n    const fileName = `reports/${new Date().toISOString().split('T')[0]}.json`;\r\n    await env.MY_BUCKET.put(fileName, JSON.stringify(report));\r\n\r\n    // Send via email\r\n    ctx.waitUntil(sendReportEmail(report, env.RESEND_API_KEY));\r\n\r\n    console.log('Daily report generated and sent');\r\n  },\r\n};\r\n\r\nasync function generateDailyReport(db: D1Database) {\r\n  const yesterday = new Date();\r\n  yesterday.setDate(yesterday.getDate() - 1);\r\n  const startOfDay = yesterday.setHours(0, 0, 0, 0);\r\n  const endOfDay = yesterday.setHours(23, 59, 59, 999);\r\n\r\n  const stats = await db\r\n    .prepare(`\r\n      SELECT\r\n        COUNT(*) as total_users,\r\n        COUNT(DISTINCT user_id) as active_users,\r\n        SUM(revenue) as total_revenue\r\n      FROM events\r\n      WHERE timestamp BETWEEN ? AND ?\r\n    `)\r\n    .bind(startOfDay, endOfDay)\r\n    .first();\r\n\r\n  return {\r\n    date: yesterday.toISOString().split('T')[0],\r\n    stats,\r\n  };\r\n}\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 8 * * *\"]  // Daily at 8am UTC\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 4. Cache Warming\r\n\r\n**Every hour: Pre-warm cache with popular content**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    // Get most popular pages from analytics\r\n    const popularPages = await env.DB\r\n      .prepare('SELECT url FROM pages ORDER BY views DESC LIMIT 100')\r\n      .all();\r\n\r\n    // Fetch each page to warm cache\r\n    const requests = popularPages.results.map((page) =>\r\n      fetch(`https://example.com${page.url}`, {\r\n        cf: {\r\n          cacheTtl: 3600,  // Cache for 1 hour\r\n        },\r\n      })\r\n    );\r\n\r\n    await Promise.all(requests);\r\n\r\n    console.log(`Warmed cache for ${popularPages.results.length} pages`);\r\n  },\r\n};\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 * * * *\"]  // Every hour\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### 5. Monitoring & Health Checks\r\n\r\n**Every 5 minutes: Check system health**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    const checks = await Promise.allSettled([\r\n      checkDatabaseHealth(env.DB),\r\n      checkAPIHealth(),\r\n      checkStorageHealth(env.MY_BUCKET),\r\n    ]);\r\n\r\n    const failures = checks.filter((check) => check.status === 'rejected');\r\n\r\n    if (failures.length > 0) {\r\n      // Send alert\r\n      await sendAlert({\r\n        service: 'health-check',\r\n        failures: failures.map((f) => f.reason),\r\n        timestamp: new Date().toISOString(),\r\n      });\r\n    }\r\n  },\r\n};\r\n\r\nasync function checkDatabaseHealth(db: D1Database): Promise<void> {\r\n  const result = await db.prepare('SELECT 1 as health').first();\r\n  if (!result || result.health !== 1) {\r\n    throw new Error('Database health check failed');\r\n  }\r\n}\r\n\r\nasync function checkAPIHealth(): Promise<void> {\r\n  const response = await fetch('https://api.example.com/health');\r\n  if (!response.ok) {\r\n    throw new Error(`API health check failed: ${response.status}`);\r\n  }\r\n}\r\n\r\nasync function checkStorageHealth(bucket: R2Bucket): Promise<void> {\r\n  const testObject = await bucket.get('health-check.txt');\r\n  if (!testObject) {\r\n    throw new Error('Storage health check failed');\r\n  }\r\n}\r\n```\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"*/5 * * * *\"]  // Every 5 minutes\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Integration Patterns": "### 1. Standalone Scheduled Worker\r\n\r\n**Best for:** Workers that only run on schedule (no HTTP requests)\r\n\r\n```typescript\r\n// src/index.ts\r\ninterface Env {\r\n  DB: D1Database;\r\n  MY_BUCKET: R2Bucket;\r\n}\r\n\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void> {\r\n    console.log('Running scheduled maintenance...');\r\n\r\n    // Database cleanup\r\n    await env.DB.prepare('DELETE FROM sessions WHERE expires_at < ?')\r\n      .bind(Date.now())\r\n      .run();\r\n\r\n    // Generate daily report\r\n    const report = await generateDailyReport(env.DB);\r\n\r\n    // Upload to R2\r\n    await env.MY_BUCKET.put(\r\n      `reports/${new Date().toISOString().split('T')[0]}.json`,\r\n      JSON.stringify(report)\r\n    );\r\n\r\n    console.log('Maintenance complete');\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n### 2. Combined with Hono (Fetch + Scheduled)\r\n\r\n**Best for:** Workers that handle both HTTP requests and scheduled tasks\r\n\r\n```typescript\r\n// src/index.ts\r\nimport { Hono } from 'hono';\r\n\r\ninterface Env {\r\n  DB: D1Database;\r\n}\r\n\r\nconst app = new Hono<{ Bindings: Env }>();\r\n\r\n// Regular HTTP routes\r\napp.get('/', (c) => c.text('Worker is running'));\r\n\r\napp.get('/api/stats', async (c) => {\r\n  const stats = await c.env.DB.prepare('SELECT COUNT(*) as count FROM users').first();\r\n  return c.json(stats);\r\n});\r\n\r\n// Export both fetch handler and scheduled handler\r\nexport default {\r\n  // Handle HTTP requests\r\n  fetch: app.fetch,\r\n\r\n  // Handle cron triggers\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void> {\r\n    console.log('Cron triggered:', controller.cron);\r\n\r\n    // Run scheduled task\r\n    await updateCache(env.DB);\r\n\r\n    // Log completion\r\n    ctx.waitUntil(logExecution(controller.scheduledTime));\r\n  },\r\n};\r\n```\r\n\r\n**Why this pattern:**\r\n- One Worker handles both use cases\r\n- Share environment bindings\r\n- Reduce number of Workers to manage\r\n- Lower costs (one Worker subscription)\r\n\r\n---\r\n\r\n### 3. Multiple Cron Triggers\r\n\r\n**Best for:** Different schedules for different tasks\r\n\r\n**wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\r\n      \"*/5 * * * *\",    // Every 5 minutes\r\n      \"0 */6 * * *\",    // Every 6 hours\r\n      \"0 0 * * *\"       // Daily at midnight UTC\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n**src/index.ts:**\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void> {\r\n    // Route based on which cron triggered this execution\r\n    switch (controller.cron) {\r\n      case '*/5 * * * *':\r\n        // Every 5 minutes: Check system health\r\n        await checkSystemHealth(env);\r\n        break;\r\n\r\n      case '0 */6 * * *':\r\n        // Every 6 hours: Sync data from external API\r\n        await syncExternalData(env);\r\n        break;\r\n\r\n      case '0 0 * * *':\r\n        // Daily at midnight: Generate reports and cleanup\r\n        await generateDailyReports(env);\r\n        await cleanupOldData(env);\r\n        break;\r\n\r\n      default:\r\n        console.warn(`Unknown cron trigger: ${controller.cron}`);\r\n    }\r\n  },\r\n};\r\n```\r\n\r\n**CRITICAL:**\r\n- Use exact cron expression match (whitespace sensitive)\r\n- Maximum 3 cron triggers per Worker (Free plan)\r\n- Standard/Paid plan supports more (check limits)\r\n\r\n---\r\n\r\n### 4. Accessing Environment Bindings\r\n\r\n**All Worker bindings available in scheduled handler:**\r\n\r\n```typescript\r\ninterface Env {\r\n  // Databases\r\n  DB: D1Database;\r\n\r\n  // Storage\r\n  MY_BUCKET: R2Bucket;\r\n  KV_NAMESPACE: KVNamespace;\r\n\r\n  // AI & Vectors\r\n  AI: Ai;\r\n  VECTOR_INDEX: VectorizeIndex;\r\n\r\n  // Queues & Workflows\r\n  MY_QUEUE: Queue;\r\n  MY_WORKFLOW: Workflow;\r\n\r\n  // Durable Objects\r\n  RATE_LIMITER: DurableObjectNamespace;\r\n\r\n  // Secrets\r\n  API_KEY: string;\r\n}\r\n\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    // D1 Database\r\n    const users = await env.DB.prepare('SELECT * FROM users WHERE active = 1').all();\r\n\r\n    // R2 Storage\r\n    const file = await env.MY_BUCKET.get('data.json');\r\n\r\n    // KV Storage\r\n    const config = await env.KV_NAMESPACE.get('config', 'json');\r\n\r\n    // Workers AI\r\n    const response = await env.AI.run('@cf/meta/llama-3-8b-instruct', {\r\n      prompt: 'Summarize today\\'s data',\r\n    });\r\n\r\n    // Send to Queue\r\n    await env.MY_QUEUE.send({ type: 'process', data: users.results });\r\n\r\n    // Trigger Workflow\r\n    await env.MY_WORKFLOW.create({ input: { timestamp: Date.now() } });\r\n\r\n    // Use secrets\r\n    await fetch('https://api.example.com/webhook', {\r\n      headers: { Authorization: `Bearer ${env.API_KEY}` },\r\n    });\r\n  },\r\n};\r\n```\r\n\r\n---\r\n\r\n### 5. Combining with Workflows\r\n\r\n**Best for:** Multi-step, long-running tasks triggered on schedule\r\n\r\n**wrangler.jsonc:**\r\n\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": [\"0 2 * * *\"]  // Daily at 2am UTC\r\n  },\r\n  \"workflows\": [\r\n    {\r\n      \"name\": \"daily-report-workflow\",\r\n      \"binding\": \"DAILY_REPORT\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n**src/index.ts:**\r\n\r\n```typescript\r\ninterface Env {\r\n  DAILY_REPORT: Workflow;\r\n}\r\n\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env): Promise<void> {\r\n    console.log('Triggering daily report workflow...');\r\n\r\n    // Trigger workflow with initial state\r\n    const instance = await env.DAILY_REPORT.create({\r\n      params: {\r\n        date: new Date().toISOString().split('T')[0],\r\n        reportType: 'daily-summary',\r\n      },\r\n    });\r\n\r\n    console.log(`Workflow started: ${instance.id}`);\r\n  },\r\n};\r\n```\r\n\r\n**Why use Workflows:**\r\n- Workflows can run for hours (cron handlers have CPU limits)\r\n- Built-in retry and error handling\r\n- State persistence across steps\r\n- Better for complex, multi-step processes\r\n\r\n**Reference:** [Cloudflare Workflows Docs](https://developers.cloudflare.com/workflows/)\r\n\r\n---\r\n\r\n### 6. Error Handling in Scheduled Handlers\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext\r\n  ): Promise<void> {\r\n    try {\r\n      // Main task\r\n      await performScheduledTask(env);\r\n    } catch (error) {\r\n      // Log error\r\n      console.error('Scheduled task failed:', error);\r\n\r\n      // Send alert\r\n      await sendAlert({\r\n        worker: 'my-scheduled-worker',\r\n        cron: controller.cron,\r\n        error: error.message,\r\n        timestamp: new Date(controller.scheduledTime).toISOString(),\r\n      });\r\n\r\n      // Store failure in database\r\n      ctx.waitUntil(\r\n        env.DB.prepare(\r\n          'INSERT INTO cron_failures (cron, error, timestamp) VALUES (?, ?, ?)'\r\n        )\r\n          .bind(controller.cron, error.message, Date.now())\r\n          .run()\r\n      );\r\n\r\n      // Re-throw to mark execution as failed\r\n      throw error;\r\n    }\r\n  },\r\n};\r\n\r\nasync function sendAlert(details: any): Promise<void> {\r\n  await fetch('https://hooks.slack.com/services/YOUR/WEBHOOK/URL', {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    body: JSON.stringify({\r\n      text: `üö® Cron job failed: ${details.worker}`,\r\n      blocks: [\r\n        {\r\n          type: 'section',\r\n          fields: [\r\n            { type: 'mrkdwn', text: `*Worker:*\\n${details.worker}` },\r\n            { type: 'mrkdwn', text: `*Cron:*\\n${details.cron}` },\r\n            { type: 'mrkdwn', text: `*Error:*\\n${details.error}` },\r\n            { type: 'mrkdwn', text: `*Time:*\\n${details.timestamp}` },\r\n          ],\r\n        },\r\n      ],\r\n    }),\r\n  });\r\n}\r\n```\r\n\r\n---",
    "Always Do ‚úÖ": "1. **Use exact handler name** - Must be `scheduled`, not `scheduledHandler` or variants\r\n2. **Use ES modules format** - Export in default object, not addEventListener\r\n3. **Convert to UTC** - All cron times are UTC, convert from local timezone\r\n4. **Wait 15 minutes** - Cron changes take up to 15 min to propagate\r\n5. **Test locally first** - Use `wrangler dev --test-scheduled`\r\n6. **Validate cron syntax** - Use [Crontab Guru](https://crontab.guru/)\r\n7. **Handle errors gracefully** - Log, alert, and optionally re-throw\r\n8. **Use ctx.waitUntil()** - For non-critical async operations\r\n9. **Consider Workflows** - For tasks that need >30 seconds CPU time\r\n10. **Monitor executions** - Check dashboard logs regularly\r\n\r\n---",
    "Green Compute": "Run cron triggers only in data centers powered by renewable energy.\r\n\r\n### Enable Green Compute\r\n\r\n**Via Dashboard:**\r\n\r\n1. Go to [Workers & Pages](https://dash.cloudflare.com/?to=/:account/workers-and-pages)\r\n2. In **Account details** section, find **Compute Setting**\r\n3. Click **Change**\r\n4. Select **Green Compute**\r\n5. Click **Confirm**\r\n\r\n**Applies to:**\r\n- All cron triggers in your account\r\n- Reduces carbon footprint\r\n- No additional cost\r\n- May introduce slight delays in some regions\r\n\r\n**How it works:**\r\n- Cloudflare routes cron executions to green-powered data centers\r\n- Uses renewable energy: wind, solar, hydroelectric\r\n- Verified through Power Purchase Agreements (PPAs) and Renewable Energy Credits (RECs)\r\n\r\n---",
    "Troubleshooting": "curl \"http://localhost:8787/__scheduled?cron=0+*+*+*+*\"\r\n```\r\n\r\n---",
    "Production Checklist": "Before deploying cron triggers to production:\r\n\r\n- [ ] Cron expression validated on [Crontab Guru](https://crontab.guru/)\r\n- [ ] Handler named exactly `scheduled` in default export\r\n- [ ] ES modules format used (not Service Worker)\r\n- [ ] Local timezone converted to UTC\r\n- [ ] Error handling implemented with logging\r\n- [ ] Alerts configured for failures\r\n- [ ] CPU limits increased if needed (`limits.cpu_ms`)\r\n- [ ] Environment bindings tested\r\n- [ ] Tested locally with `--test-scheduled`\r\n- [ ] Deployment tested in staging environment\r\n- [ ] Waited 15 minutes after deploy for propagation\r\n- [ ] Verified execution in dashboard logs\r\n- [ ] Monitoring and alerting configured\r\n- [ ] Documentation updated with schedule details\r\n\r\n---",
    "Execution Context": "```typescript\r\nexport default {\r\n  async scheduled(\r\n    controller: ScheduledController,\r\n    env: Env,\r\n    ctx: ExecutionContext  // ‚Üê Execution context\r\n  ): Promise<void> {\r\n    // Use ctx.waitUntil() for async operations that should complete\r\n    ctx.waitUntil(logToAnalytics(env));\r\n  },\r\n};\r\n```\r\n\r\n### `ctx.waitUntil(promise: Promise<any>)`\r\n\r\nExtends the execution context to wait for async operations to complete after the handler returns.\r\n\r\n**Use cases:**\r\n- Logging to external services\r\n- Analytics tracking\r\n- Cleanup operations\r\n- Non-critical background tasks\r\n\r\n```typescript\r\nexport default {\r\n  async scheduled(controller: ScheduledController, env: Env, ctx: ExecutionContext): Promise<void> {\r\n    // Critical task - must complete before handler exits\r\n    await processData(env);\r\n\r\n    // Non-critical tasks - can complete in background\r\n    ctx.waitUntil(sendMetrics(env));\r\n    ctx.waitUntil(cleanupOldData(env));\r\n    ctx.waitUntil(notifySlack({ message: 'Cron completed' }));\r\n  },\r\n};\r\n```\r\n\r\n**Important:** First `waitUntil()` that fails will be reported as the status in dashboard logs.\r\n\r\n---",
    "Testing & Development": "curl \"http://localhost:8787/cdn-cgi/handler/scheduled?cron=*+*+*+*+*\"\r\n```\r\n\r\n---",
    "Wrangler Configuration": "npx wrangler deploy --env production\r\n```\r\n\r\n---\r\n\r\n### Removing All Cron Triggers\r\n\r\n```jsonc\r\n{\r\n  \"triggers\": {\r\n    \"crons\": []  // Empty array removes all crons\r\n  }\r\n}\r\n```\r\n\r\nAfter deploy, Worker will no longer execute on schedule.\r\n\r\n---"
  }
}