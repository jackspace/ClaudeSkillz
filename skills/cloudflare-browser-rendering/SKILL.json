{
  "description": "|",
  "metadata": {
    "license": "MIT"
  },
  "references": {
    "files": [
      "references/common-errors.md",
      "references/pricing-and-limits.md",
      "references/puppeteer-vs-playwright.md",
      "references/session-management.md"
    ]
  },
  "content": "Production-ready knowledge domain for building browser automation workflows with Cloudflare Browser Rendering.\r\n\r\n**Status**: Production Ready ‚úÖ\r\n**Last Updated**: 2025-10-22\r\n**Dependencies**: cloudflare-worker-base (for Worker setup)\r\n**Latest Versions**: @cloudflare/puppeteer@1.0.4, @cloudflare/playwright@1.0.0, wrangler@4.43.0\r\n\r\n---\r\n\r\n\r\n### Templates (templates/)\r\n\r\nReady-to-use code templates for common patterns:\r\n\r\n- `basic-screenshot.ts` - Minimal screenshot example\r\n- `screenshot-with-kv-cache.ts` - Screenshot with KV caching\r\n- `pdf-generation.ts` - Generate PDFs from HTML or URLs\r\n- `web-scraper-basic.ts` - Basic web scraping pattern\r\n- `web-scraper-batch.ts` - Batch scrape multiple URLs\r\n- `session-reuse.ts` - Session reuse for performance\r\n- `ai-enhanced-scraper.ts` - Scraping with Workers AI\r\n- `playwright-example.ts` - Playwright alternative example\r\n- `wrangler-browser-config.jsonc` - Browser binding configuration\r\n\r\n**Usage:**\r\n```bash",
  "name": "cloudflare-browser-rendering",
  "id": "cloudflare-browser-rendering",
  "sections": {
    "Table of Contents": "1. [Quick Start (5 minutes)](#quick-start-5-minutes)\r\n2. [Browser Rendering Overview](#browser-rendering-overview)\r\n3. [Puppeteer API Reference](#puppeteer-api-reference)\r\n4. [Playwright API Reference](#playwright-api-reference)\r\n5. [Session Management](#session-management)\r\n6. [Common Patterns](#common-patterns)\r\n7. [Pricing & Limits](#pricing--limits)\r\n8. [Known Issues Prevention](#known-issues-prevention)\r\n9. [Production Checklist](#production-checklist)\r\n\r\n---",
    "Quick Start (5 minutes)": "### 1. Add Browser Binding\r\n\r\n**wrangler.jsonc:**\r\n```jsonc\r\n{\r\n  \"name\": \"browser-worker\",\r\n  \"main\": \"src/index.ts\",\r\n  \"compatibility_date\": \"2023-03-14\",\r\n  \"compatibility_flags\": [\"nodejs_compat\"],\r\n  \"browser\": {\r\n    \"binding\": \"MYBROWSER\"\r\n  }\r\n}\r\n```\r\n\r\n**Why nodejs_compat?** Browser Rendering requires Node.js APIs and polyfills.\r\n\r\n### 2. Install Puppeteer\r\n\r\n```bash\r\nnpm install @cloudflare/puppeteer\r\n```\r\n\r\n### 3. Take Your First Screenshot\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { searchParams } = new URL(request.url);\r\n    const url = searchParams.get(\"url\") || \"https://example.com\";\r\n\r\n    // Launch browser\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    // Navigate and capture\r\n    await page.goto(url);\r\n    const screenshot = await page.screenshot();\r\n\r\n    // Clean up\r\n    await browser.close();\r\n\r\n    return new Response(screenshot, {\r\n      headers: { \"content-type\": \"image/png\" }\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### 4. Deploy\r\n\r\n```bash\r\nnpx wrangler deploy\r\n```\r\n\r\nTest at: `https://your-worker.workers.dev/?url=https://example.com`\r\n\r\n**CRITICAL:**\r\n- Always pass `env.MYBROWSER` to `puppeteer.launch()` (not undefined)\r\n- Always call `browser.close()` when done (or use `browser.disconnect()` for session reuse)\r\n- Use `nodejs_compat` compatibility flag\r\n\r\n---",
    "Known Issues Prevention": "This skill prevents **6 documented issues**:\r\n\r\n---\r\n\r\n### Issue #1: XPath Selectors Not Supported\r\n\r\n**Error:** \"XPath selector not supported\" or selector failures\r\n**Source:** https://developers.cloudflare.com/browser-rendering/faq/#why-cant-i-use-an-xpath-selector-when-using-browser-rendering-with-puppeteer\r\n**Why It Happens:** XPath poses a security risk to Workers\r\n**Prevention:** Use CSS selectors or `page.evaluate()` with XPathEvaluator\r\n\r\n**Solution:**\r\n```typescript\r\n// ‚ùå Don't use XPath directly (not supported)\r\n// await page.$x('/html/body/div/h1')\r\n\r\n// ‚úÖ Use CSS selector\r\nconst heading = await page.$(\"div > h1\");\r\n\r\n// ‚úÖ Or use XPath in page.evaluate()\r\nconst innerHtml = await page.evaluate(() => {\r\n  return new XPathEvaluator()\r\n    .createExpression(\"/html/body/div/h1\")\r\n    .evaluate(document, XPathResult.FIRST_ORDERED_NODE_TYPE)\r\n    .singleNodeValue.innerHTML;\r\n});\r\n```\r\n\r\n---\r\n\r\n### Issue #2: Browser Binding Not Passed\r\n\r\n**Error:** \"Cannot read properties of undefined (reading 'fetch')\"\r\n**Source:** https://developers.cloudflare.com/browser-rendering/faq/#cannot-read-properties-of-undefined-reading-fetch\r\n**Why It Happens:** `puppeteer.launch()` called without browser binding\r\n**Prevention:** Always pass `env.MYBROWSER` to launch\r\n\r\n**Solution:**\r\n```typescript\r\n// ‚ùå Missing browser binding\r\nconst browser = await puppeteer.launch(); // Error!\r\n\r\n// ‚úÖ Pass binding\r\nconst browser = await puppeteer.launch(env.MYBROWSER);\r\n```\r\n\r\n---\r\n\r\n### Issue #3: Browser Timeout (60 seconds)\r\n\r\n**Error:** Browser closes unexpectedly after 60 seconds\r\n**Source:** https://developers.cloudflare.com/browser-rendering/platform/limits/#note-on-browser-timeout\r\n**Why It Happens:** Default timeout is 60 seconds of inactivity\r\n**Prevention:** Use `keep_alive` option to extend up to 10 minutes\r\n\r\n**Solution:**\r\n```typescript\r\n// Extend timeout to 5 minutes for long-running tasks\r\nconst browser = await puppeteer.launch(env.MYBROWSER, {\r\n  keep_alive: 300000 // 5 minutes = 300,000 ms\r\n});\r\n```\r\n\r\n**Note:** Browser closes if no devtools commands for the specified duration.\r\n\r\n---\r\n\r\n### Issue #4: Concurrency Limits Reached\r\n\r\n**Error:** \"Rate limit exceeded\" or new browser launch fails\r\n**Source:** https://developers.cloudflare.com/browser-rendering/platform/limits/\r\n**Why It Happens:** Exceeded concurrent browser limit (3 free, 10-30 paid)\r\n**Prevention:** Reuse sessions, use tabs instead of multiple browsers, check limits before launching\r\n\r\n**Solutions:**\r\n```typescript\r\n// 1. Check limits before launching\r\nconst limits = await puppeteer.limits(env.MYBROWSER);\r\nif (limits.allowedBrowserAcquisitions === 0) {\r\n  return new Response(\"Concurrency limit reached\", { status: 429 });\r\n}\r\n\r\n// 2. Reuse sessions\r\nconst sessions = await puppeteer.sessions(env.MYBROWSER);\r\nconst freeSessions = sessions.filter(s => !s.connectionId);\r\nif (freeSessions.length > 0) {\r\n  const browser = await puppeteer.connect(env.MYBROWSER, freeSessions[0].sessionId);\r\n}\r\n\r\n// 3. Use tabs instead of multiple browsers\r\nconst browser = await puppeteer.launch(env.MYBROWSER);\r\nconst page1 = await browser.newPage();\r\nconst page2 = await browser.newPage(); // Same browser, different tabs\r\n```\r\n\r\n---\r\n\r\n### Issue #5: Local Development Request Size Limit\r\n\r\n**Error:** Request larger than 1MB fails in `wrangler dev`\r\n**Source:** https://developers.cloudflare.com/browser-rendering/faq/#does-local-development-support-all-browser-rendering-features\r\n**Why It Happens:** Local development limitation\r\n**Prevention:** Use `remote: true` in browser binding for local dev\r\n\r\n**Solution:**\r\n```jsonc\r\n// wrangler.jsonc for local development\r\n{\r\n  \"browser\": {\r\n    \"binding\": \"MYBROWSER\",\r\n    \"remote\": true  // Use real headless browser during dev\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n### Issue #6: Bot Protection Always Triggered\r\n\r\n**Error:** Website blocks requests as bot traffic\r\n**Source:** https://developers.cloudflare.com/browser-rendering/faq/#will-browser-rendering-bypass-cloudflares-bot-protection\r\n**Why It Happens:** Browser Rendering requests always identified as bots\r\n**Prevention:** Cannot bypass; if scraping your own zone, create WAF skip rule\r\n\r\n**Solution:**\r\n```typescript\r\n// ‚ùå Cannot bypass bot protection\r\n// Requests will always be identified as bots\r\n\r\n// ‚úÖ If scraping your own Cloudflare zone:\r\n// 1. Go to Security > WAF > Custom rules\r\n// 2. Create skip rule with custom header:\r\n//    Header: X-Custom-Auth\r\n//    Value: your-secret-token\r\n// 3. Pass header in your scraping requests\r\n\r\n// Note: Automatic headers are included:\r\n// - cf-biso-request-id\r\n// - cf-biso-devtools\r\n```\r\n\r\n---",
    "Pricing & Limits": "### Free Tier (Workers Free)\r\n\r\n| Feature | Limit |\r\n|---------|-------|\r\n| **Browser Duration** | 10 minutes per day |\r\n| **Concurrent Browsers** | 3 per account |\r\n| **New Browsers per Minute** | 3 per minute |\r\n| **REST API Requests** | 6 per minute |\r\n| **Browser Timeout** | 60 seconds (idle) |\r\n\r\n### Paid Tier (Workers Paid)\r\n\r\n| Feature | Included | Beyond Included |\r\n|---------|----------|-----------------|\r\n| **Browser Duration** | 10 hours per month | $0.09 per additional browser hour |\r\n| **Concurrent Browsers** | 10 (monthly average) | $2.00 per additional concurrent browser |\r\n| **New Browsers per Minute** | 30 per minute | Request higher limit |\r\n| **REST API Requests** | 180 per minute | Request higher limit |\r\n| **Browser Timeout** | 60 seconds (can extend to 10 minutes with `keep_alive`) | - |\r\n| **Max Concurrent Browsers** | 30 per account | Request higher limit |\r\n\r\n### Pricing Calculation\r\n\r\n**Duration Charges:**\r\n- Charged per browser hour\r\n- Rounded to nearest hour at end of billing cycle\r\n- Failed requests (timeouts) are NOT charged\r\n\r\n**Concurrency Charges:**\r\n- Monthly average of daily peak usage\r\n- Example: 10 browsers for 15 days, 20 browsers for 15 days = (10√ó15 + 20√ó15) / 30 = 15 average\r\n- 15 average - 10 included = 5 √ó $2.00 = $10.00\r\n\r\n**Example Monthly Bill:**\r\n- 50 browser hours used: (50 - 10) √ó $0.09 = $3.60\r\n- 15 concurrent browsers average: (15 - 10) √ó $2.00 = $10.00\r\n- **Total: $13.60**\r\n\r\n### Rate Limiting\r\n\r\n**Per-Second Rate:**\r\nRate limits are enforced per-second. Example:\r\n- 180 requests per minute = 3 requests per second\r\n- You cannot send all 180 at once; they must be spread evenly\r\n\r\n**Handling Rate Limits:**\r\n```typescript\r\nasync function launchWithRetry(env: Env, maxRetries = 3): Promise<Browser> {\r\n  for (let i = 0; i < maxRetries; i++) {\r\n    try {\r\n      return await puppeteer.launch(env.MYBROWSER);\r\n    } catch (error) {\r\n      if (i === maxRetries - 1) throw error;\r\n\r\n      // Check if rate limited\r\n      const limits = await puppeteer.limits(env.MYBROWSER);\r\n      if (limits.allowedBrowserAcquisitions === 0) {\r\n        // Wait before retry\r\n        const delay = limits.timeUntilNextAllowedBrowserAcquisition || 1000;\r\n        await new Promise(resolve => setTimeout(resolve, delay));\r\n      }\r\n    }\r\n  }\r\n  throw new Error(\"Failed to launch browser\");\r\n}\r\n```\r\n\r\n---",
    "Session Management": "### Why Session Management Matters\r\n\r\n**Problem**: Launching new browsers is slow and consumes concurrency limits.\r\n\r\n**Solution**: Reuse browser sessions across requests.\r\n\r\n**Benefits:**\r\n- ‚ö° Faster (no cold start)\r\n- üí∞ Lower concurrency usage\r\n- üìä Better resource utilization\r\n\r\n---\r\n\r\n### Session Reuse Pattern\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\nasync function getBrowser(env: Env): Promise<{ browser: Browser; launched: boolean }> {\r\n  // Check for available sessions\r\n  const sessions = await puppeteer.sessions(env.MYBROWSER);\r\n  const freeSessions = sessions.filter(s => !s.connectionId);\r\n\r\n  if (freeSessions.length > 0) {\r\n    // Reuse existing session\r\n    try {\r\n      const browser = await puppeteer.connect(env.MYBROWSER, freeSessions[0].sessionId);\r\n      return { browser, launched: false };\r\n    } catch (e) {\r\n      console.log(\"Failed to connect, launching new browser\");\r\n    }\r\n  }\r\n\r\n  // Launch new session\r\n  const browser = await puppeteer.launch(env.MYBROWSER);\r\n  return { browser, launched: true };\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { browser, launched } = await getBrowser(env);\r\n\r\n    try {\r\n      const page = await browser.newPage();\r\n      await page.goto(\"https://example.com\");\r\n      const screenshot = await page.screenshot();\r\n\r\n      // Disconnect (don't close) to allow reuse\r\n      await browser.disconnect();\r\n\r\n      return new Response(screenshot, {\r\n        headers: { \"content-type\": \"image/png\" }\r\n      });\r\n    } catch (error) {\r\n      await browser.close(); // Close on error\r\n      throw error;\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n**CRITICAL:**\r\n- Use `browser.disconnect()` to keep session alive\r\n- Use `browser.close()` on errors\r\n- Always handle connection failures\r\n\r\n---\r\n\r\n### Incognito Browser Contexts\r\n\r\nUse browser contexts to isolate cookies and cache while sharing a browser instance.\r\n\r\n**Benefits:**\r\n- Share browser (reduce concurrency)\r\n- Isolate sessions (separate cookies/cache)\r\n- Test multi-user scenarios\r\n\r\n**Example:**\r\n```typescript\r\nconst browser = await puppeteer.launch(env.MYBROWSER);\r\n\r\n// Create isolated contexts\r\nconst context1 = await browser.createBrowserContext();\r\nconst context2 = await browser.createBrowserContext();\r\n\r\n// Each context has its own cookies/cache\r\nconst page1 = await context1.newPage();\r\nconst page2 = await context2.newPage();\r\n\r\nawait page1.goto(\"https://app.example.com\"); // User 1\r\nawait page2.goto(\"https://app.example.com\"); // User 2\r\n\r\nawait context1.close();\r\nawait context2.close();\r\nawait browser.close();\r\n```\r\n\r\n---\r\n\r\n### Multiple Tabs vs Multiple Browsers\r\n\r\n**Scenario**: Scrape 10 URLs\r\n\r\n**‚ùå Bad (10 browsers):**\r\n```typescript\r\nfor (const url of urls) {\r\n  const browser = await puppeteer.launch(env.MYBROWSER); // 10 launches!\r\n  // ... scrape ...\r\n  await browser.close();\r\n}\r\n```\r\n\r\n**‚úÖ Good (1 browser, 10 tabs):**\r\n```typescript\r\nconst browser = await puppeteer.launch(env.MYBROWSER);\r\n\r\nconst results = await Promise.all(\r\n  urls.map(async (url) => {\r\n    const page = await browser.newPage();\r\n    await page.goto(url);\r\n    const data = await page.evaluate(() => ({\r\n      title: document.title,\r\n      text: document.body.innerText\r\n    }));\r\n    await page.close();\r\n    return { url, data };\r\n  })\r\n);\r\n\r\nawait browser.close();\r\n```\r\n\r\n**Benefit**: Uses 1 concurrent browser instead of 10.\r\n\r\n---",
    "Dependencies": "**Required:**\r\n- `@cloudflare/puppeteer@1.0.4` - Puppeteer for Workers\r\n- `wrangler@4.43.0+` - Cloudflare CLI\r\n\r\n**Optional:**\r\n- `@cloudflare/playwright@1.0.0` - Playwright for Workers (alternative)\r\n- `@cloudflare/workers-types@4.20251014.0+` - TypeScript types\r\n\r\n**Related Skills:**\r\n- `cloudflare-worker-base` - Worker setup with Hono\r\n- `cloudflare-kv` - KV caching for screenshots\r\n- `cloudflare-r2` - R2 storage for generated files\r\n- `cloudflare-workers-ai` - AI-enhanced scraping\r\n\r\n---",
    "Troubleshooting": "### Problem: \"Cannot read properties of undefined (reading 'fetch')\"\r\n**Solution:** Pass browser binding to puppeteer.launch():\r\n```typescript\r\nconst browser = await puppeteer.launch(env.MYBROWSER); // Not just puppeteer.launch()\r\n```\r\n\r\n### Problem: XPath selectors not working\r\n**Solution:** Use CSS selectors or page.evaluate() with XPathEvaluator (see Issue #1)\r\n\r\n### Problem: Browser closes after 60 seconds\r\n**Solution:** Extend timeout with keep_alive:\r\n```typescript\r\nconst browser = await puppeteer.launch(env.MYBROWSER, { keep_alive: 300000 });\r\n```\r\n\r\n### Problem: Rate limit reached\r\n**Solution:** Reuse sessions, use tabs, check limits before launching (see Issue #4)\r\n\r\n### Problem: Local dev request > 1MB fails\r\n**Solution:** Enable remote binding in wrangler.jsonc:\r\n```jsonc\r\n{ \"browser\": { \"binding\": \"MYBROWSER\", \"remote\": true } }\r\n```\r\n\r\n### Problem: Website blocks as bot\r\n**Solution:** Cannot bypass. If your own zone, create WAF skip rule (see Issue #6)\r\n\r\n---\r\n\r\n**Questions? Issues?**\r\n\r\n1. Check `references/common-errors.md` for detailed solutions\r\n2. Review `references/session-management.md` for performance optimization\r\n3. Verify browser binding is configured in wrangler.jsonc\r\n4. Check official docs: https://developers.cloudflare.com/browser-rendering/\r\n5. Ensure `nodejs_compat` compatibility flag is enabled",
    "Playwright API Reference": "Playwright provides a similar API to Puppeteer with slight differences.\r\n\r\n### Installation\r\n\r\n```bash\r\nnpm install @cloudflare/playwright\r\n```\r\n\r\n### Basic Example\r\n\r\n```typescript\r\nimport { env } from \"cloudflare:test\";\r\nimport { chromium } from \"@cloudflare/playwright\";\r\n\r\ninterface Env {\r\n  BROWSER: Fetcher;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const browser = await chromium.launch(env.BROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    await page.goto(\"https://example.com\");\r\n    const screenshot = await page.screenshot();\r\n\r\n    await browser.close();\r\n\r\n    return new Response(screenshot, {\r\n      headers: { \"content-type\": \"image/png\" }\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n### Key Differences from Puppeteer\r\n\r\n| Feature | Puppeteer | Playwright |\r\n|---------|-----------|------------|\r\n| **Import** | `import puppeteer from \"@cloudflare/puppeteer\"` | `import { chromium } from \"@cloudflare/playwright\"` |\r\n| **Launch** | `puppeteer.launch(env.MYBROWSER)` | `chromium.launch(env.BROWSER)` |\r\n| **Session API** | ‚úÖ Advanced (sessions, history, limits) | ‚ö†Ô∏è Basic |\r\n| **Auto-waiting** | Manual `waitForSelector()` | Built-in auto-waiting |\r\n| **Selectors** | CSS only | CSS, text, XPath (via evaluate workaround) |\r\n\r\n**Recommendation**: Stick with Puppeteer unless you have existing Playwright tests to migrate.\r\n\r\n---",
    "Error Handling Template": "Complete error handling for production use:\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\nasync function withBrowser<T>(\r\n  env: Env,\r\n  fn: (browser: Browser) => Promise<T>\r\n): Promise<T> {\r\n  let browser: Browser | null = null;\r\n\r\n  try {\r\n    // Check limits\r\n    const limits = await puppeteer.limits(env.MYBROWSER);\r\n    if (limits.allowedBrowserAcquisitions === 0) {\r\n      throw new Error(\"Rate limit reached. Retry after: \" + limits.timeUntilNextAllowedBrowserAcquisition + \"ms\");\r\n    }\r\n\r\n    // Launch or connect\r\n    const sessions = await puppeteer.sessions(env.MYBROWSER);\r\n    const freeSessions = sessions.filter(s => !s.connectionId);\r\n\r\n    if (freeSessions.length > 0) {\r\n      try {\r\n        browser = await puppeteer.connect(env.MYBROWSER, freeSessions[0].sessionId);\r\n      } catch {\r\n        browser = await puppeteer.launch(env.MYBROWSER);\r\n      }\r\n    } else {\r\n      browser = await puppeteer.launch(env.MYBROWSER);\r\n    }\r\n\r\n    // Execute user function\r\n    const result = await fn(browser);\r\n\r\n    // Disconnect (keep session alive)\r\n    await browser.disconnect();\r\n\r\n    return result;\r\n  } catch (error) {\r\n    // Close on error\r\n    if (browser) {\r\n      await browser.close();\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    try {\r\n      const screenshot = await withBrowser(env, async (browser) => {\r\n        const page = await browser.newPage();\r\n        await page.goto(\"https://example.com\", {\r\n          waitUntil: \"networkidle0\",\r\n          timeout: 30000\r\n        });\r\n        return await page.screenshot();\r\n      });\r\n\r\n      return new Response(screenshot, {\r\n        headers: { \"content-type\": \"image/png\" }\r\n      });\r\n    } catch (error) {\r\n      console.error(\"Browser error:\", error);\r\n      return new Response(\r\n        JSON.stringify({\r\n          error: error instanceof Error ? error.message : \"Unknown error\"\r\n        }),\r\n        { status: 500, headers: { \"content-type\": \"application/json\" } }\r\n      );\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n---",
    "Common Patterns": "### Pattern 1: Screenshot with KV Caching\r\n\r\nCache screenshots to reduce browser usage and improve performance.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n  CACHE: KVNamespace;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { searchParams } = new URL(request.url);\r\n    const url = searchParams.get(\"url\");\r\n\r\n    if (!url) {\r\n      return new Response(\"Missing ?url parameter\", { status: 400 });\r\n    }\r\n\r\n    const normalizedUrl = new URL(url).toString();\r\n\r\n    // Check cache\r\n    let screenshot = await env.CACHE.get(normalizedUrl, { type: \"arrayBuffer\" });\r\n\r\n    if (!screenshot) {\r\n      // Generate screenshot\r\n      const browser = await puppeteer.launch(env.MYBROWSER);\r\n      const page = await browser.newPage();\r\n      await page.goto(normalizedUrl);\r\n      screenshot = await page.screenshot();\r\n      await browser.close();\r\n\r\n      // Cache for 24 hours\r\n      await env.CACHE.put(normalizedUrl, screenshot, {\r\n        expirationTtl: 60 * 60 * 24\r\n      });\r\n    }\r\n\r\n    return new Response(screenshot, {\r\n      headers: { \"content-type\": \"image/png\" }\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Pattern 2: PDF Generation from HTML\r\n\r\nConvert custom HTML to PDF.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    if (request.method !== \"POST\") {\r\n      return new Response(\"Method not allowed\", { status: 405 });\r\n    }\r\n\r\n    const { html } = await request.json<{ html: string }>();\r\n\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    // Set custom HTML\r\n    await page.setContent(html, { waitUntil: \"networkidle0\" });\r\n\r\n    // Generate PDF\r\n    const pdf = await page.pdf({\r\n      format: \"A4\",\r\n      printBackground: true,\r\n      margin: {\r\n        top: \"1cm\",\r\n        right: \"1cm\",\r\n        bottom: \"1cm\",\r\n        left: \"1cm\"\r\n      }\r\n    });\r\n\r\n    await browser.close();\r\n\r\n    return new Response(pdf, {\r\n      headers: {\r\n        \"content-type\": \"application/pdf\",\r\n        \"content-disposition\": \"attachment; filename=document.pdf\"\r\n      }\r\n    });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Pattern 3: Web Scraping with Structured Data\r\n\r\nExtract structured data from web pages.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\ninterface ProductData {\r\n  title: string;\r\n  price: string;\r\n  description: string;\r\n  image: string;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { searchParams } = new URL(request.url);\r\n    const url = searchParams.get(\"url\");\r\n\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    await page.goto(url!, { waitUntil: \"networkidle0\" });\r\n\r\n    // Extract structured data\r\n    const data = await page.evaluate<ProductData>(() => {\r\n      return {\r\n        title: document.querySelector(\"h1\")?.textContent || \"\",\r\n        price: document.querySelector(\".price\")?.textContent || \"\",\r\n        description: document.querySelector(\".description\")?.textContent || \"\",\r\n        image: document.querySelector(\"img\")?.src || \"\"\r\n      };\r\n    });\r\n\r\n    await browser.close();\r\n\r\n    return Response.json({ url, data });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Pattern 4: Batch Scraping Multiple URLs\r\n\r\nEfficiently scrape multiple URLs using tabs.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\nasync function scrapeUrl(browser: Browser, url: string): Promise<any> {\r\n  const page = await browser.newPage();\r\n  try {\r\n    await page.goto(url, { waitUntil: \"networkidle0\", timeout: 30000 });\r\n\r\n    const data = await page.evaluate(() => ({\r\n      title: document.title,\r\n      url: window.location.href,\r\n      text: document.body.innerText.slice(0, 500) // First 500 chars\r\n    }));\r\n\r\n    await page.close();\r\n    return { success: true, url, data };\r\n  } catch (error) {\r\n    await page.close();\r\n    return {\r\n      success: false,\r\n      url,\r\n      error: error instanceof Error ? error.message : \"Unknown error\"\r\n    };\r\n  }\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { urls } = await request.json<{ urls: string[] }>();\r\n\r\n    if (!urls || urls.length === 0) {\r\n      return new Response(\"Missing urls array\", { status: 400 });\r\n    }\r\n\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n\r\n    // Scrape all URLs in parallel (each in its own tab)\r\n    const results = await Promise.all(\r\n      urls.map(url => scrapeUrl(browser, url))\r\n    );\r\n\r\n    await browser.close();\r\n\r\n    return Response.json({ results });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Pattern 5: AI-Enhanced Scraping\r\n\r\nCombine Browser Rendering with Workers AI to extract structured data.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n  AI: Ai;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { searchParams } = new URL(request.url);\r\n    const url = searchParams.get(\"url\");\r\n\r\n    // Scrape page content\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n    const page = await browser.newPage();\r\n    await page.goto(url!, { waitUntil: \"networkidle0\" });\r\n\r\n    const bodyContent = await page.$eval(\"body\", el => el.innerHTML);\r\n    await browser.close();\r\n\r\n    // Extract structured data with AI\r\n    const response = await env.AI.run(\"@cf/meta/llama-3.1-8b-instruct\", {\r\n      messages: [\r\n        {\r\n          role: \"user\",\r\n          content: `Extract product information as JSON from this HTML. Include: name, price, description, availability.\\n\\nHTML:\\n${bodyContent.slice(0, 4000)}`\r\n        }\r\n      ]\r\n    });\r\n\r\n    // Parse AI response\r\n    let productData;\r\n    try {\r\n      productData = JSON.parse(response.response);\r\n    } catch {\r\n      productData = { raw: response.response };\r\n    }\r\n\r\n    return Response.json({ url, product: productData });\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n### Pattern 6: Form Filling and Automation\r\n\r\nAutomate form submissions and multi-step workflows.\r\n\r\n```typescript\r\nimport puppeteer from \"@cloudflare/puppeteer\";\r\n\r\ninterface Env {\r\n  MYBROWSER: Fetcher;\r\n}\r\n\r\nexport default {\r\n  async fetch(request: Request, env: Env): Promise<Response> {\r\n    const { email, password } = await request.json<{\r\n      email: string;\r\n      password: string;\r\n    }>();\r\n\r\n    const browser = await puppeteer.launch(env.MYBROWSER);\r\n    const page = await browser.newPage();\r\n\r\n    // Navigate to login page\r\n    await page.goto(\"https://example.com/login\");\r\n\r\n    // Fill form\r\n    await page.type('input[name=\"email\"]', email);\r\n    await page.type('input[name=\"password\"]', password);\r\n\r\n    // Submit and wait for navigation\r\n    await page.click('button[type=\"submit\"]');\r\n    await page.waitForNavigation();\r\n\r\n    // Extract result\r\n    const result = await page.evaluate(() => ({\r\n      url: window.location.href,\r\n      title: document.title,\r\n      loggedIn: document.querySelector(\".user-profile\") !== null\r\n    }));\r\n\r\n    await browser.close();\r\n\r\n    return Response.json(result);\r\n  }\r\n};\r\n```\r\n\r\n---",
    "Browser Rendering Overview": "### What is Browser Rendering?\r\n\r\nCloudflare Browser Rendering provides headless Chromium browsers running on Cloudflare's global network. Use familiar tools like Puppeteer and Playwright to automate browser tasks:\r\n\r\n- **Screenshots** - Capture visual snapshots of web pages\r\n- **PDF Generation** - Convert HTML/URLs to PDFs\r\n- **Web Scraping** - Extract content from dynamic websites\r\n- **Testing** - Automate frontend tests\r\n- **Crawling** - Navigate multi-page workflows\r\n\r\n### Two Integration Methods\r\n\r\n| Method | Best For | Complexity |\r\n|--------|----------|-----------|\r\n| **Workers Bindings** | Complex automation, custom workflows, session management | Advanced |\r\n| **REST API** | Simple screenshot/PDF tasks | Simple |\r\n\r\n**This skill covers Workers Bindings** (the advanced method with full Puppeteer/Playwright APIs).\r\n\r\n### Puppeteer vs Playwright\r\n\r\n| Feature | Puppeteer | Playwright |\r\n|---------|-----------|------------|\r\n| **API Familiarity** | Most popular | Growing adoption |\r\n| **Package** | `@cloudflare/puppeteer@1.0.4` | `@cloudflare/playwright@1.0.0` |\r\n| **Session Management** | ‚úÖ Advanced APIs | ‚ö†Ô∏è Basic |\r\n| **Browser Support** | Chromium only | Chromium only (Firefox/Safari not yet supported) |\r\n| **Best For** | Screenshots, PDFs, scraping | Testing, frontend automation |\r\n\r\n**Recommendation**: Use Puppeteer for most use cases. Playwright is ideal if you're already using it for testing.\r\n\r\n---",
    "Official Documentation": "- **Browser Rendering Docs**: https://developers.cloudflare.com/browser-rendering/\r\n- **Puppeteer API**: https://pptr.dev/api/\r\n- **Playwright API**: https://playwright.dev/docs/api/class-playwright\r\n- **Cloudflare Puppeteer Fork**: https://github.com/cloudflare/puppeteer\r\n- **Cloudflare Playwright Fork**: https://github.com/cloudflare/playwright\r\n- **Pricing**: https://developers.cloudflare.com/browser-rendering/platform/pricing/\r\n- **Limits**: https://developers.cloudflare.com/browser-rendering/platform/limits/\r\n\r\n---",
    "Package Versions (Verified 2025-10-22)": "```json\r\n{\r\n  \"dependencies\": {\r\n    \"@cloudflare/puppeteer\": \"^1.0.4\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@cloudflare/workers-types\": \"^4.20251014.0\",\r\n    \"wrangler\": \"^4.43.0\"\r\n  }\r\n}\r\n```\r\n\r\n**Alternative (Playwright):**\r\n```json\r\n{\r\n  \"dependencies\": {\r\n    \"@cloudflare/playwright\": \"^1.0.0\"\r\n  }\r\n}\r\n```\r\n\r\n---",
    "Production Checklist": "Before deploying Browser Rendering Workers to production:\r\n\r\n### Configuration\r\n- [ ] **Browser binding configured** in wrangler.jsonc\r\n- [ ] **nodejs_compat flag enabled** (required for Browser Rendering)\r\n- [ ] **Keep-alive timeout set** if tasks take > 60 seconds\r\n- [ ] **Remote binding enabled** for local development if needed\r\n\r\n### Error Handling\r\n- [ ] **Retry logic implemented** for rate limits\r\n- [ ] **Timeout handling** for page.goto()\r\n- [ ] **Browser cleanup** in try-finally blocks\r\n- [ ] **Concurrency limit checks** before launching browsers\r\n- [ ] **Graceful degradation** when browser unavailable\r\n\r\n### Performance\r\n- [ ] **Session reuse implemented** for high-traffic routes\r\n- [ ] **Multiple tabs used** instead of multiple browsers\r\n- [ ] **Incognito contexts** for session isolation\r\n- [ ] **KV caching** for repeated screenshots/PDFs\r\n- [ ] **Batch operations** to maximize browser utilization\r\n\r\n### Monitoring\r\n- [ ] **Log browser session IDs** for debugging\r\n- [ ] **Track browser duration** for billing estimates\r\n- [ ] **Monitor concurrency usage** with puppeteer.limits()\r\n- [ ] **Alert on rate limit errors**\r\n- [ ] **Dashboard monitoring** at https://dash.cloudflare.com/?to=/:account/workers/browser-rendering\r\n\r\n### Security\r\n- [ ] **Input validation** for URLs (prevent SSRF)\r\n- [ ] **Timeout limits** to prevent abuse\r\n- [ ] **Rate limiting** on public endpoints\r\n- [ ] **Authentication** for sensitive scraping endpoints\r\n- [ ] **WAF rules** if scraping your own zone\r\n\r\n### Testing\r\n- [ ] **Test screenshot capture** with various page sizes\r\n- [ ] **Test PDF generation** with custom HTML\r\n- [ ] **Test scraping** with dynamic content (networkidle0)\r\n- [ ] **Test error scenarios** (invalid URLs, timeouts)\r\n- [ ] **Load test** concurrency limits\r\n\r\n---",
    "Using Bundled Resources": "cp ~/.claude/skills/cloudflare-browser-rendering/templates/basic-screenshot.ts src/index.ts\r\n```\r\n\r\n### References (references/)\r\n\r\nDeep-dive documentation:\r\n\r\n- `session-management.md` - Complete session reuse guide\r\n- `pricing-and-limits.md` - Detailed pricing breakdown\r\n- `common-errors.md` - All known issues and solutions\r\n- `puppeteer-vs-playwright.md` - Feature comparison and migration\r\n\r\n**When to load:** Reference when implementing advanced patterns or debugging specific issues.\r\n\r\n---",
    "Puppeteer API Reference": "### puppeteer.launch()\r\n\r\nLaunch a new browser instance.\r\n\r\n**Signature:**\r\n```typescript\r\nawait puppeteer.launch(binding: Fetcher, options?: LaunchOptions): Promise<Browser>\r\n```\r\n\r\n**Parameters:**\r\n- `binding` (required) - Browser binding from `env.MYBROWSER`\r\n- `options` (optional):\r\n  - `keep_alive` (number) - Keep browser alive for N milliseconds (max: 600000 = 10 minutes)\r\n\r\n**Returns:** `Promise<Browser>` - Browser instance\r\n\r\n**Example:**\r\n```typescript\r\nconst browser = await puppeteer.launch(env.MYBROWSER, {\r\n  keep_alive: 60000 // Keep alive for 60 seconds\r\n});\r\n```\r\n\r\n**CRITICAL:** Must pass `env.MYBROWSER` binding. Error \"Cannot read properties of undefined (reading 'fetch')\" means the binding wasn't passed.\r\n\r\n---\r\n\r\n### puppeteer.connect()\r\n\r\nConnect to an existing browser session.\r\n\r\n**Signature:**\r\n```typescript\r\nawait puppeteer.connect(binding: Fetcher, sessionId: string): Promise<Browser>\r\n```\r\n\r\n**Use Cases:**\r\n- Reuse existing browser sessions for performance\r\n- Share browser instance across multiple Workers\r\n- Reduce startup time\r\n\r\n**Example:**\r\n```typescript\r\nconst sessionId = \"478f4d7d-e943-40f6-a414-837d3736a1dc\";\r\nconst browser = await puppeteer.connect(env.MYBROWSER, sessionId);\r\n```\r\n\r\n---\r\n\r\n### puppeteer.sessions()\r\n\r\nList currently running browser sessions.\r\n\r\n**Signature:**\r\n```typescript\r\nawait puppeteer.sessions(binding: Fetcher): Promise<SessionInfo[]>\r\n```\r\n\r\n**Returns:**\r\n```typescript\r\ninterface SessionInfo {\r\n  sessionId: string;\r\n  startTime: number;\r\n  connectionId?: string;  // Present if worker is connected\r\n  connectionStartTime?: number;\r\n}\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nconst sessions = await puppeteer.sessions(env.MYBROWSER);\r\n// Find sessions without active connections\r\nconst freeSessions = sessions.filter(s => !s.connectionId);\r\n```\r\n\r\n---\r\n\r\n### puppeteer.history()\r\n\r\nList recent sessions (both open and closed).\r\n\r\n**Signature:**\r\n```typescript\r\nawait puppeteer.history(binding: Fetcher): Promise<HistoryEntry[]>\r\n```\r\n\r\n**Returns:**\r\n```typescript\r\ninterface HistoryEntry {\r\n  sessionId: string;\r\n  startTime: number;\r\n  endTime?: number;\r\n  closeReason?: number;\r\n  closeReasonText?: string; // \"NormalClosure\", \"BrowserIdle\", etc.\r\n}\r\n```\r\n\r\n**Use Case:** Monitor usage patterns and debug session issues.\r\n\r\n---\r\n\r\n### puppeteer.limits()\r\n\r\nCheck current account limits and available sessions.\r\n\r\n**Signature:**\r\n```typescript\r\nawait puppeteer.limits(binding: Fetcher): Promise<LimitsInfo>\r\n```\r\n\r\n**Returns:**\r\n```typescript\r\ninterface LimitsInfo {\r\n  activeSessions: Array<{ id: string }>;\r\n  maxConcurrentSessions: number;\r\n  allowedBrowserAcquisitions: number;\r\n  timeUntilNextAllowedBrowserAcquisition: number; // milliseconds\r\n}\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nconst limits = await puppeteer.limits(env.MYBROWSER);\r\nif (limits.allowedBrowserAcquisitions === 0) {\r\n  return new Response(\"Rate limit reached\", { status: 429 });\r\n}\r\n```\r\n\r\n---\r\n\r\n### Browser API\r\n\r\nMethods available on the `Browser` object returned by `launch()` or `connect()`.\r\n\r\n#### browser.newPage()\r\n\r\nCreate a new page (tab) in the browser.\r\n\r\n**Signature:**\r\n```typescript\r\nawait browser.newPage(): Promise<Page>\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nconst page = await browser.newPage();\r\nawait page.goto(\"https://example.com\");\r\n```\r\n\r\n**Performance Tip:** Reuse browser instances and open multiple tabs instead of launching new browsers.\r\n\r\n---\r\n\r\n#### browser.sessionId()\r\n\r\nGet the current browser session ID.\r\n\r\n**Returns:** `string` - Session ID\r\n\r\n**Example:**\r\n```typescript\r\nconst sessionId = browser.sessionId();\r\nconsole.log(\"Current session:\", sessionId);\r\n```\r\n\r\n---\r\n\r\n#### browser.close()\r\n\r\nClose the browser and terminate the session.\r\n\r\n**Signature:**\r\n```typescript\r\nawait browser.close(): Promise<void>\r\n```\r\n\r\n**When to use:** When you're completely done with the browser and want to free resources.\r\n\r\n---\r\n\r\n#### browser.disconnect()\r\n\r\nDisconnect from the browser WITHOUT closing it.\r\n\r\n**Signature:**\r\n```typescript\r\nawait browser.disconnect(): Promise<void>\r\n```\r\n\r\n**When to use:** Session reuse - allows another Worker to connect to the same session later.\r\n\r\n**Example:**\r\n```typescript\r\n// Keep session alive for reuse\r\nconst sessionId = browser.sessionId();\r\nawait browser.disconnect(); // Don't close, just disconnect\r\n// Later: puppeteer.connect(env.MYBROWSER, sessionId)\r\n```\r\n\r\n---\r\n\r\n#### browser.createBrowserContext()\r\n\r\nCreate an isolated incognito browser context.\r\n\r\n**Signature:**\r\n```typescript\r\nawait browser.createBrowserContext(): Promise<BrowserContext>\r\n```\r\n\r\n**Use Cases:**\r\n- Isolate cookies and cache between operations\r\n- Test multi-user scenarios\r\n- Maintain session isolation while reusing browser\r\n\r\n**Example:**\r\n```typescript\r\nconst context1 = await browser.createBrowserContext();\r\nconst context2 = await browser.createBrowserContext();\r\n\r\nconst page1 = await context1.newPage();\r\nconst page2 = await context2.newPage();\r\n\r\n// page1 and page2 have separate cookies/cache\r\n```\r\n\r\n---\r\n\r\n### Page API\r\n\r\nMethods available on the `Page` object returned by `browser.newPage()`.\r\n\r\n#### page.goto()\r\n\r\nNavigate to a URL.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.goto(url: string, options?: NavigationOptions): Promise<Response>\r\n```\r\n\r\n**Options:**\r\n- `waitUntil` - When to consider navigation complete:\r\n  - `\"load\"` - Wait for load event (default)\r\n  - `\"domcontentloaded\"` - Wait for DOMContentLoaded\r\n  - `\"networkidle0\"` - Wait until no network connections for 500ms\r\n  - `\"networkidle2\"` - Wait until ‚â§2 network connections for 500ms\r\n- `timeout` - Maximum navigation time in milliseconds (default: 30000)\r\n\r\n**Example:**\r\n```typescript\r\nawait page.goto(\"https://example.com\", {\r\n  waitUntil: \"networkidle0\",\r\n  timeout: 60000\r\n});\r\n```\r\n\r\n**Best Practice:** Use `\"networkidle0\"` for dynamic content, `\"load\"` for static pages.\r\n\r\n---\r\n\r\n#### page.screenshot()\r\n\r\nCapture a screenshot of the page.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.screenshot(options?: ScreenshotOptions): Promise<Buffer>\r\n```\r\n\r\n**Options:**\r\n- `fullPage` (boolean) - Capture full scrollable page (default: false)\r\n- `type` (string) - `\"png\"` or `\"jpeg\"` (default: `\"png\"`)\r\n- `quality` (number) - JPEG quality 0-100 (only for jpeg)\r\n- `clip` (object) - Capture specific region: `{ x, y, width, height }`\r\n\r\n**Examples:**\r\n```typescript\r\n// Full page screenshot\r\nconst screenshot = await page.screenshot({ fullPage: true });\r\n\r\n// JPEG with compression\r\nconst screenshot = await page.screenshot({\r\n  type: \"jpeg\",\r\n  quality: 80\r\n});\r\n\r\n// Specific region\r\nconst screenshot = await page.screenshot({\r\n  clip: { x: 0, y: 0, width: 800, height: 600 }\r\n});\r\n```\r\n\r\n---\r\n\r\n#### page.pdf()\r\n\r\nGenerate a PDF of the page.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.pdf(options?: PDFOptions): Promise<Buffer>\r\n```\r\n\r\n**Options:**\r\n- `format` (string) - Page format: `\"Letter\"`, `\"A4\"`, etc.\r\n- `printBackground` (boolean) - Include background graphics (default: false)\r\n- `margin` (object) - `{ top, right, bottom, left }` (e.g., `\"1cm\"`)\r\n- `landscape` (boolean) - Landscape orientation (default: false)\r\n- `scale` (number) - Scale factor 0.1-2 (default: 1)\r\n\r\n**Example:**\r\n```typescript\r\nconst pdf = await page.pdf({\r\n  format: \"A4\",\r\n  printBackground: true,\r\n  margin: { top: \"1cm\", right: \"1cm\", bottom: \"1cm\", left: \"1cm\" }\r\n});\r\n\r\nreturn new Response(pdf, {\r\n  headers: { \"content-type\": \"application/pdf\" }\r\n});\r\n```\r\n\r\n---\r\n\r\n#### page.content()\r\n\r\nGet the full HTML content of the page.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.content(): Promise<string>\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nconst html = await page.content();\r\nconsole.log(html); // Full HTML source\r\n```\r\n\r\n---\r\n\r\n#### page.setContent()\r\n\r\nSet custom HTML content.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.setContent(html: string, options?: NavigationOptions): Promise<void>\r\n```\r\n\r\n**Use Case:** Generate PDFs from custom HTML.\r\n\r\n**Example:**\r\n```typescript\r\nawait page.setContent(`\r\n  <!DOCTYPE html>\r\n  <html>\r\n    <head><style>body { font-family: Arial; }</style></head>\r\n    <body><h1>Hello World</h1></body>\r\n  </html>\r\n`);\r\n\r\nconst pdf = await page.pdf({ format: \"A4\" });\r\n```\r\n\r\n---\r\n\r\n#### page.evaluate()\r\n\r\nExecute JavaScript in the browser context.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.evaluate<T>(fn: () => T): Promise<T>\r\n```\r\n\r\n**Use Cases:**\r\n- Extract data from the DOM\r\n- Manipulate page content\r\n- Workaround for XPath (not directly supported)\r\n\r\n**Examples:**\r\n```typescript\r\n// Extract text content\r\nconst title = await page.evaluate(() => document.title);\r\n\r\n// Extract structured data\r\nconst data = await page.evaluate(() => ({\r\n  title: document.title,\r\n  url: window.location.href,\r\n  headings: Array.from(document.querySelectorAll(\"h1, h2\")).map(el => el.textContent),\r\n  links: Array.from(document.querySelectorAll(\"a\")).map(el => el.href)\r\n}));\r\n\r\n// XPath workaround (XPath selectors not directly supported)\r\nconst innerHtml = await page.evaluate(() => {\r\n  return new XPathEvaluator()\r\n    .createExpression(\"/html/body/div/h1\")\r\n    .evaluate(document, XPathResult.FIRST_ORDERED_NODE_TYPE)\r\n    .singleNodeValue.innerHTML;\r\n});\r\n```\r\n\r\n---\r\n\r\n#### page.waitForSelector()\r\n\r\nWait for an element to appear in the DOM.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.waitForSelector(selector: string, options?: WaitForOptions): Promise<ElementHandle>\r\n```\r\n\r\n**Options:**\r\n- `timeout` (number) - Maximum wait time in milliseconds\r\n- `visible` (boolean) - Wait for element to be visible\r\n\r\n**Example:**\r\n```typescript\r\nawait page.goto(\"https://example.com\");\r\nawait page.waitForSelector(\"#content\", { visible: true });\r\nconst screenshot = await page.screenshot();\r\n```\r\n\r\n---\r\n\r\n#### page.type()\r\n\r\nType text into an input field.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.type(selector: string, text: string): Promise<void>\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nawait page.type('input[name=\"email\"]', 'user@example.com');\r\n```\r\n\r\n---\r\n\r\n#### page.click()\r\n\r\nClick an element.\r\n\r\n**Signature:**\r\n```typescript\r\nawait page.click(selector: string): Promise<void>\r\n```\r\n\r\n**Example:**\r\n```typescript\r\nawait page.click('button[type=\"submit\"]');\r\nawait page.waitForNavigation();\r\n```\r\n\r\n---"
  }
}